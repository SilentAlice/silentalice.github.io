<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用V2Ray]]></title>
    <url>%2Fblog%2F2023%2F03%2F26%2Fv2ray%2F</url>
    <content type="text"><![CDATA[在服务器上部署自己的端口转发服务，V2ray是一个非常好的选择。 目前V2ray支持多种协议，拥有方便的Android与Windows客户端， Linux上的配置文件简单方便，本篇记录V2ray的使用与配置方式。 LinksV2ray的相关仓可以直接从github上进行获取: Main: https://github.com/v2ray MacOS: https://github.com/v2ray/homebrew-v2ray Android: https://github.com/v2ray/V2RayNG Windows: https://github.com/2dust/v2rayN Other Awesome tools: https://www.v2ray.com/en/awesome/tools.html Installation官方一键安装脚本: https://github.com/v2fly/fhs-install-v2ray Configs Path: /usr/local/etc/v2ray/config.json Manual: https://v2ray.com Sample: https://www.v2ray.com/en/welcome/start.html Using as serverconfig.json1234567891011121314&#123; "inbounds": [&#123; // Server port, need to add TCP security policy in AWS security group "port": 11223, "protocol": "vmess", "settings": &#123; "clients": [&#123; "id": "81498305-0be0-4923-a270-df4e490a086b" &#125;] // Same as client &#125; &#125;], "outbounds": [&#123; "protocol": "freedom", "settings": &#123;&#125; &#125;]&#125; Using as clientconfig.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&#123; "log": &#123; "access": "/var/log/v2ray/log", "error": "/var/log/v2ray/log", "loglevel": "error" &#125;, // Accept local socks request "inbounds": [&#123; "listen": "127.0.0.1", "port": 11112, "protocol": "socks", "tag": "socks-inbound", "settings": &#123; "auth": "noauth", "udp": true, "userlevel": 8, "ip": "127.0.0.1" &#125;, "sniffing": &#123; "enabled": true, "destOverride": ["http", "tls"] &#125; &#125;, // Accept local http request &#123; "listen": "127.0.0.1", "port": 11111, "protocol": "http", "tag": "http-inbound", "settings": &#123; "userlevel": 8 &#125; &#125;], // Transfer to vps server using vmess "outbounds": [&#123; "mux": &#123; "concurrency": -1, "enabled": false &#125;, "protocol": "vmess", "settings": &#123; "vnext": [&#123; "address": "server.ip.address", "port": 11223, // Same as server "users": [&#123; "alterId": 0, "id": "81498305-0be0-4923-a270-df4e490a086b", "security": "auto", "level": 8 &#125;] &#125;] &#125;, "streamSettings": &#123; "network": "tcp", "security":"" &#125;, "tag": "proxy" &#125;, &#123; "protocol": "blackhole", "settings": &#123;&#125;, "tag": "blocked" &#125;, &#123; "protocol": "freedom", "settings": &#123;&#125;, "tag": "direct" &#125;], "routing": &#123; "domainStrategy": "IPIfNonMatch", "rules":[ ] &#125;, "dns": &#123; "hosts": &#123; "domain:github.io": "pages.github.com", "domain:wikipedia.org": "www.wikimedia.org", "domain:shadowsocks.org": "electronicsrealm.com", "domain:googleapis.cn": "googleapis.com" &#125;, "servers": [ "1.1.1.1" ] &#125;, "policy": &#123; "levels": &#123; "8": &#123; "connIdle": 300, "uplinkOnly": 1, "handshake": 4, "downlinkOnly": 1 &#125; &#125;, "system": &#123; "statsInboundUplink": false, "statsInboundDownlink": false, "statsOutboundUplink": false, "statsOutboundDownlink": false &#125; &#125;&#125; Running serviceDirectly Run: 1v2ray --config /usr/local/etc/v2ray/config.json &amp; Start as systemd service Linux123# Set v2ray as startup servicesudo systemctl enable v2raysudo systemctl start v2ray MacOS1sudo brew services start v2ray Note]]></content>
      <tags>
        <tag>tutorial</tag>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上海隔离生活记]]></title>
    <url>%2Fblog%2F2023%2F03%2F26%2Fshanghai-quarantine-life%2F</url>
    <content type="text"><![CDATA[昨晚做了个梦，梦见自己出差去广州，然后开车跑到了越南的“久岐市”，车的手刹还不太灵…… 入关的时候海关人员和蔼地跟我说，当地防疫已经不需要带口罩了， 但长期处于严格防疫状态的我还是坚持带着口罩参观。 跟随导览观看了一处活火山的岩浆， 火山口有一个像绿巨人一样的人从口中向游客吐出岩浆球， 我害怕地看向导览，导览一笑：“这个是表演……”， 我还对此啧啧称奇。 在路上遇到了同样本该在上海隔离的朋友， 我们相视一笑，而此刻岩浆球喷到了我把我喷醒了…… 我寻思可能是居家时间太久，连梦里都变成了离开上海出国旅游。 所玩的游戏要出一个角色叫“久岐忍”，可能因此我到达了一个不存在的“久岐市”; 所玩的另一款游戏有一个经常使用的技能“岩石球”，所以在梦里见到了岩浆球吧。 至于为什么是从广东开车跑到越南，说实话我也摸不着头脑， 想来想去可能需要写篇日记缓和一下自己的居家情绪， 免得时间更长梦里出来更多乱七八糟的东西， 因此有了此文。 3月初开始上海每日就有着零星的病例，可能是香港输入，也可能是其他地方的传播， 那时住在上海的打工人没有人会想到不到一个月，上海的疫情会扩散到全民封城的地步。 平日两点一线往返于工作地与家，与我一样寄居在出租屋的打工仔们， 又有多少心理与实际的准备，来面对着突如其来的长时间封城呢？ 决赛圈的小区从3月初开始就有同事因为次密接等原因陆陆续续被要求居家隔离， 尤其是由于工作的原因我们一些同事需要往返于广深与上海， 在深圳疫情扩散的那段时间，去过广深的同事都根据当地的各种政策有过不同长度的隔离。 在那时上海每日只有零星几个病例，我深圳在3月中旬还能够去南京出差， 即使是后续的动态网格核算筛查，我们小区以出色的全阴表现， 从未有人被要求居家或无法到达工作岗位。看着同事的小区一个个跑毒[1]失败， 决赛圈[1]的我甚至还想居家两天来体验一下隔离生活的感觉， 毕竟最差也不会比2020年差嘛，每天可以多睡半小时， 叫外卖就能过活，看起来也没那么糟糕？ 和同一小区的同学每天回家路上也会是不是调侃， 就像在游戏里处于决赛圈的玩家都会开心的看着跑毒玩家一样， 我们也在调侃中似乎忘记了真实的世界里又怎会留出一个“安全区”呢？ 3月26日，周六，加班下班回来的路上，同一小区的同学X从舍友处得知，我们小区要被封了， 闻此，我们屁颠屁颠跑到盒马置办了一些物资，买的时候是以居家2-4天为考虑的， 因为根据之前的经验，这次只是动态网格排查到了我们小区而已， 不出意外48小时就会解封。 这是3人买的物资，我主要买了些零食和水果。 急转而下的形势从盒马回来的路上，我们路径一个小区正在被工人用木板围住， “可能是防止通过栏杆拿外卖导致疫情扩散吧？”同学X发出了这样的猜疑， 而那一声声咚咚钉木板的声音都预示着这次疫情的不乐观， 当身边看到了如此严格的封闭时，自己才会切身体会到疫情已经扩散到了自己身边。 3月26日晚，我们听到楼下有不寻常的声音，下楼一看惊讶的发现也被木板隔离了， 而且我们和同学X是同一小区的，在小区内部竟然也拉起了木板， 两边要各自走各自的大门。“难道是对面出了什么意外？担心扩散到我们这边所以拉起了木板？” 这是我的第一反应，而当晚上同学X在群内说被大白检测了核酸后， 更加印证了我的这一猜想。 3月27日，大白开始对我们进行了核酸，与之相配的是，小区的另一半解除了封闭， 而我们这边则开始了严格的消杀。？！这木板原来是为了隔离我们！原来是我们这侧出现了病例！ 看来这封城一时半会要好不了了。与此同时我和舍友则泛起些微的担忧， 看着空空的厨房，长期两点一线的我们哪会预料到这个？空有炉灶但没有一口锅， 微波炉、电磁炉、碗碟筷一概没有！所幸两人各有一个烧水壶，还有角落里的几盒泡面， 加上刚买的盒马物资，一周时间还是能熬过去的，大概吧。 木板的另一边就是小区的另一半，也是同学X所在的一半，我们这一半打开了平时许久不用的另一个大门， 在大门处有一条过道和好几个货架，当外卖与快递送来时，社区志愿者会进行消杀后放到货架上， 等我们到达后再让志愿者拿给我们以实现全程的无接触配送。 外卖小哥就是我的再生父母所幸现在只是我们小区被封闭，外卖依旧可以点，就是因为被封的小区有点多，选择的余地少些罢了。 3.27 星期日； 早：沙琪玛+牛奶; 中：泡面; 晚：蜀相人家外卖 周末过得似乎没什么不同，我依旧乐呵呵打开老头环打了一天，美哉美哉。 中午吃泡面纯粹是因为游戏打久了，点外卖等不及了，嘿嘿 3.28 早：沙琪玛；中：凉皮肉夹馍；晚：泡面 周一我们申请了居家办公，作为IT行业居家办公与在公司办公除了沟通效率有所降低外没什么不同， 自己的行业受疫情影响较小，自己的职位也和消费民生关系不大，所以工作依旧~ 晚上17:00快下半时打开了饿了么与美团却惊愕地发现所有的店家都关!门!了！ 其实下午16:00店家就都关了，外卖也没了，晚上只能再吃一份泡面， 我心里隐隐感觉到了不安，至少……明天中午订餐的时候把全天的饭都买了吧。 3.29 早：舍友的蛋糕；中：番茄鸡蛋盖浇饭；晚：中午一起买的水饺 和预想的一样，下午一过16:00就没有了外卖，舍友靠着买的许多烘培度过，而我晚上则吃着不热不冷的水饺。 看着形势越来越不对劲，当晚我就买了第二天的饭，找了一家还在营业的餐馆，定了几个不错的菜： 鱼香肉丝饭、麻婆豆腐饭、虾仁炒蛋。改善一下伙食吧！ 3.30 早: 舍友的面包; 中：泡面；晚：！！！ 从早上上班开始我就时不时刷着APP看着外卖的进度， 外卖小哥从早上11点不到就开始在餐馆等，到了快13:00依旧在等， 而我等不及便又泡了一桶泡面。 到了14:30，外卖小哥等不及了，取消了配送。我赶紧在APP上要了小哥微信以此了解情况。 外卖小哥也是有责任心的好人，担心我吃不到饭说帮我解决， 他找了家不在线上的餐馆，发了一个长长的菜单让我挑， 我的眼中瞬间燃起了希望，直接下单3份饭菜，保证了晚上和第二天的伙食。 真是佩服自己的智慧，也就这样我通过一个没有点到的外卖认识了一位外卖小哥， 让小哥帮我直接买饭，这样这几天不就都可以快活过了？哈哈哈，佩服自己！ 我给了小哥双倍的路费以示感谢。 订单在下午15:30左右我也识相地取消了，这份饭也是不可能送到了，但是也因此认识了一位外卖小哥。 晚上我吃的非常好，毕竟这是几天晚上吃的最热乎与丰盛的晚餐了，3种菜样，都是下饭的： 青椒肉丝、番茄炒蛋、麻婆豆腐；舍友这两天买到了一次KFC，5个汉堡和各类炸鸡， 真的是各凭本事了。 3.31 早：沙琪玛；中：昨天小哥买的饭; 晚：水饺 在外卖平台上发现一家卖牛肉面的店家在卖冻饺，二话不说下单买了几份，在中午消耗掉小哥的饭后晚上吃了份冻饺。 你问隔夜饭怎么加热？为什么不继续找小哥帮买？我没有锅怎么煮的冻饺？ 隔夜饭是通过煮水壶烧水然后蒸热的，后面两点只能说情况每时每秒都在改变，我也只能随机应变了…… 热心、负责、温柔的楼组长阿姨！没错，3月31日，上海宣布封城了，这个拉不下脸的城市正式放低了身段开始进行了封城， 说什么先封浦东后封浦西只不过是自欺欺人的说法，封城就是封城。 在这里我也不散播什么不可信的阴谋论，但是前期防疫的不坚决是这次疫情扩散的主要原因， 至少开始封城意味着态度与风向的转变，也算是好事吧。 只不过封城前的狂欢则让人实在气不过管理者的愚钝， 前几日只是我们小区被封，但是很多小区是正常的，因此在封城通知前大家进行了几小时的疯狂购物， 其结果嘛不用想也知道会导致大规模聚集…… 不知是不是提前预感到了这一点，外卖小哥在昨晚便告诉我31日不再出来送货， 这也是我当晚无法继续找小哥买饭的原因, 看来找外卖小哥这条路也断了…… 我们小区是一个基层动作执行非常规范的小区，拜提前封闭所赐， 志愿者、居委准备的非常充足，每个楼栋都有楼组长负责帮我们团购物资。 我们的楼组长是一位住在这里的上海本地阿姨， 阿姨人好心善，得知我们没有锅之后慷慨地借给了我们一口锅， 这样团购买的菜至少可以煮了。 好巧不巧，因为我喜欢吃椰子、苹果之类的，刚好买了水果刀和削皮器； 为了减少一次性筷子使用，之前买了自己的筷子和洗洁精； 之前搬过来时因为买过烧烤用的高级海盐，舍不得丢所以带了一袋盐； 曾经帮社区做过一词问卷调研，当时送了个案板，现在还没拆封； 刚好同一小区有另两位同学，其中一位在封城前去了女友那边， 我和舍友找他们借了碗、碟、铲、酱油……这不，真是好巧不巧，做饭的东西齐活了！ 这里要感谢热心的楼组长！比心！ 自给自足的日子4月1日是上海开始正式封城的日子，也是我开始居家自己做饭的日子。 舍友是个作息比我规律的人，早上会去APP上抢菜， 多亏他买到了好几次像海底捞、牛奶、肉品、蛋糕等改善生活品质的物资。 我则像个寄生虫一样蹲在楼组长的群里面每时每秒等着楼组长发起的团购， 每天都有着不错的伙食，就是每天要多花一些时间做饭， 而且一口锅又蒸米、又炒菜效率还是低啊…… (食物流水账放文章末尾了) 感想必须点赞的社区这次居家生活质量的好坏完全取决于社区基层的执行能力， 政府能够做到的只有调配物资，但联系团购、分配到家、信息收集与统计等等都需要社区来完成， 我们社区是一个比较老的上海本地社区，不乏老人。 但是社区阿姨大叔真的十分负责，令人感动。 核酸检测井井有序，按栋检测。团购物资虽然说不上丰富，但至少可以解决温饱， 一周一到两次的不限量团购大可以让自己过上不饿肚子的生活。 相比一些小区物资送不到，物业没人，有的小区生硬的不允许外部物资进入小区， 美其名曰防止外部感染，全然不顾里面居住的居民生活。 基层的执行动作不到位导致上海的负面新闻频出， 作为一个生活在防疫区的人，身边确有同事饿过肚子，抢不到菜， 和开始的我一样没有炊具的人也不少，依靠着泡面、面包糕点惶惶度日。 但这都是基层执行的问题，经过一周的阵痛期，之前了解到的生活较为惨淡的同事现在也基本上好了起来， 大体向好。 我身边有这么好的社区实在不易，尤其还是较老的小区， 不是通过物业而是通过居民组成的居委做的这么专业，令人不得不佩服。 也希望疫情能够快速过去，大家也多给基层一些鼓励和信心。 平时的未雨绸缪这波疫情结束后，消毒物资、炊具我肯定会常备了， 从来没有想到某一天会因为吃不到东西而担忧， 果然是好日子过惯了呢。 同样的，掌握做饭的本事也至关重要， 自己之前练习过一些菜肴让只有一口锅的我在居家时也不会显得那么不安。 一些不贵的东西：水果刀、削皮器、洗洁精，在这种时候竟然显得这么好用！ 平时赚再多的钱又有什么用？连自己的生活都顾不好怎是一个合格的打工仔！ 前期拉跨的防疫这次疫情上海的动作和执行网上流传的说法很多， 无论上海的当局者想要怎么做都无法否认这次上海前期的防疫是失败的。 在上海实行动态网格的时候我就不以为然，作为曾经横穿上海上班的我， 每日来回往返不同区域的人大有人在，封一部分小区放一部分小区并不能阻断病毒传播的路径， 最多减少了病毒传播的效率，但是对于动态清零的政策来讲没有任何用处。 即便被全网职责时，也依旧有发言人在发布会上声称上海是全国的上海，不能封云云。 试想深圳作为制造业集中的沿海大市，港口众多，紧接香港都能坚决封城从而快速清零， 上海这一说辞实在算不上合理，反而体现了些许的傲慢，按理说金融中心白领众多， 大部分可以居家办公，封城带来的影响会更小才是。 所幸后面还是老实封城了。 共存的思潮在3月中旬我曾出差到南京， 当时与其他属地的同事交流时就有人提过当前严格的防疫可能是既得利益集团想要从医保中赚取抗疫拨款， 毕竟检测试剂也是门生意，奥密克戎变种根据西方的研究大部分都是轻症，可以自愈，其实可以共存的。 不知是否是这一思潮在金融中心更易发散，身边确实有不少这么认为的同事， 但是当人民打完疫苗之后才达到和流感一样的死亡率时， 当已经有了如此充足的应对之后才勉强和流感差不多时， 我很难将它和流感划等号。 美国逐年增多的死亡人数、有着特效药和疫苗却被疫情一轮轮清洗的日子又如何说服我共存是合理的呢？ 更别说那些后遗症，谁知道下一个踩狗屎的是不是自己呢？ 当然后续上海的抢菜难更加坚定了我认为必须清零的信念。 毕竟连菜都抢不到，等疫情铺开后又怎么保证自己能抢到一张病床呢？ 独居与合租，本地与外地刚毕业有段时间我也是一人独居，一居室没有厨房，只有一个烧水壶和微波炉， 如果现在还住在这样的环境中，可以想象当封城来临时生活会受到多大的打击。 说艰难，和艰苦地区相比似乎又有些矫情，但不适应是一定的。 生活上的不适应好歹还能看到改进的希望， 心理上的不适应则需要认真纾解。 本地的同学有许多朋友，在群里大家一起聊天可以一定程度上缓解一个人的孤独， 但是同样也能更多看到身边人生活的艰难，亦容易变成负能量的聚集地。 同学X是上海本地人，当作为子女发现自己的父母也因为疫情吃不上菜， 帮父母凌晨起来抢菜又空手而归时，那种焦虑与不安让本就不好的自己更受打击。 若是一个人生活则更容易产生心理的阴暗。 可见平时还是需要一个能全身心投入的爱好， 哪怕它看起来是不务正业的游戏、动漫， 但这些爱好能在生活的低估让我们保持乐观， 所以我以后一定要找一个不会阻止我打游戏看动漫的妹子！ 作为一个外地来到上海的人，我庆幸于大部分认识的朋友都不在上海， 我的母亲在家乡非常安全，生活充实；我的同学在其他城市正常工作， 尤其是一些以表演、翻译等等为生的自由职业者， 他们所在的城市没有停止相关的场所，也让他免于因为封城找不到工作带来的焦虑。 整体上我只要考虑自己，只要让自己过好就能让父母朋友免于担心。 老头环还没有打完、原神更新了新地图、4月新番开播、挖的画画坑已搁置了很久…… 想要做的事情太多，只要吃的解决了、工作还在，再居家更长的时间于我也无所谓！ 多一些信心说实话一些负面消息是真实的， 但谣言也满天飞， 更有甚者在业主群掀起混乱， 鼓吹动乱的外部势力渗透。 在这样一个特殊的时期， 更重要的还是坚持清零的政策。 即使纠正底层执行的死板， 比如封城的第二周，之前买菜难的小区也陆陆续续收到了政府的物资。 外部省份对上海的敌视也可以理解， 毕竟外溢的大部分病例都来自上海。 在这样一个特殊时期，人民需要情绪的宣泄， 而上海本身传出的负面新闻也让这所城市成为了此时的宣泄口。 我们需要的是给这所城市多一些信心。 外部势力与无所作为的官员毕竟还是少数， 在国家动态清零的大方向下， 相信最终我们能获得抗疫的胜利。 附录图 除了政府发放的物资，舍友经常能抢到许多东西，上图的这个好吃的面就是舍友抢到的。 蛋炒饭！万能的蛋炒饭！只要有鸡蛋和米，就能活下去。背后的莲花清瘟也是社区发的物资。 第一天刚拿到菜时炒的西兰花炒洋葱，说实话味道不咋地，西兰花是真的没啥味道。 因为没有蚝油，所以放的火锅酱，酱口味太重了…… 吃完才想起来拍照，洋葱炒土豆，味道不错哦~ 舍友抢到的烧卖和肉丝，终于开始吃肉的我们！ 上海好像没这种吃法？鸡蛋打好之后沸水一冲就成，就根黄瓜当早餐了，我们那边叫冲鸡蛋。 这个是4月10日时的物资，大部分都是政府发的！ 舍友抢到的挂面、火腿、牛奶 万能的舍友抢到的海底捞！跑一顿煮面吃两顿，真的好吃啊…… 在楼组长那边团购的米，除了这两袋还有一袋正在吃的。 政府发放的第三拨物资，量最大的一次，之前主要都是发的蔬菜。 团购和抢购的部分物资，鸡蛋、黄瓜等，都是4月10日时的储备状态。 餐食流水账(5.17之后就返工在公司生活了) 4.1：早：舍友新买的盒马烘焙；中：水饺；晚：米粥、青豆、土豆炒番茄 4.2：早：蛋糕；中：米饭，炒青菜，炒土豆丝; 晚：鸡蛋到了！笋瓜炒鸡蛋、西兰花炒洋葱、米饭； 4.3：早：面包；中：水饺(水饺告罄); 晚：炒洋葱胡罗卜丝、煮生菜、米饭 4.4：早：面包：中：番茄炒蛋、煮青菜、米饭；晚：蛋炒饭(中午多蒸了米)； 4.5：早：沙琪玛；中：洋葱炒胡罗卜、土豆炒胡罗卜、米饭；晚：煮生菜、土豆炒洋葱、米饭； 4.6：早：沙琪玛；中：洋葱炒鸡蛋、啃黄瓜、米饭；晚：洋葱炒肉！(舍友买到肉了)、煮青菜、煮生菜、米饭 4.7：早：米粥；中：水饺，舍友米粥吃撑了，午饭pass；晚：蛋炒饭 4.8：早：冲鸡蛋(鸡蛋茶); 中：煮面条(把一些剩菜边角料处理掉)；晚：米饭炒菜 4.9：早：周末懒觉没吃；中：海底捞！；晚：海底捞煮面条！ 4.10：早：苹果；中：煮水饺；晚：芹菜炒肉丝、青椒胡罗卜丝炒蛋、米饭 4.11：早：黄瓜；中：煮鸡蛋面+方便面；晚：青椒肉丝、洋葱胡罗卜丝、米饭 4.12：早：橘子；中：煮鸡蛋面+方便面(鸡蛋面再不吃要坏了)；焖胡萝卜白萝卜、洋葱炒蛋、米饭 4.13：早：黄瓜；中：煮鸡蛋面+方便面；晚：芹菜炒肉、番茄丝瓜炒鸡蛋、米饭 4.14：早：黄瓜；中：香菇肉水饺；晚：西红柿菠菜鸡蛋面 4.15: 早：None；中：挂面+方便面(菠菜、丝瓜、火腿); 晚：蒜蓉茼蒿、白灼小白菜 4.16: 早：黄瓜；中；水饺；晚：火锅(没错，舍友买到了火锅！) 4.17：早：面包(又一次收到了政府物资，有面包、盐、酱油等)；中：火锅，把剩余的牛肉卷吃掉了；晚：蒜苔炒鸡蛋、芹菜炒肉、米饭； 4.18：早：面包；中：水饺；晚：挂面，火锅底料和昨天没吃完了的菜一起配面条煮了~ 4.19：早：蛋糕(舍友又抢到了盒马烘焙); 中：水饺；晚：方便面+挂面； 4.20：早：蛋糕；中：方便面+挂面；晚：米饭、芹菜炒肉、洋葱炒鸡蛋； 4.21：早：饼干；中：方便面+挂面；晚：水饺(上班太忙了，根本没空做饭） 4.22：早：手撕面包；中：方便面+挂面+菜；晚：笋炒鸡蛋，油泼茄子，咸鸭蛋，米粥 4.23：早：面包；中：面条；晚：面条； 4.24：早：面包；中：面条；晚：莴苣炒肉，蒜苔炒鸡蛋，米饭； 4.25：早：面包；中：饺子；晚：面条； 4.26：早：面包；中：面条；晚：饺子+面条； 4.27：早：面包；中：面条；晚：蛋炒饭 4.28：早：蛋黄派；中：面(买的豆制品、番茄都到啦); 晚：番茄鸡蛋、青椒肉丝盖浇饭 4.29：早：蛋黄派；中：挂面；晚：醋溜土豆、麻婆豆腐、米饭 4.30：早：假期睡懒觉直接过去了:)；中：挂面，买了好多豆制品；晚：番茄鸡蛋，青椒素鸡丝，米饭； 5.1：早：睡觉；中：挂面，豆制品太多了，都快过期了。 5.2：早：睡觉；中：挂面；晚：米饭，豆干炒肉，青椒土豆丝 5.3：早：睡觉：中：面条；晚：米饭，青椒肉丝，醋溜土豆丝 5.4：早：睡觉：中：面条；晚：米饭，番茄鸡蛋，莴苣炒肉 5.5：早：睡觉；中：面条；晚：米饭，烧茄子 5.6：早：无；中：面条；晚：炒米 5.7：早：豆奶；中：面条；晚：土豆咖喱饭 (这次买了8斤菜全是土豆青椒) 5.8：早：睡觉；中：面条；晚：青椒土豆丝，蛋炒饭(全靠舍友的午餐肉) 5.9：早：无；中：面条；晚：鸡蛋羹、土豆咖喱饭 5.10：早：点心(舍友买了拉面球); 中：面条；晚：蛋炒饭 5.11: 早：麦片+豆奶；中：面条(黄瓜、香肠配菜)；晚：蒜苔炒鸡蛋、青椒土豆丝、米饭 5.12: 早：蛋糕(大礼包送了蛋糕); 中：面条；晚：蛋炒饭 5.13: 早：蛋糕；中：面条；晚：米饭，烧茄子，油炸金针菇(做的巨失败)； 5.14：早：睡觉；中：面条(鸡蛋告罄)；晚：卤面(突然想吃路面)； 5.15：早：睡觉；中：青椒肉丝炒饭；晚：麻婆豆腐、醋溜土豆丝、米饭 5.16：早：蛋糕；中：面条；晚：麻婆豆腐炒饭 5.17：早：面包；中：面条(青菜和鸡蛋买到了)；晚：卤面(韭菜炒鸡蛋、青菜) [1]: 跑毒、决赛圈的出处来自于一款名叫《绝地求生————大逃杀》的游戏，游戏中地图被毒气覆盖，安全区域不断缩小，最终100个人里面只有一个队伍or玩家能够获胜， 安全区域会缩小5次，最后一次的安全圈被称为“决赛圈”，而玩家从毒气区域跑向安全区域的过程被称为“跑毒”]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Install Both Android Emulator & WSL2 on Windows 11]]></title>
    <url>%2Fblog%2F2022%2F10%2F30%2Finstall-wsl2-on-win11%2F</url>
    <content type="text"><![CDATA[Install both android emulator and wsl(windows linux subsystem). If you directly install the android emulator like nox, mumu it will tell you that “please open Intel vT” or “system configuration is not compatible”. Let’s solve the problem and run both of them! Brief Introduction to Referred ConceptsWSL (Windows Subsystem for Linux)You could find the detailed info from wiki. For most target users the wsl is a fast linux virtual machine running windows. The wsl released version 2 on May 2019 with Hyper-V (microsoft para-virtualization, see previous posts Virtualization Introduction and What Color Is Your Guest(Chinese)) So it’s recommended to use it on latest version of windows 11. (The vim or qemu in wsl runs slowly when I was using win10. But the issue is fixed on Win11) Hyper-VThe official introduction of Hyper-V only talked the pros but won’t tell you that your Android Emulator or other VM software (like VMWare) will be breaked once the feature is enabled. I didn’t dig into the implementation only guess that the Hyper-V will intervene the virtualization interface so that original VM software couldn’t get correctly result when they want to use hardware supported virtualization directly. The Microsoft will recommend you to build VM using Hyper-V but we actually want to use our own virtualization managers. So how about just shut down the Hyper-V feature? Unfortunately, the latest version of WSL force you open the Virtual Machine Platform which depends on Hyper-V and will open partial related modules even though we didn’t open the Hyper-V feature. So if we want to use both WSL and Emulator we have to find correct alternatives. Run Linux SubsystemInstall WSL2It’s easy to install the WSL2 (official tutorial). Open your microsoft store Search the WSL Choose one distribution (Debian, Ubuntu, SUSE, etc) Run it Oops, the software tell you that you should open the feature first! Open Virtualization SupportSearch VT-x in your BIOS and enable it. The VT-x is microsoft virtualization support upon which the hypervisor kernel could be run and leverage the hardware support to create virtual machine(The CPU virtualization in Virtualization Introduction). You could also open SR-IOV (Single Root I/O Virtualization, IO virtualization hardware support) if your mainboard support it. Open FeaturesEasy way: Open “Start” (Press Windows key) and search “control panel) Open “Programs” Open “Turn Windows features on or off” in “Program and Features” Check the “Virtual Machine Platform” and “Windows Subsystem for Linux” or you could open it in cmd: “Win+R” to open running Open “CMD” as Administrator Open the feature in cmd: 123&gt; dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart&gt; dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart&gt; You have to reboot the system when you change the above features. Run WSL2Now we could open and run our WSL. Here to change the default fonts (The fonts will changed back everytime we reopen the wsl), we have to modify the regentry manually. 1231. Open regedit (Win+R and run regedit)2. Computer\HKEY_CURRENT_USER\Console\your_linux_subsystem_distribution3. Add CodePage (Type: DWORD, Value: 0x01b5). This is Lucida Consola Run Android EmulatorWe have no choice but to choose the “correct one”. The BludStack has Hyper-V supported version so we could use it for our gameplay. Offical Download Page Before install it, please open other Hyper-V features: (All of them could be opened in “control panel” Hyper-V Windows Hypervisor Platform Windows Sandbox Reboot the system and install the bluestacks. It will prompt and let you grant the Hyper-V feature to it. After the installation you could now use BludStack Emulator on Hyper-V enabled windows. The WSL could also be run of course. Most android emulators are built upon the bludstack since it is open source. So we should be optimistic that other emulators will support Hyper-V in the future. And this will let your emulators run much faster. Enjoy your gameplay and works now!]]></content>
      <tags>
        <tag>linux</tag>
        <tag>virtualization</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020 ACG 追番总结]]></title>
    <url>%2Fblog%2F2021%2F04%2F05%2F2020-acg-summary%2F</url>
    <content type="text"><![CDATA[本来还尝试改用豆瓣来记录自己的看番历程，不过发生了差评事件加之一些非表世界番豆瓣没有记录，最终作罢。 毕竟自己来控制格式的话自由的多~ 之前的动画图片都是从百度百科上取的，但是人家动不动就更新链接， 还有一些是CDN缓存的所以经常过一段时间就变白框。 现在都用了更高级的技术，根本取不到jpg的链接，我自己也有点懒， 所以这次换成维基的链接了，要是也不能用了那以后估计就没有图了吧。 瘫= = 来回顾一下过去2020年又有哪些动画给我们留下了深刻的回忆吧！ Jan.5.0 异种族风俗娘评鉴指南/異種族レビュアーズ-Passione 看标题就知道这部作品多么不得了！然而这部作品竟然是正儿八经的全年龄你敢信！ 这部作品可以说是快速了解各类异世界风格xp的指南了， 原作者一定深谙异世界设定， 主要讲述主角团(精灵、人类、中性天使、小尺寸种族)和偶尔一些其他参评者(兽人、恶魔、蛇人、妖精、吸血鬼)和各种异世界种族的风俗娘XXOO后的评价… 这部番让我惊叹于作者的脑洞，同时也很好的学习了异世界各类种族的设定。 说实话许多异世界设定的动画甚至都不一定有本作对各种异世界种族的设定了解的深… 满分没啥好说的。 4.9 ID: Invalid/异度侵入-NAZ 除了最后一部分，前面基本上是神作！满分100能给120都不怕骄傲的那种！也是在这部番当中我完全迷上了男主声优津叔，对高智商罪犯的塑造、男主的推理都是满分，本作尤其出色在其节奏安排上，一环扣一环每一集都能在给出大量信息的同时为下一集埋下伏笔，全程无尿点。更关键的是，几乎每一集都有反转，要理解这对于一部连续剧类的动画是极为难得的。 这部作品需要静下心来认真观看，无论你是否喜爱推理，本番都极为推荐！ 4.8 虚构推理/虚構推理-Brain’s Base 一种比较另类的推理小说，作品的设定是男主与女主能够看到灵异事务， 在一个个由妖怪们或超自然现象导致的事件中男女主要“虚构”出合情合理的推理， 让普通人认为它是一个合情合理的事件。 从另一个角度，将超自然与灵异部分排除，本作就是传统的社会推理小说， 给定现场与线索，让观众跟随女主的推理过程去还原整个事件。 而作者在一上来就告诉观众这件事实际上是妖怪引起的， 这与传统作品中面对事件时云里雾里相比， 这一强加给观众的设定会让观众更难按照以往的思维方式去“正常”推理整个事件， 从而在跟随女主“虚构”出整个合情合理的事件后更大可能啧啧称奇，也是作者的一个巧妙地叙事手法。 同时由于本作加入了灵异等超自然现象，在许多事件中除却推理部分， 故事本身的浪漫主义温情也很好的与冷冰冰的推理进行了互补， 加上女主可爱、聪慧、老司机的性格，使得本作的质量非常高。 硬要说有什么不足，那就是部分篇章节奏可能有点慢，但是动画将节奏处理的还是非常好的，非常推荐！ 4.6 别对影像研出手！/映像研には手を出すな！-Science SARU 动画讲述的三个高中生以映像研的名义做动画的故事，本作最大的亮点在于将创作者的思路构画了出来， 当主角手舞足蹈得描述场景设定时，动画会将那想象的世界直接构建出来。 像我们小时候模拟机枪、导弹的声音一般，动画中对想象出来的音效进行模拟的也是角色本身。 这部作品能摒除生活与工作中的繁缛琐事，将创作这一本身的乐趣原原本本呈现在我们眼前， 是不可多得的佳作！ 4.3 ペット/思维覆写/pet-GENO STUDIO 该季度与ID:Invalid相杀的悬疑类作品，虽然没有异度侵入每话有高能那么神， 本身作品的讲述的剧情与故事还是很棒的。主角是一群能够通过潜入对方潜意识操作对方记忆的人们， 他们被称为pet，因为这些有能力的人是黑社会权位者的宠物也是武器， 每一位主角都有着各自的故事，而他们之间的爱恨纠葛也是本作的主要叙事与看点。 4.3 痛いのは嫌なので防御力に極振りしたいと思います。/因为太怕痛就全点防御力了。-SILVER LINK. 当季度的凤傲天动画，虽然剧情比较老套，但是女主卖萌卖的并不做作，加之动画制作也不是很缺资金， 因此还是推荐看一下的，毕竟在各类龙/凤傲天动画的历史中，“盾傲天”绝对是可以留名的一部作品。 4.2 理科生坠入情网，故尝试证明/理系が恋に落ちたので証明してみた。/Science Fell in Love, So I Tried to Prove It-ZERO-G 一部校园爱情的发糖番，男女主由于都是理科生，所以用各种奇怪的方式来进行实验验证与分析恋爱这一感情， 由此发生了诸多搞笑的校园日常生活。不过本质上就是个发糖番，喜欢的不妨一看。 4.1 达尔文游戏/ダーウィンズゲーム/Darwin’s Game-Nexus 达尔文游戏是我从漫画一路追来的动画，漫画画风和剧情都属上乘，动画的表现上略有瑕疵，不过总体观感还不错。 剧情描述的是能力者之间的战斗，作为主角的“要”凭借着聪明的头脑巧胜“不败女王”从而收入后宫~ 随着剧情深入逐渐揭开给予玩家超能力的游戏软件：达尔文游戏。 战斗方面刻画的不错，美中不足的是男主的能力又是比较BT的外挂般复制能力，有一种既视感的遗憾。 但是在生存游戏类的作品中，属于排上的名次的了，可以一看。 4.0 地縛少年花子くん/地缚少年花子君/Toilet-Bound Hanako-kun-Lerche 糖，都是糖。 作为幽灵的男主和高一女主的甜蜜爱情校园故事= =， 要是被前面的推理番刀的难受了，可以看这部作品治愈一下~ 3.5 + 0.5 ランウェイで笑って/请在伸展台上微笑/请在T台上微笑-Ezo’la 本作讲述的是作为设计师的男主都村育人与小个子(158cm)模特藤户千雪互相支持并成长的励志番。 虽然男主是出身并不富裕的普通男性，女主又有着小个子这一对模特来说致命的缺陷， 但是本作的男主有着极高的设计师天赋， 女主又是一个比较有名的模特公司总裁的女儿使得作品还是超脱了普罗大众的范畴， 这一点会让观众难以带入是个扣分项。 作品有意思的地方在于对时尚界有许多的描写，从这部作品里我选到了一个T台展的设计有着其叙事， 展出的服装有着展示用与售卖用两类，对模特后台的描绘与设计师服装设计的细节展开非常专业， 女主(&amp;女二)与男主的感情线也是其一大看点，因此本作本该获得不错的分数。 可是令人遗憾的是，时尚界类的题材可能不是那么符合大众尤其是青少年的口味吧， 本作的原作漫画在中途女主还未能挑战当时的Top模特，即将遇到贵人要开始完成成长与蜕变时快速完结， 而动画公司也显然不看好本作品，投入的资源非常有限使得作品的质量非常差， 原作T台秀的美奂场景动画中的表现非常拉跨，也使得作品只能获得我3.5分的评价。 那额外的0.5分时是追完漫画的我为原作者打抱不平而强加的！ 3.5 邪神ちゃんドロップキック/邪神与厨二病少女-Nomad 小邪神与中二少女的日常故事，每天就是看小邪神如何作死与被中二少女暴打的搞笑日常番， 里面出场的奇怪角色也各有特点，不过与龙女仆相比，本作由于是纯搞笑，少了些温情。 女主也不是萌系的，使得其竞争力稍逊。 3.3 Magia Record 魔法少女小圆外传/魔法纪录 魔法少女小圆外传/マギアレコード 魔法少女まどか☆マギカ外伝-SHAFT 本作是手游改编，与初见小圆相比还是少了很多新鲜与惊异感的，而且编剧不再是虚渊玄执笔， 叙事能看出来达不到原作的功力，但是又想往原作的B格上靠，造成本片的叙事节奏不清晰。 本传晓美焰为了拯救圆神的举动令人动容，与之相比，外传的本作则更像是看初中女生们闹矛盾的程度。 Apr.5.0 隐瞒之事/かくしごと-亚细亚堂 本作比较特别，讲述的是一个女儿对父亲的回忆。 父亲一个人带着小学4年级的女儿，本职是一位漫画师，由于连载的漫画有点下流， 为了不让还是小学生女二发现而在生活中对女儿的各种突袭进行隐瞒， 而与此同时女儿控的父亲也时时刻刻爱护着自己的女儿， 让女儿能够有一个快乐与开心的童年。 在轻松治愈的日常生活中体现了父亲对女儿的关爱，想要隐瞒自己工作的笨拙， 其实随着女儿的长大，父亲又如何隐瞒的住呢？ 当女儿最后在病床上面对父亲时，动画之前酝酿的情感顷刻爆发，催人泪下。 4.6 富豪刑警 Balance:UNLIMITED/富豪刑事 Balance:UNLIMITED-CloverWorks 本作有同名电视剧，但是因为政治正确和收视率的原因改成了男女主。 动画更加还原小说，是两位男主的故事。 看热血男一与富豪男二的办案故事， 男二告诉你如何使用钞能力来处理事件，看的那叫一个过瘾哈哈哈。 4.5 昨日之歌/イエスタデイをうたって-动画工房 真正的普通人纠结的爱情故事。本作非常好的展现了男主与女一和女二之间的九个的感情， 将一个普通人的纠葛恋爱描绘的淋漓尽致。 男主大学毕业，便利店打工，单向喜欢同学女一; 女一现在是高中老师，放不下曾经的感情(自己的青梅竹马 早逝)，而一直拒绝男主的感情; 女二是咖啡店打工仔，性格率直因为曾经的精力对男主有好感; 作品及其贴近现实，连男主许多地方的优柔寡断都让观众是不是能看到自己的影子， 作品描绘了三人各自对面对感情时而逃避、时而烦恼、时而迷茫的纠结， 这样平淡的故事却更加贴近你我的生活。 4.2 신의 탑/神之塔/Tower of God-Telecom Animation Film 哎，没想到吧，这个竟然是一部韩漫改编！原作的神之塔韩漫是我唯一付费追更的韩漫， 曾经和《大贵族》、《高校之神》等作品一起，是韩国的国民级民工漫。 随着《大贵族》和《高校之神》的完结，《神之塔》也算是目前还在连载中的元老漫画了。 神之塔在前期比较像全职猎人，在爬塔过程中主角团要挑战完成一个个游戏/比赛， 因此里面在打斗之外存在大量的智斗，这是本作的第一个看点。 本作的第二个看点是小可爱男主 第二十五夜、高智商高颜值忠犬型男二 昆·阿奎罗·阿尼亚斯 以及笨蛋热血男三鳄鱼队长雷克·萊科雷斯三人之间的钢铁友情 第三个看点则在女主蕾哈尔与男主之间的故事。 动画中规中矩，4.2分里面带有我很多的漫画感情分私货， 带了私货也只能给出4.2分的评价是因为本作最好看的部分在漫画第二部， 第一部讲述的是漫画开始的部分，很多篇幅都在帮助观众熟悉任务与规则和设定， (毕竟不像日漫那种异世界，开局2min直接就能熟悉各种设定， 甚至都不用说明)。因此动画只能说中规中矩。同时本作也是标准的热血民工漫。 喜欢看游戏类、大逃杀类的如《弥留之国的爱丽丝》、《噬慌者》、 《诚如甚至所说》等类型的可以看看本作。 （琉璃姐姐和莲花姐姐踩我！） 3.5 转生成为了只有乙女游戏破灭Flag的邪恶大小姐…/乙女ゲームの破滅フラグしかない悪役令嬢に転生してしまった…/转生恶役只好拔除破灭旗标-SILVER LINK. 女主穿越到了女性向Galgame中的女反派，然后利用自己通关游戏的经验避免自己的死亡Flag， 一路改善与各路男主的关系，最后攻略了本该喜欢上游戏女主(女二)的各类男性， 甚至连女二都一连攻略了！ 欢乐轻松搞笑的校园故事，微逆后宫。 3.2 格莱普尼尔/グレイプニル/GLEIPNIR/被束缚的芬尼尔-PINE JAM 超能力热血动画，本身讲述的是一个外星人找地球人帮他收集硬币的故事， 拿到硬币的人类可以获得和自己相匹配的超能力， 收集到100枚硬币则可以实现一个愿望， 也因此展开了超能者之间的厮杀。 男主的能力是个带左轮的布偶，由于是布偶因此里面可以钻人， 女主在自杀时被男主所救，从而跟着男主寻找自己的姐姐， 无能力的女主则回每次身着泳衣(漫画开始可是裸的， 动画是内衣)进入(物理意义上)男主体内(动画名镜头)和男主并肩作战！ 动画本身的战斗还算不错，不过没什么智斗，漫画后面的剧情有点还在展开中， 只能说前面的铺垫与目前的剧情比重分配的不太好，不过动画对这一部分有所弥补。 至少前两集中的名镜头还是需要了解一下的。 Jul.4.6 GREAT PRETENDER/大欺诈师-WIT STUDIO 男主被诓骗进了以罗兰为首的诈骗团伙，讲述的是诈骗团伙的诈骗故事。 由于诈骗行为这一敏感性，因此为了让作品能存活(笑)主角团诈骗的都是恶人， 劫畗不过也没有济贫就是了hh 作品叙事节奏几乎完美，诈骗手法虽然有点老套但是描绘的细致到位不出戏， 而且本作对诈骗的描写只是支线，主线讲述的反而是主角团们各自的故事。 连线洛杉矶篇章讲述男主枝村真人的故事，男主如何被忽悠进团； 新加坡之空篇章讲述主角团妹子阿比的故事，阿比如何与自己和解； 伦敦之雪篇章讲述主角团色诱担当辛西娅的故事，辛西娅如何放下曾经的感情； 远东魔法师篇章则是罗兰与男主的故事，为整部作品画下了不错的句号。 作品有瑕疵的地方在于男主最后强行挣脱他人指定的框框， 最后有意让男主用自己的智慧来完结事件，但是有些画蛇添足的味道， 尤其是其使用的手段明显不合常理反而给作品打了个大大的折扣。 但是瑕不掩瑜，作品仍然十分十分 (我打了9分来着 hh) 值得一看。 4.2 没落要塞/DECA-DENCE/デカダンス-NUT 作品讲述的是末日中男主与女主为代表的人类对抗未知生命体的末日生存故事！不过这个只是设定， 由于第二话惊人的反转，所以我这里不能完全剧透太多，感兴趣的小伙伴不妨快去看看！ 这部作品的看点一是人类为生存而做出的反抗，另一个看点则是男主为了正义所做成的决断。 设定新颖，这也是这部原创番令人惊喜的一点。作品中名场面：超级聚能正义之拳！拳头才是男人的浪漫！ 3.7 モンスター娘のお医者さん/魔物娘的医生/Monster Girl Doctor-ARVO ANIMATION 男主是异世界专门给魔物们看病的医生，是著名医生章鱼熟女老师的得意门生， 作品是正常的异世界微后宫番，不同的是男主是给各类魔物看病的医生， 也因此有许多意想不到的细心设定， 在异世界系列里面是值得一看的作品。 3.6 宇崎学妹想要玩！/宇崎ちゃんは遊びたい！-ENGI 女主是身形娇小的学姐，和男主在一个咖啡店打工，我就像那个咖啡店老板一样天天磕糖。 甜甜的轻松搞笑日常校园恋爱番，不过欢乐的多，因此给分高一些。 3.2 租借女友/彼女、お借りします-TMS Entertainment 其实有点标题党啦，就是正常的校园恋爱番，还有点后宫向的。男主只不过是开始叫了个租女友服务， 回头客的时候各种强行不给人家面子导致妹子展现真性格。医院偶遇因为种种原因谎称情侣， 后面假戏真做的校园爱情故事。 动画比漫画好的一点是对节奏的修改更加合理，因此动画的观看比漫画要好不少。 3.0 魔王学院的不适任者～史上最强的魔王始祖，转生就读子孙们的学校～/魔王学院の不適合者～史上最強の魔王の始祖、転生して子孫たちの学校へ通う～-SILVER LINK. 龙傲天他来了，他转生、他异世界、他带着后宫他来了。龙傲天嘛，就是看个爽，这部番满足及格线吧。 Oct.4.3 魔女之旅/魔女の旅々-C2C 讲述的一位天才魔女旅行，路途发生的各类故事。本番的女主并不圣母， 因为在旅途中遇到了好心办坏事的情况，所以在某些场景下会有着作为旁观者的不近人情一面， 而这却恰恰是我觉得最为真实的部分，也是我对本作评价较高的原因。 同时作品讲述的故事蕴含的道理令人深思，在旅途中有开心快乐也同样有苦涩难过， 并非凤傲天，喜欢看冒险故事或物语系列的推荐一看~ 4.1 攀岩少女/いわかける！ -Sport Climbing Girls–BLADE 虽然是冷门的运动，但是加上美少女就有看头了~ 本部动画对竞技攀岩和野外攀岩均有简单的介绍， 同时也是标准的美少女运动励志动画~ 对女主们的动作刻画也挺不错, 对象要看女高中生类或运动类或对单纯想要攀岩的可以一看~ 4.0 大贵族/노블레스/NOBLESSE -ノブレス–Production I.G 本年度几个著名的韩漫都得到了动画化，大贵族作为著名的民工韩漫，也在今年得到了动画化。 讲述的剧情是标准的吸血鬼贵族的剧情，一方面看一个温柔的大帅B稍微有点脱线的快乐校园生活， 另一半就是男主作为吸血鬼之王处理族内事物的龙傲天剧情~ 剧中角色都是帅哥，微乙女向，整体制作还算可以。 4.0 在魔王城说晚安/魔王城でおやすみ-动画工房 女主被拐到了魔王城，不过众所周知，魔王城力都是男妈妈！一部治愈轻松快乐的日常番， 看女主如何被当女儿养的欢乐故事，还是很温馨的~ 3.9 无能力者娜娜/无能的奈奈/無能なナナ-Bridge 虽然背景是超能力者云集的小岛，无能力者女主(娜娜)在高智商男主(能力者)的眼皮底下执行暗杀任务的故事， 不过实际上更像是推理番，主要看女主如果向男主隐瞒自己的动作，以及看男主分析各类事件。 设定还是不错的，尤其是在超能力都已经用上的情况下还在设定里保持了合乎逻辑的推理这一点难能可贵。 3.4 总之就是非常可爱/トニカクカワイイ-Seven Arcs 开局就告诉你，这是狗粮番，标题就告诉你，这是狗粮番，那还能咋办？汪汪汪。 男主觉得女主实在是太可爱了，即使遭遇车祸也依旧向女主表达爱意，之后失去意识和部分记忆。 在18岁的这年，女主上门兑现承诺，开局叫老公，发糖一整季！ 续作类 5.0 攻壳机动队：SAC_2045/攻殻機動隊 SAC_2045-Production I.G/SOLA DIGITAL ARTS 攻壳机动队经典老番了，本作是3D版，素子姐姐好看多了！剧情依旧顶，强烈推荐。情怀加分给满分。 4.6 辉夜大小姐想让我告白～天才们的恋爱头脑战～ 2/かぐや様は告らせたい～天才たちの恋愛頭脳戦～ 2-A-1 Pictures 高水准的续作，不容错过的轻松搞笑校园恋爱番，男女主互相想让对方告白的故事，值得一看。 4.6 やはり俺の青春ラブコメはまちがっている。完/我的青春恋爱物语果然有问题。完-feel. 大老师！完结篇多多少少还是给点高分吧。 4.5 RWBY 7 RWBY一如既往的质量与水准，欧美少数的日系动画，主角们有着欧美的价值观与性格，没看的快去看！ 4.5 PSYCHO-PASS 心理测量者 3 FIRST INSPECTOR/PSYCHO-PASS サイコパス 3 FIRST INSPECTOR-Production I.G 另一半的心理测量者，好看继续追~ 依旧是男主能力有点过分，好好的悬疑变超能力了啊喂！但是说实话，收尾其实收的比我想象的要好… 4.3 某科学的超电磁炮T/とある科学の超電磁砲T-J.C.STAFF 一如既往的高水准，喜欢炮姐的当然不会错过~ （本人是操祈女王派的，这一作女王出场不少，不过女王跟男主注定是悲剧让人意难平啊) 4.2 Ｒｅ：ゼロから始める異世界生活/Re:从零开始的异世界生活/Re:Life in a different world from zero-White Fox 新编辑版&amp;第二季，喜欢的姥爷们可以重温一下~ 这部作品的质量还是不错的， 只不过我个人比喜欢艾米莉亚这种人设，同样也不喜欢男主这类纯靠毅力与耐心突破阻碍的类型， 相性太差hh 4.2 在地下城寻求邂逅是否搞错了什么/ダンジョンに出会いを求めるのは間違っているだろうか #3-J.C.STAFF 延续前作的轻松风格，制作在线！ 3.5 LoveLive!虹咲学园学园偶像同好会/ラブライブ！虹ヶ咲学園スクールアイドル同好会-SUNRISE 还是和以前一样的偶像番，类似的9个人，喜欢听歌的可以看~ 3.5 食戟のソーマ 豪ノ皿/食戟之灵：豪之皿-J.C.STAFF 食戟之灵按部就班按漫画走的，但是漫画后面出了黑暗料理界之后就越来越离谱了= = 3.0爱书的下克上：为了成为图书管理员不择手段！ 2/本好きの下剋上~司书になるためには手段を选んでいられません~ 2-亚细亚堂 标准开挂女主的续作的正常延续, 喜欢看成长类凤傲天的来看这部。 Others 2.8 我立于百万生命之上/100万の命の上に俺は立っている/I’M STANDING ON A MILLION LIVES-MAHO FILM 和同学一起转生异世界，但是完成任务后还会回到现实世界的设定，任务中只要不团灭就能复活， 所以男主在一次次任务中虽然存在对队友/同学的牺牲，不过靠着自己的存活最后也拯救了同学。 不过个人不喜欢这部番的剧情，因为女主们的设定不太行，智商下限，圣母婊…… 所以仁者见仁吧。 2.7 被众神捡到的男孩/神達に拾われた男-MAHO FILM 依旧是龙傲天，男主转生收到各种神的祝福，养了一堆史莱姆。 由于设定上史莱姆吃各种东西可以变成不同属性从而能够干各种活， 但是整体有些无趣，龙傲天看起来却并不爽。 2.6 갓 오브 하이스쿨/The God of High School/高校之神-MAPPA 韩国民工漫热血打斗番，不过这部番没什么大叙事，这也是韩漫的大部分问题， 作者驾驭不了大主线和大叙事，每次都只能安排一个小场地来给男主开挂，个人不是很喜欢。 2.5 你与我最后的战场，亦或是世界起始的圣战/キミと僕の最後の戦場、あるいは世界が始/Our Last Crusade or the Rise of a New World-SILVER LINK. 狗粮番，不过有点强行；军国最强战力龙傲天男主和魔法国最强法师凤傲天女主的撒糖故事， 制作还可以，但剧情有些过于模板化了。 2.5 PLUNDERER/プランダラ/星掠者-GEEKTOYS 经典的热血动画，我是从漫画开始追的，然而热血动漫的动画制作公司资金经常都不是那么充沛.. 最终导致本作的动画属实有点垃, 剧情甚至已经到了侮辱智商的程度了，但是漫画还是推荐一看的！ 2.5 八男？別鬧了！/八男って、それはないでしょう！/八男？别闹了！-SHIN-EI动画/SynergySP 排行第8的男主，已经继承不了家里什么了，但是人家是龙傲天啊！ 2.2 彼得·格里尔的贤者时间/ピーター・グリルと賢者の時間-WolfsBane 各种白给，强行设定要男主染色体的那种白给，基本上算18X了。 2.2 弩级战队H×EROS/ド級編隊エグゼロス-project No.9 打擦边球的动画，女主们的H力能转换成男主的战斗能力对付虫虫外星人…奇葩设定的卖肉番。 2.0 進撃の巨人/进击的巨人 最终季-WIT STUDI 这番也终于完结了，后面实际上是漫画剧情拉跨了， 尤其是作者反战败而不反战的价值观让男主最后毁灭大部分人类的做法让我呸。 2.0 猎魔武士/GIBIATE-ランチ·BOX 武士穿越到现代，然而实在是不太行，看了两集愣是没看下去。 1.0 公主连结！Re:Dive/プリンセスコネクト！Re:Dive/超异域公主连结☆Re:Dive-CygamesPictures 只能说动画完美还原了游戏白开水的剧情，真的是一丁点的脑子都不能带… 纯看妹子们跟着哑巴男主的白开水日常, 我是接受不能的。 0 咒术回战/呪術廻戦/Jujutsu Kaisen-MAPPA 本来不错的漫画，可惜了，作者反华，私货太多，原谅霸凌，唉。 End本年度值得一看的动画还是挺多的，尤其是自己长追的一些韩漫在获得美国的投资下， 在日厂进行了动画化令我惊喜，就是最终的产出有些意难平， 但对比中日合作的那些动画，只能说质量还说的过去。 工作虽然越来越忙，但是动漫可不能落下，明年继续~]]></content>
      <tags>
        <tag>ACG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020 Summary]]></title>
    <url>%2Fblog%2F2020%2F12%2F20%2F2020-summary%2F</url>
    <content type="text"><![CDATA[2020 是历史魔幻的一年，乘着历史的过山车，演好自己的剧本，端好手中的饭碗，抚平心中的涟漪，笑对生活~ 流水账 Jan. Bad Begin 个人的生活迎来了波折，人生好聚好散。外面的一切也渐渐都都紧张了起来，武汉的消息传到了上海，我也拿出自己为数不多的普通口罩， 在网上购买的口罩也为时已晚，武汉封城的消息传出后他省的货物便难以进入上海了。 每天除了一遍遍给父母强调戴口罩，就是谨小慎微地注意出行，经过武汉的同事也都取消了回家的班列，我也准备离开上海，回河南老家过年。 这次疫情河南的应对获得了全网的夸赞，作为人口大省，非常理解省长的应对措施，也为自己家乡的优秀表现点一个大大的赞。 Feb. Tough Life 各省均处于一级响应状态，形势严峻，好在作为ICT行业的从业人员似乎并没有被疫情打乱太多，除了担心自己返回进不了小区以外似乎并没有特别担心的事情。 经过7天+延长3天的假期后便立刻返回了上海开始居家隔离，这也是第一次Work From Home。 每天睡醒线上会议，中午下午外卖解决，缩在家里尽可能地减少口罩的使用， 算是体验了一把特殊时期的工作模式吧，在家里除了上班每天也都会关注新闻、思考生活， 难以想象假如发生了大型灾害或战乱时，当稳定的生活被打破时我是不是还能够镇定的应对这些，至少现在的我还无法自信的认为自己能够在乱世中生存， 能够在不稳定中伴着高风险去实现自己的目标，也再次意识到自己不过是个普通人罢了。 缩在家里一个月又会有什么新奇的事呢，苦笑。 Mar. Keep living 本来2月到期的房子，由于疫情就又续了一个季度，每天通勤使用公司发的普通口罩，安慰自己带总比不带强… 每天的三餐都是盒饭，在这特殊的事情谁也不会再抱怨什么，毕竟还有那么几种盒饭可以选不是么(笑).. 两点一线的生活就着么持续着，不过看着确诊的数字在一点点下降，大家都充满了信心觉得快乐的生活就快到来， 不再是起初的恐慌与中间的茫然，和朋友已经可以聊起去哪里玩，关注的重点也渐渐变成了国外， 开始担心国外的同学与家人…… 每天会有几个同事去餐厅给大家领盒饭，每个人都带着口罩，食堂也拉起了宣传标语 Apr. To Be Good 已经可以去其他的小区了！看起来疫情就快过去了呢！ 虽然在公司依旧吃着盒饭，不过口罩也能够在药店不限量买到了，产能也陆陆续续恢复了， 我们的公司也在依旧平稳进行着~ 今年的娱乐活动也就只剩下看看动漫玩玩游戏了，4月开始入坑了公主连结的B服公测， 依旧两点一线的生活，不过大家已经在等待娱乐设施开门了~ May. Rush Work 5月又到了攻关期，加上今年的特殊情形，因为不推荐出上海，所以在家休息了几天后就到公司值班干活了… 因为几乎每个周末都在加班，也没来得及找房子，又续了一个季度… 加班也逃避不了长膘… Jun. Eat! and Debug! 6月依旧处于攻关期，上班解决问题，周末还要加班，不过外面的餐厅已经可以聚餐了， 生活的快乐回来了！大家都可以一起吃火锅了呢！ 吃火锅，咔咔 饭店的提示语也是非常的有意思~ Jul. Business to ShenZhen 7月份整体还是很快乐的，获得了公司比较大的一个荣誉，灰常的开心！还要去分享、领奖、发表感言、拍视频balabala… 之后又遇到了一个疑难问题需要攻关，和上海的H大 &amp; L桑，杭州的大佬们一起出差深圳进行攻关。 攻关虽然每天都挺枯燥啦，天天起来干到晚上11点，但是见到了表姐一家，又和ACG深圳众搓了一顿加深了基友情， 可以说让工作充实了生活~ 和深圳众一起吃的烤鱼、公司经营的员工宿舍、以及由于疫情原因改变的飞机餐 获得的奖品~ 美丽的深圳 Aug. ChinaJoy &amp; ACG Shanghai! 8月因为ChinaJoy的原因，公司的ACG杭州和上海众在上海J桑家集合！ 第一次看到了现实中的龙猫，只能说J桑真的厉害…也在现实中见到了up主… 感觉似乎一瞥另一个圈子的大佬们… 真正的龙猫，J桑是有6个这样的龙猫屋子的… 在家里大家一起吃烤肉、喝快乐水、打switch、侃ACG，悠哉美哉！ (8月光在玩了，懒得找房，所以…又续了一个季度) Sep. Normal Life 9月就是正常的生活工作啦，没有什么有意思的事情，意外收到了公司教师节发给当导师的教师节礼物，我也有幸收到了一份~ Oct. Groomsman 十一好兄弟L桑结婚，我则是作为伴郎过去~ 顺道去深圳与Y桑玩了一天，又到广州见了表姐一家~ 最后则是落脚L桑的家乡，为L桑送去最好的祝福，并帮他抢亲，哈哈哈。 这次去广州感受了不一样的婚礼风俗，只感觉红包满天飞、各种地方都要敬茶，甚是神奇~ 月底则终于开始了搬家，搬到了离公司比较近的地方和同事C桑一起~ 果然合租住大House比单人的小屋舒服多了… Nov. Animal, Botany &amp; Art 大家约定的春游因为疫情变成了秋游，秋游则由于工作的攻关一拖再拖拖到了11月…都快变成了东游了~ 去了辰山植物园，不过似乎大家对动物更感兴趣，哈哈 有只小羊从栏杆里钻出来了，超级可爱！羊驼殿也非常的帅~ 最后还是附一张真正的主角，植物好了~ 回来与G大去艺术感感受了一波人文情怀，不过果然该看不懂的还是看不懂呢，摊手 作品名：马赛克 作品名：会动的房间 Dec. Ordinary Life 12月没有什么惊喜的事情，工作的事情塞满了自己的生活，倏忽间便过去了~ Note22年某月回看，才发现当时20年的总结忘了写，留在这里的是19年的总结，有点尴尬。 现在已经无法回想起20年的感受了，唯有疫情导致封城的现在再一次提醒了我20年的不好过， 而现在看着自己所在日增2w的上海，恍惚间甚至觉得日子越过越回去了…… 所以20年就没有总结了吧~ 健身 50× 25√ 读10本专业以外的书 画4副插画 写5篇技术博客(博客是一个自己总结的好机会) 开开心心 2021年加油！ 健身30 读10本专业以外的书 画画！！！！！！ 快快乐乐]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 ACG 追番总结]]></title>
    <url>%2Fblog%2F2020%2F06%2F15%2F2019-acg-summary%2F</url>
    <content type="text"><![CDATA[2019的追番总结一直拖延到现在其中有诸多原因，过年期间由于感情问题导致春节在家专注于新鲜事物转移注意力， 而十分不幸的是遇到了百年难遇的新冠疫情，本想出去散心的我只能待在家里。 当时也仅仅专注于技术希望能让自己的注意力能够集中， 也因此把追番的总结一直拖到现在。 之所以一直坚持这个系列，无非是想让自己在看过的这么多套路满满的动画中能够汲取一些收获， 使得自己的时间不是无意义的流逝。 废话到此为止，来回顾一下2019的牛鬼蛇神！ Jan.5.0 约定的梦幻岛/約束のネバーランド/The Promised Neverland-CloverWorks 这部番作为当季度霸权无可争议， 这是少有的我看了后深感自己叙事能力低下的作品， 属于可望而不可及的水准。 在不看漫画的情况下，整部番的舞台就是一个福利院， 天真无邪的孩童们在亲切的妈妈的照顾下每天度过快乐的时光。 只是隐隐发现一些不和谐的地方， 每个儿童都有编号、时不时就会离开的伙伴、不能去的大门…… 12集仅仅讲述一个福利院的孩童们与妈妈进行捉迷藏、斗智斗勇的故事。 这部番强烈推荐，虽然后面的漫画剧情相比其他作品也没有特别出彩， 只是中上水平。然而动画的叙事使该作的观看体验大幅提升。 4.9 辉夜大小姐想让我告白～天才们的恋爱头脑战～/かぐや様は告らせたい～天才たちの恋愛頭脳戦～-A-1 Pictures 轻松快乐的校园生活剧， 剧情好笑并且全程无尿点， 动画将漫画的喜剧特点进一步进行夸张和突出， 使角色塑造的更加鲜明，对比也更加强烈。 剧情围绕相互喜欢但是都想要让对方先告白的学生会会长副会长， 以及与天然黑粉毛、无言游戏宅的搞笑学生会生活。 也算斗智斗勇了… 4.2 爱，死亡和机器人/Love, Death &amp; Robots-Netfix 这是Netfix爸爸请各路神仙导演出的短视频合集， 也因此质量参差不齐， 个人比较喜欢的是这几部《桑尼的优势》、《证人》、《祝有好收获》、《变形者》、《帮手》， 美国的动画就是充满黄毒暴← ←… 不愧是各路大导演的脑洞，每个都是可以扩展成长篇电影的剧情， 可以算是看了18个精彩小故事吧~ 3.8 烟草/ケムリクサ-YAOYOROZU 这部番有些画风劝退，加之剧情慢热使得作品比较冷门， 在一个神奇的充满危险红雾的世界里男主遇到了会使用叶子(烟草)的妹子们， 这部番在每一集都在一点点对这个世界进行叙述、 通过一个个细节展露一个个疑点， 作为一部带有悬疑成分的原创动画， 每一集和弹幕都在猜测接下来的发展而不亦乐乎。 到了11集一口气揭示世界真相与妹子们的身世， 让观众在哀叹这不幸的故事时，也感到一丝丝的欣慰。 这部分虽然冷门，画风比较奇特，但是属实不错，也是季度销量霸权足见其成功。 3.5 不吉波普不笑/ブギーポップは笑わない-Madhouse 一年之后，能够记起来关于这部番的只有OP的音乐了(笑)。 在当时作为一部冷门番，其质量还是说的过去的， 讲述不可思议的传说少女不吉波普解决事件的物语， 有一点死后文的味道，每个故事都是个小篇章， 适合杀时间时看看~ 3.0 五等分的新娘/五等分の花嫁-手冢Production 后宫向的动画真是从封面就能看出来， 男主辅导5胞胎，然后…嗯你就知道后面就是6角恋的故事了。 这部番的问题在于和《伪恋》类似，有些强行拖剧情的嫌疑， 所以给个平均分3分ok了。还算能看。 Apr.4.7 鬼灭之刃/鬼滅の刃-ufotable 这部番原本属于慢热型，奈何ufotable强无敌的作画让整部动画节奏非常的好， 热血类的动画、精彩的动作戏+优美的作画向来不缺乏市场， 何况妹妹还那么可爱。 妹妹被“鬼”的Boss无惨变为了鬼，炭治郎就怀着将妹妹变回人类的信念成为鬼杀队的一员， 与其他队员解决一个个由鬼引起的事件并不断成长的故事~ 里面除了高人气的妹妹，蝶之柱、珠世等人气角色也在P站有诸多同人作品。 3.5 我们无法一起学习/ぼくたちは勉強ができない-st Silver，ARVO ANIMATION 看封面就知道是个微后宫向的动画， 男主学霸辅导偏科天才们的故事， 理科天才想要攻读文科方向， 文科天才想要攻读理科方向， 体育特招的青梅竹马，要男主补英语， 看着男主这般努力刀子嘴豆腐心的傲娇老师…… 青春校园恋爱喜剧开幕啦啦啦啦。。。 Jul.4.0 石纪元/ドクターストーン/Dr.STONE-TMS Entertainment 一道奇妙的绿光，全世界所有人变成了石头， 男主几个从石头中重新活了过来， 便从0开始构建人类文明。 这部番都可以看成是科教片了， 毕竟从0构建全部文明，直接走工业革命并介绍历史上的重大发明， 还属于比较有意思的番。 不过长篇漫画的改编都有一点问题，就是长线剧情的跌宕起伏达不到短片的精彩， 毕竟要给后面留剧情演进，无法把人物写死。 3.0 骚动时节的少女们啊。/荒ぶる季節の乙女どもよ。-Lay-duce 讲述一个文学社的少女们谈性色变的故事， 然而原本都对恋爱避之不及或十分害羞的少女们， 在这骚动的时节每一个都走上了自己的故事. 3.8 流汗吧！健身少女/ダンベル何キロ持てる？/肌肉少女：哑铃，能举多少公斤？-动画工房 动画工房的水准真的是越来越高了， 这番要是某个健身房推出的， 绝对会员卡买爆啊！ 一边讲述硬核健身知识，一边用萌妹来演示， 充分调动肥宅的积极性。。。 Oct.3.4 喜欢本大爷的竟然就你一个？/俺を好きなのはお前だけかよ-CONNECT 男主高富帅，受各种妹子喜欢， 想着美丽的学姐与漂亮的青梅竹马间二取一就行， 然而没想到学姐与青梅竹马都希望男主牵线给他的基友…… 然而！没想到基友对男主竟然有深仇大恨， 想利用男主身边的妹子来报复男主， 看破一切的竟然是那个带着眼镜的神秘跟踪狂少女…… 这部番由一部参赛获奖小说改变， 小说剧情跌宕起伏，甚是精彩； 原作里把基友都当成反派Boss准备干掉了， 没想到作品火了后要出续集， 于是又强行洗白。。 所以本作只需要看到第一部分谜底揭开就可以了，后面就是纯粹的拖了。 4.5 慎重勇者～这个勇者明明超强却过分慎重～/慎重勇者～この勇者が俺TUEEEくせに慎重すぎる～-WHITE FOX 异世界穿越类中题材新颖的作品， 男主就是那种十里坡剑神， 在出生点练级到满级才去打boss的那类， 也由此产生了诸多笑点。 而在欢笑的背后， 也慢慢揭示了男主与女主前世的故事， 属于做工还不错，剧情尚可的异世界穿越系列~ 4.7 BEASTARS/动物狂想曲-Orange 这番有点《动物农场》的感觉了， 通过动物精妙的影射了社会的现实， 在校园中食肉与食草动物和谐相处， 而校外却是社会的残酷。 即使在校内，大灰狼爱上小白兔这种禁忌之恋也不按照偶像剧中那般发展， 小白兔并不纯洁，大灰狼也实在拥有者兽性， 反倒是这样才愈发显得真实， 也为这狼兔之恋增添了一些真实的质感。 4.5 灵笼：INCARNATION，INCARNATION-艺画开天 上乘的国产动画， 描述的背景是末世世界下残存的人类在空中城堡中的社会， 题材带有反乌托邦特色， 在这个社会自由恋爱、传统的爱情家庭观被视为旧世界的陋习， 根据基因培育下一代的人类， 基因优秀与普通还会区分人的阶级。 但为了生存的需要，在这新的社会下，获取我们现在所拥有的自由、平等、博爱才是脆弱的花朵吧。 3.0 碧蓝航线/アズールレーン/Azur Lane-Bibury Animation Studio 粉丝向的作品，也是为了给游戏做宣传， 但是做的还不错，给个及格分水平。 故事剧情也是极为政治正确了， 轴心国是被塞壬力量侵蚀做了蠢事， 然后与同盟国合力击败塞壬O(∩_∩)O 动画的一大特点是，角色在战斗中都会说与游戏中一样的台词， 战斗场面可圈可点， 剧情勉强差强人意， 粉丝向的可以一看。 续作类个人评分直接写到前面啦~ 4.3 心理测量者/PSYCHO-PASS/サイコパス 3-Production I.G PP3剧情还是不错，不过这一季只演了一半，另一半要等剧场版(剧场版剧情更为精彩哦！), 但是朱妹要为下一届主角让位，所以看不到朱美的飒爽英姿了。PP3的男主能力又有些过于玄幻，扣点分吧。 4.2 进击的巨人 3 还是一如既往的水准，不过国内禁播所以… 4.0 续·终物语/続・終物語/ゾク・オワリモノガタリ-SHAFT 这部一般，有点拖沓了，没有之前的惊艳。 3.8 某科学的一方通行/とある科学の一方通行-J.C.STAFF 不得不说，一方通行的地位还是远没有炮姐高啊，但是比本传魔禁还是要更出色的。 3.7 食戟之灵：神之皿/食戟のソーマ 神ノ皿-J.C.STAFF 剧情继续，不过这番越往后越魔幻，最后都快成魔法料理了。。 3.6 在地下城寻求邂逅是否搞错了什么/ダンジョンに出会いを求めるのは間違っているだろうか 2-J.C.STAFF 剧情继续前作，水准也和前作保持一致，还算可以 3.5 狂赌之渊×x/賭ケグルイ××-MAPPA 继续讲述蛇喰夢子与早乙女芽亞里在私立百花王学园的赌博故事~颜艺满满！ 3.3 约会大作战 3/デート·ア·ライブ 3/DATE A LIVE 3-AIC PLUS+ 继续以往的剧情和水准。 3.2 刀剑神域 异界战争/ソードアート・オンライン アリシゼーション War of Underworld-A-1 Pictures 刀剑爱丽丝这一篇属于质量不错的一篇，不过动画做的确实一般般，就强行坐等桐姥爷开挂就有些无趣了。 2.8 我们无法一起学习 2/ぼくたちは勉強ができない 2-st Silver，ARVO ANIMATION 剧情没有第一作精彩，伪恋式长篇拖沓的毛病出现了啊… Others 2.9 W’z/ウィズ-Go Hands 音乐作画上乘的《W’z》比《K》还要没有意思， 除了各种特效的作画就是卖肉. 2.8 我，不是说了能力要平均值么！/私、能力は平均値でって言ったよね！-project No.9 凤傲天类动画，女主能力要平均值结果获得的是世界总魔量的一半…但是剧情稍显无聊。 2.8 厨神小当家/真・中華一番！/中华小当家-Production I.G，NAS 骗情怀的重制版，但是过于赶，比以前节奏快了不少，看的云里雾里。 2.7 街角魔族/まちカドまぞく-J.C.STAFF 废萌系列，萌就完事了。 2.5 贤者之孙/賢者の孫/Wise Man’s Grandchild-SILVER LINK. 这一季度的龙傲天动画，超级大魔法师与魔道工具的养孙，上来就有MAX的魔法天赋然后各种装B的场景，无他唯爽尔。 2.5 女子高生の無駄づかい/女高中生的虚度日常-Passione 个人不太能欣赏来这类日常向的动画，类似《男子高中生的日常》，讲女高的。 2.5 重来吧、魔王大人/魔王様、リトライ！-EKACHI EPILKA 穿越系的动画，男主作为魔王穿越到自己写的游戏里面， 这类都带有龙傲天性质，本部番的看点可能就在女儿控了吧。。 2.2 超人高中生们即便在异世界也能从容生存！/超人高校生たちは異世界でも余裕で生き抜くようです!/High School Prodigies Have It Easy Even In Another World!-project No.9 龙傲天组团穿越，但是太过无聊。 2.0 环战公主 美少女格斗！但是挺无聊，两女主的故事线也很俗套。 1.5 笑容的代价 真的是好久没见过这么无聊平庸的作品了，男主守护公主的故事，无聊 End其实去年补了一些电影与剧场版， 从4、7月的新番也能看出来， 好番并不是很多， 并且随着对动画的阅历逐渐加深， 能够挑动心弦的作品越来越好， 回顾一些影视经典更能填补平淡的日常吧~]]></content>
      <tags>
        <tag>ACG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alice OS 7-Startup Table]]></title>
    <url>%2Fblog%2F2020%2F01%2F31%2Falice-7-startup-table%2F</url>
    <content type="text"><![CDATA[上一篇都是理论，都是虚的， 学过操作系统的小伙伴这些东西也都听了好多遍了， 我们这次就来实际配一下页表， 看看需要注意哪些事项~ Alice-OS: Startup Table Address Map Layout我们的目的是把KERNEL_START_VADDR(0x80000000)让它能映射为 KERNEL_LOAD_PADDR(0x60010000 or 0x00010000), 所以首先我们要把0x80000000对应的STE entry填成load_paddr的base address; startup_table.clink123456789101112#define STE_RSRV_BITS (0x2)#define STE_AP_SHIFT 10#define STE_BASE_SHIFT 20#define STE_KERNEL_DEF (STE_RSRV_BITS | STE_DOMAIN(0) | (0x2 &lt;&lt; STE_AP_SHIFT))#define STE_ADDR(base, offset) (((base &gt;&gt; STE_BASE_SHIFT) + offset) &lt;&lt; STE_BASE_SHIFT)__attribute__((__aligned__(SECTION_TABLE_ALIGN)))uint32_t startup_table[4096] = &#123; /* KERNEL_START_VADDR maps KERNEL_LOAD_PADDR */ [(KERNEL_START_VADDR &gt;&gt; 20) + 0] = STE_ADDR(KERNEL_LOAD_PADDR, 0) | STE_KERNEL_DEF,&#125;; 根据前一篇的原理分析，我们将0x80000000 - 0x80100000 1M 的空间映射到了0x60000000 - 0x60100000, 这样当我们取地址时就能拿到正确的数据了。 Domain我们取Domain 0, DACR[1:0]我们配置为Client 01, 也就是要应用页表的这些访问控制检查; AP我们使用0b10, 也就是映射的区域可读可写; RSRV_BITS实际上是确定table entry是使用section table entry的意思。 但是这里有个问题，如果我们就这样enable MMU之后, 我们的下一条指令还是0x6001xxxx吧? 虽然0x80000000映射好了， 但是0x6001xxxx这个是我们正在用的地址，用这个去访存取指令不就没有物理页对应么？ 所以除了0x80000000, 我们对原来的Load Address也要映射为真正的Load Address, 这部分就是1:1直接映射: startup_table.clink12345678__attribute__((__aligned__(SECTION_TABLE_ALIGN)))uint32_t startup_table[4096] = &#123; /* KERNEL_LOAD_PADDR is direct mapping */ [(KERNEL_LOAD_PADDR &gt;&gt; 20) + 0] = STE_ADDR(KERNEL_LOAD_PADDR, 0) | STE_KERNEL_DEF, /* KERNEL_START_VADDR maps KERNEL_LOAD_PADDR */ [(KERNEL_START_VADDR &gt;&gt; 20) + 0] = STE_ADDR(KERNEL_LOAD_PADDR, 0) | STE_KERNEL_DEF,&#125;; 好了，这样我们的映射就构建好了，我们下一条指令0x6001xxxx也能正常执行， 取地址什么的0x8000xxxx也能正常取到。由于只映射了1M的空间， 如果我们镜像慢慢变大可能会不够用， 所以实际实现过程中我各映射了16M。 startup_table.clink1234567891011121314__attribute__((__aligned__(SECTION_TABLE_ALIGN)))uint32_t startup_table[4096] = &#123; /* KERNEL_LOAD_PADDR is direct mapping (16M) */ [(KERNEL_LOAD_PADDR &gt;&gt; 20) + 0] = STE_ADDR(KERNEL_LOAD_PADDR, 0) | STE_KERNEL_DEF, [(KERNEL_LOAD_PADDR &gt;&gt; 20) + 1] = STE_ADDR(KERNEL_LOAD_PADDR, 1) | STE_KERNEL_DEF, ... [(KERNEL_LOAD_PADDR &gt;&gt; 20) + 15] = STE_ADDR(KERNEL_LOAD_PADDR, 15) | STE_KERNEL_DEF, /* KERNEL_START_VADDR maps KERNEL_LOAD_PADDR (16M) */ [(KERNEL_START_VADDR &gt;&gt; 20) + 0] = STE_ADDR(KERNEL_LOAD_PADDR, 0) | STE_KERNEL_DEF, [(KERNEL_START_VADDR &gt;&gt; 20) + 1] = STE_ADDR(KERNEL_LOAD_PADDR, 1) | STE_KERNEL_DEF, ... [(KERNEL_START_VADDR &gt;&gt; 20) + 15] = STE_ADDR(KERNEL_LOAD_PADDR, 15) | STE_KERNEL_DEF,&#125;; Enable MMU!好了，Startup Table已经填好，接下来就是配置TTBR、SCTLR用起来了: arch/arm/init.clink12345678910111213141516171819202122uint32_t val;/* init DACR, we only use domain 0 */val = 0x1;sysreg_write32(DACR, val);#if ARM_VERSION == 7 /* bit[2-0]: All address translation use TTBR0 */val = 0x0;sysreg_write32(TTBCR, val);#endifval = (uintptr_t)(&amp;startup_table);val = va2pa(val);sysreg_write32(TTBR0, val);/* enable mmu */sysreg_read32(SCTLR, val);val |= SCTLR_M;sysreg_write32(SCTLR, val);asm volatile ("mov r7, #0xAA");asm volatile (".word 0xdeadbeef"); 首先配置DACR, 把Domain 0设置为Client, ARMv7上我还把TTBCR配置为只使用TTBR0, 需要注意的是我们取到的&amp;startup_table是链接脚本里的虚拟地址， 需要给他转换成物理地址(减去KERNEL_START_VADDR 再加上KERNEL_LOAD_PADDR), 之后将它填到TTBR(0)里面, 使能MMU! 我们来验证一下，使能MMU之后我们mov r7, #0xAA是否可以执行成功吧！ vexpress-a9: QEMU 4.2.0 monitor - type &apos;help&apos; for more information (qemu) info registers R00=60010000 R01=6001a000 R02=60018000 R03=00c50079 R04=00000000 R05=00000000 R06=00000000 R07=000000aa R08=00000000 R09=00000000 R10=00000000 R11=60019fec R12=00000000 R13=00000000 R14=00000010 R15=0000000c versatilepb: QEMU 4.2.0 monitor - type &apos;help&apos; for more information (qemu) info registers R00=00010000 R01=0001a000 R02=00018000 R03=00090079 R04=00000000 R05=00000000 R06=00000000 R07=000000aa R08=00000000 R09=00000000 R10=00000000 R11=00019fdc R12=00019fe0 R13=00019fb8 R14=000100d0 R15=000100a8 R7里面就是我们想要的AA! 我们的页表配置成功! Next我们接下来就要把栈、PC等跳到真正的0x80000000了， 让他们跑在自己应该跑的地方~ 之后我们设置的就是操作系统非常重要的异常向量表, 如果上面这些代码小伙伴自己哪里写错的话会发现PC会跑到一个奇怪的地址, 那个地址就是当异常发生时系统控制流直接跳转的地方， 不设置异常向量表，我们的操作系统就无法处理任何错误， 发生错误时我们也得不到任何有用的信息， 不能处理系统调用请求和中断…]]></content>
      <tags>
        <tag>os-dev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alice OS 6-Address Translation]]></title>
    <url>%2Fblog%2F2020%2F01%2F31%2Falice-6-address-translation%2F</url>
    <content type="text"><![CDATA[本篇主要解释一下为什么要使用页表系统， 构建页表系统需要注意什么， 然后再看一下ARMv5与ARMv7页表格式的区别, 看能不能尽可能把两者的代码统一起来。 已经熟悉地址翻译的小伙伴可以直接看下一篇， 不玩虚的直接上手！ 页表系统我们学习操作系统原理的时候一定会讲页表， 我们也都知道虚拟地址经过页表翻译会变成物理地址。 那么页表是为了解决什么问题呢？ 设想一下，如果我们没有页表，就像我们之前的代码那样一行行直接跑， 我们在linker script里面把起始地址改成和实际启动地址一样， 好像也是OK的。只要链接脚本生成的地址和实际启动地址一致， 我们的访存也不会出错，好像已经很完美了。 在没有OS的时候，我们的CPU直接跑的裸程序(bare metal), 那么如果想跑多个APP的话，就需要保证APP之间地址不能互相重叠。 但这样一个APP也基本上只能跑在这个CPU上了， 换个CPU可能别的APP就把这个给占了， 总不能我们每次换一个CPU要么赌运气别的APP没用我们的地址， 要么我们重新编、甚至重新写吧？ 所以我们一定需要一个地址翻译， 每个APP都可以从同一个地址开始执行， 只要我给他们映射到不同的物理地址上就行了。 至于为何慢慢发展成2级或者如今64位系统的4级页表， 则主要是为了满足硬件越来越大的物理地址以及减少内存外部碎片的原因。 内存碎片和页表的发展有兴趣的小伙伴可以私下自己再看啦。 TTBR &amp; First Level Table将输入的va(virtual address)翻译为pa(physical address)的过程叫做page walk, 也叫address translation. ARMv5的页表非常简单，只要我们构建一个表装到这个TTBR里， SCTLR里的M-bit一使能，MMU就会开始地址翻译了。 那么页表翻译的规则是什么样的呢? 这里我用ARMv7的页表翻译过程来说, ARMv5的类似，不过v7的图更简洁: 我们在ARMv7上会将图中的N设置为0，这样ARMv7上就只使用TTBR0且格式与ARMv5的TTBR保持兼容， 可以看到，va的bit[31-20]会作为一级页表的index, 通过这个index和TTBR里存放的base, 就可以找到对应的页表项(Page Table Entry, PTE or Section Table Entry, STE)。 如图中所示，我们1级页表有3种格式，分别是Section, Page Table和Supersection, Page Table更为细粒度，还需要2级页表，在2级页表里还有大页和小页等等。 总的来说: 使用section, 那么每个entry对应1M物理内存区域; 使用Supersection, 每16个entry内容一模一样, entry指向16M物理内存区域; 使用Page Table 大页和section类似, 一个指向1M物理内存, 小页是常见的4K页，一个指向4K物理内存。 我们随后再解释为什么它们指向1M、16M或者4K物理内存， 我们首先观察，由于一级页表的index范围是 bit[31-20]， 所以可以存放2^12 = 4096个entry。每个entry是个32位长变量(4byte)， 所以一级页表的大小就是 4byte * 4096 = 16KB. 由于每个STE对应1M物理内存，所以这个页表最大能够映射 1M * 4096 = 4G的物理地址空间。 而为什么是4G物理内存呢? 是因为我们虚拟地址长度32位 2^32 = 4G, 所以虚拟地址空间的范围最大就是4G。物理地址也是32位，同样最大也就是4G物理地址空间了。 (Long-descriptor format 支持更大的物理地址空间, 虚拟地址空间仍为4G)。 现在再回头看看图1中TTBR的Format: 他的bit[13-0]是(Sould Be Zero/SBZ), 其原因就是1级页表是16K大小，而TTBR又要求一级页表是16KB对齐的， 因此页表地址的后14位一定为0. Address Translation由于Section最为简单，我们以一级页表是Section为例 每个entry是一个STE, 对应1M物理内存。 详细的查表过程如下: 32位的va, 取bit[31:20]作为index, 加到TTBR里的Base上, 这样产生的物理地址 |Base[31:14] | va[31:20] | 00 | 指向的就是1级页表的某个entry (STE)。 由于entry都是4byte (32bits), 又是对齐的，所以最后两个bit一定是0; 再来看看输入的va, va只用了bit[31:20], 还有[19:0]呢， 这后20位又是怎么使用的呢？这就要看我们上一步取出来的STE了。 STE格式如下: 可以看到STE的bit[31:20]存放的是section base address, 这个section base address就是我们刚刚说的这个STE对应的1M物理内存的基址！ 最后翻译得到的物理地址就是 | section base address | va[19:0] | 这样一个32位地址了。 所以我们看到1级section table实际上只对va的前12位 bit[31:20]进行了翻译， 翻译成了section base address, va的后20位直接拿来使用，组成了一个物理地址。 所以我们如果想让这个翻译成立，就必须对物理内存进行切分，切分成1M大小的块， 每一块的起始物理地址都要对齐到1M大小(即后20位为0), 这些物理地址块就可以作为STE里面的section base address。 所以这也是为什么我们开头说section对应1M物理内存区域， 这1M的物理块是va通过地址翻译找到的， 找到了这个物理块之后，后面的20位地址就可以直接拿来用了。 假如: (答案在文末) section指向的是2M的物理内存, 那么Section Table的大小要如何改变？STE如何改变? 虚拟地址我们最大只有2G, Section Table大小和STE如何改变? 物理地址我们想支持8G, 又要改变什么呢？ 我们想支持16G的虚拟地址, 需要怎么办? Page Table那么Page Table的格式也就类似了: va会被拆成3部分: va[31:22] : index of first level page table va[21:12] : index of second level page table va[11:0] : offset of page 其中1级页表的PTE (也叫PDE: Page Directory Entry) 存放2级页表的base; 2级页表的PTE存放4K物理页的base, 最后从2级页表的PTE中取出20位长的4K物理页base再加上va[11:0]组成真正的物理地址(如上图Fine page table)。 所以使用页表，物理页就会被分成4K的小块，也就更为灵活了。 Bits in Table Entry我们发现上图中，Table Entry不止存放有物理页的base, 还有一些其它的东西: AP, Domain, C, B AP是Access Permission, 可以控制这块内存是否可以访问，是否可以被非特权的用户态访问, 是否可写等等。 Domain: ARM有个Domain Access Control Register DACR。 32位的寄存器被分成了16个Domain, 每个Domain 2个bit: Value Meaning Description 00 No access Any access generates a domain fault. 01 Client Accesses are checked against the access permission bits in the section or page descriptor. 10 Reserved Reserved. Currently behaves like the no access mode. 11 Manager Accesses are not checked against the access permission bits so a permission fault cannot be generated. 每个Domain可以设置是否可以访问或者是否启用安全检查， 页表项指向的这个区域会对应于一个Domain，在访存时进行访问控制检查。 我们当然还是希望应用检查的，所以会用0b01 Client; C, B就是Cache属性, 对应的内存区域是否是cachable, 是否为Write-Back等等; 关于Cache我们暂时不会涉及，有兴趣的可以自己查一下。 ARMv5 vs ARMv7ARMv7的页表可以用两个TTBR, 可以分别用于内核和用户态， 等我们以后用到TTBR1的时候再解释这么做的好处。 ARMv7里面的AP还有第3个: AP[2] 可以进行更细粒度的控制， 或者通过配置SCTLR.AFE将AP[0]用做Access Flag, 可以查看内存是否被硬件访问过，用于刷Cache等等。 ARMv7还有Execution Not bit, 用来表明某个内存区域不可执行等等。 总之ARMv7有更多有关安全、Cache的bits, 目前我们为了方便演示，会将ARMv7配置为兼容ARMv5的形式, 所以这些bit暂且不用理会, 有兴趣的自己可以研究一下。 Next现在我们已经知道了地址翻译的原理和过程， 下面就来看看我们如何来构建启动的页表吧。 Notes 如果section指向2M物理内存, 就意味着4G的地址范围需要 2048个entry, 每个entry 4B, Section Table大小就是 4B * 2048 = 8K, 对齐到8K 所以后13位要全为0。 TTBR的格式就是 bit[31:13]是Base (19bits), bit[12:0]SBZ; 由于entry变少，用于index的va就只需要[31:21] 11个bit用来作为index了, 和TTBR的19个bits拼起来就是STE的地址，依旧是最后两位为0。 STE由于对应2M区域，所以后21位可以都作为other bits, section base address就只需要32-21 = 11bits, 即 bit[31:21]; 虚拟地址最大为2G, 我们要翻译的地址大小就少了一半， 所以Section Table entry减半, 其他不变。 物理地址想支持8G, 那就是说最后的STE中填写的Base要多一个bit, 这样才能索引到更大的物理地址， 所以STE中的section base address要多一位来保证能索引到8G的物理地址范围。 ARM本身支持物理地址扩大到16G, 可以自己参考一下ARM手册是怎么改Descriptor格式的吧~ 如果我们想支持16G的虚拟地址(va 34位)，要么把Table番两番，entry加到 4096 * 4; 要么就要再引入多级页表, 把va拆成多份, va[a|b|c|d|…], a作为1级页表的index, b是2级页表的index, c是3级页表的index… 最后在最后一级页表中取出来physical address base, 拼上最后没用做index的va; 本质上，多级页表就是添加了更多的table entry, 又保持每张页表小一些，不至于16K 64K 256K…这样越来越大。]]></content>
      <tags>
        <tag>os-dev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alice OS 5-System Regs]]></title>
    <url>%2Fblog%2F2020%2F01%2F30%2Falice-5-system-regs%2F</url>
    <content type="text"><![CDATA[为了配置内存，首先我们要先熟悉一下ARM的系统控制寄存器。 除了CPU提供的功能外，ARM提供了16个协处理器(Coprocessor)接口, 芯片厂商可以自己外接协处理器来完成更为复杂的功能。 如果想要使用地址映射，那就需要借助MMU(Memory Management Unit)单元对地址进行翻译。 而包含MMU功能在内的诸多系统控制都是要通过Control Coprocessor接口CP15来完成， 这也是ARM预留的几个4个协处理接口之一。 本篇我们主要来看一下ARM访问这些控制寄存器的方式， 并简单看一下我们随后要用到的几个控制寄存器。 Alice-OS: System Register Control Register CP15根据ARM的手册(ARM1176JZ-S TRM)描述: The processor supports the connection of on-chip coprocessors through an external coprocessor interface. All types of coprocessor instruction are supported. The ARM instruction set supports the connection of 16 coprocessors, numbered 0-15, to an ARM processor. In the processor, the following coprocessor numbers are reserved: CP10 VFP control CP11 VFP control CP14 Debug and ETM control CP15 System control. You can use CP0-9, CP12, and CP13 for your own external coprocessors. ARM使用了CP15的接口来实现系统控制的寄存器， 访问这些寄存器需要使用特殊的指令:mrc和mcr, 分别对应读和写, 访问一个cp15的寄存器格式类似于: mrc p15, op1, Rd, CRn, CRm, op2 关于op1, op2, CRn, CRm我们在查相关寄存器的时候看手册就行, Rd是我们使用的通用寄存器。 利用GCC内联汇编的语法，参考一下Linux我们可以写出类似的读写: sysreg.hlink123456789101112#define sysreg_read32(name, var) do &#123; \ uint32_t __val; \ asm volatile("mrc p15, " name : "=r" (__val)); \ var = __val; \&#125; while (0)#define sysreg_write32(name, val) do &#123; \ uint32_t __val = val; \ asm volatile("mcr p15, " name :: "r" (__val) : "cc"); \ isb(); \&#125; while (0) 其中name就是系统寄存器的名称，比如我们之后要看的System Control Register (SCTLR) 编码就是: #define SCTLR &quot;0, %0, c1, c0, 0&quot;; 目的就是将系统寄存器的值读到var中，或将val中的值写到系统寄存器里。 SCTLR &amp; TTBR系统中非常重要的控制寄存器就是SCTLR (在ARMv5中叫Ctrl Register c1), 它负责控制系统的各种重要功能: 中断、FIQ、Cache、Alignment Check、MMU使能等等, 如果我们想要使能MMU的话，就需要将SCTLR的M (bit0)置为1。 TTBR (Translation Table Base Register)顾名思义， 就是存放页表基址的寄存器， 里面存放有页表的物理地址, 当我们打开MMU之后， 每一次访存操作MMU都会把输入地址作为虚拟地址， 从这个寄存器中找到Translation Table, 把地址翻译成物理地址后真正的去访存。 我们可以看一下启动之后这两个寄存器的内容: kernel/init.clink12345678910111213void init(pa_t kernel_load_address)&#123; uint32_t val; arch_init(); sysreg_read32(SCTLR, val); asm volatile("mov r5, %0" : "=r" (val)); sysreg_read32(TTBR0, val); asm volatile("mov r6, %0" : "=r" (val)); asm volatile(".word 0xdeadbeef");&#125; TTBR0带个0的原因是ARMv7有两个TTBR, ARMv5只有一个, 但是两者的编码是一致的，所以用TTBR0统一起来。 置于为什么有两个TTBR, 等我们以后用到了再说~ 小伙伴们可以checkout到我开头给的这个commit, 自己验证一下~ SCTLR的值放到了r5里面， TTBR0放到了r6里面。 123456789# vexpress-a9 (armv7)make PLAT=vexpress-a9 qemu-telnettelnet localhost 1234(qemu) info registersR00=60010000 R01=60013000 R02=60000100 R03=00000000R04=00000000 R05=00c50078 R06=00000000 R07=00000000R08=00000000 R09=00000000 R10=00000000 R11=60012ffcR12=00000000 R13=00000000 R14=60010080 R15=01698c00 123456789# versatilepb (armv5)make PLAT=versatilepb qemu-telnettelnet localhost 1234(qemu) info registersR00=00010000 R01=00013000 R02=00000100 R03=00000000R04=00000000 R05=00090078 R06=00000000 R07=00000000R08=00000000 R09=00000000 R10=00000000 R11=00012ffcR12=00000000 R13=00012fe0 R14=0001004c R15=0001007c 然后分别对照手册armv7 TRM与arm926ejs_trm查一下两个之间有什么区别。 vexpress-a9上sctlr是 0x00C50078, versatilepb上是 0x00090078, ttbr则都是0。 那么接下来我们就要认真研究一下TTBR的格式，来构建我们的页表啦。 Noteaarch64上系统寄存器已经不是用cp15访问了，以后我们开始支持aarch64的时候再说~]]></content>
      <tags>
        <tag>os-dev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alice OS 4-File Structure]]></title>
    <url>%2Fblog%2F2020%2F01%2F29%2Falice-4-file-structure%2F</url>
    <content type="text"><![CDATA[在开始内存映射之前，我们暂且小憩一下， 聊一聊比较玄学的问题: 目录结构。 之所以这个单拎出来讲是因为在工作中发现许多专业的开发人员对目录结构都不以为意， 即使是有好多年开发经验的人目录结构也可能是一团糟。 但是一个好的目录结构对于构建的效率、代码的可维护性是极为重要的， 所以本篇来说一下我们的Alice OS准备采用的目录结构。 Alice-OS: File Structure 头文件大体上来说，我们希望在kernel的C文件中只用关心kernel的东西， 将arch、plat相关的东西都放到头文件中隐藏掉， 一级级抽象上来: 1234567891011121314151617181920212223242526[0] % tree.├── arch│ └── arm│ ├── build.mk│ ├── config.mk│ └── include│ └── arch│ ├── memory.h│ └── type.h├── kernel│ ├── include│ │ └── alice│ │ ├── memory.h│ │ └── type.h│ └── init.c│└── plat ├── versatilepb │ ├── include │ │ └── plat │ │ └── memory.h └── vexpress-a9 └── include └── plat └── memory.h plat 里面存放的是跟各个平台紧相关的内容， 包含kernel的起始地址、各种外设的物理地址等等; arch 存放的是跟体系结构相关的内容， 比如像各种uint32_t、uint64_t的typedef等等， 这种就是跟体系结构相关的，所以我们把这些内容放到arch目录下; kernel 中的内容就是跟体系结构也不相关的内容了; 在include头文件时，arch/include会include plat/include目录下的头文件， kernel/include会includearch/include目录下的头文件。 我们将 plat, arch 与 kernel依次规定为下-&gt;上，最上层的kernel视为最高抽象。 那么每一级include下存在的头文件，都只能include本级以及下一级的头文件: /* kernel/include/alice/memory.h */ #include &lt;arch/memory.h&gt; /* arch/arm/include/arch/memory.h */ #include &lt;plat/memory.h&gt; 这样我们就能一层层在头文件中把细节给抽象掉。 源文件如果说头文件是抽象过程，那么源文件就是对抽象的使用， 也因此更具体的源文件是可以使用更抽象的内容的。 具体来说，上图中 arch/init.c 就可以include kernel/include 与 arch/include。 这是因为对于体系结构这一更具象的内容来说，kernel层面的东西更为抽象， 所以体系结构可以使用更抽象的kernel中定义的方法和常量， 因为Kernel定义的内容必然更为通用。 路径可以发现我在include目录下又添加了 arch/plat/alice 的目录，看起来有些冗余， 其实主要目的就是让我们能在代码里通过 #include &lt;arch/xxx.h&gt; #include &lt;plat/xxx.h&gt; #include &lt;alice/xxx.h&gt; 这种明显的方式知道使用的哪一级的头文件，也允许了不同抽象级头文件的重名。 Future后续当我们的代码慢慢变多之后，还会有driver、lib、uapi等等， 但是无论我们添加什么目录或者组件， 我们的核心思想都是保证抽象的东西只使用抽象的东西， 我们和具体体系结构无关的代码就只关心逻辑， 这样才能使得代码有更好的可移植性。 当然这个目录结构也是我个人习惯啦， 只要目录结构方便扩展、移植就完全OK.]]></content>
      <tags>
        <tag>os-dev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alice OS 3-Init Stack]]></title>
    <url>%2Fblog%2F2020%2F01%2F29%2Falice-3-init-stack%2F</url>
    <content type="text"><![CDATA[在上一次我们已经知道了内核实际的加载地址在不同平台上是不同的， 本篇我们来设置一个启动的栈，并进入C代码的初始化流程, 同时考虑如何将这不同的加载地址告诉后续的启动代码。 Alice-OS: Init Stack AT Keyworkd我首先给不同的Plat里面添加了各自的linker.ld, 1234# alice-os/plat/vexpress-a9/linker.ldkernel_start_address = 0x80000000;kernel_load_address = 0x60010000; 并在alice.ld中include了它们: 123456789101112# alice.ldINCLUDE linker.ldENTRY(entry)SECTIONS&#123; . = kernel_start_address; .text : AT(kernel_load_address) &#123; *(.text) &#125; PROVIDE(etext = .); 每个plat自己指定内核的启动虚拟地址和加载的物理地址， 我们这里没有用到AT, 因为linker script输出是按照output section address来的， 但是AT告诉了Linker这个镜像实际加载的地址， 但是一些程序loader如果使用这个linker script的话就知道到哪里去找实际的代码了; 在linker script的官方说明里也列举了这样的一个demo: demo scriptlink12345678SECTIONS &#123; .text 0x1000 : &#123; *(.text) _etext = . ; &#125; .mdata 0x2000 : AT ( ADDR (.text) + SIZEOF (.text) ) &#123; _data = . ; *(.data); _edata = . ; &#125; .bss 0x3000 : &#123; _bstart = . ; *(.bss) *(COMMON) ; _bend = . ;&#125;&#125; 当Loader发现AT指明了数据段(.mdata)实际上是在代码段(.text)的后面， 但是生成的虚拟地址是在0x2000时， Loader就可能采用如下方式去把数据放到正确的位置上: 12345678extern char _etext, _data, _edata, _bstart, _bend;char *src = &amp;_etext;char *dst = &amp;_data;/* ROM has data at end of text; copy it. */while (dst &lt; &amp;_edata) *dst++ = *src++;... 通过这种方式将data放到真正的地址上. 我们的内核也是一样，如果我们查看反汇编会发现， 我们的代码也是从0x80000000开始的， 但是实际上启动的地址却是 0x60010000。 所以如果我们想让代码后面能正常运行， 正常找到各种symbol，就需要把整个alice.bin从0x6001000 copy到 0x80000000; 不过好在我们的CPU是可以使用虚拟地址进行映射的， 所以才避免了这种copy。 Init Stack我们在上一篇中强行把当前的PC对齐到4K, 然后自己加了0x2000作为栈底。 这样显然是有风险的，如果启动代码过多超过了一个4K页， 那我们的这种计算就会出错。 由于我们现在知道了启动的时候可以通过PC获取启动地址， 又知道了生成的栈地址， 所以我们可以用Addr(栈) - 0x80000000 + Addr(Load_Start)来获取真正的栈地址: 12345678910111213141516.global entryentry: # get load address mov r0, pc sub r0, r0, #8 # calculate real stack address ldr r1, =#kernel_stack_start sub r1, r1, #KERNEL_START_ADDRESS add r1, r1, r0 # set stack mov sp, r1 # r0 is load address bl init 通过这种方式我们就可以正确的计算出栈的物理地址并赋到sp中， 当我们的栈初始化好了之后， 就可以调用其他的函数了，通过bl我们可以直接跳到C代码。 Function Frame当发生函数调用时，apcs的calling convention会对函数生成一个栈帧(Frame), 存放栈帧的寄存器在Alice OS 1中也说过， 是寄存器R11 (FP Frame Pointer)负责保存。 我们来查看一下生成的 alice.dump.asm 观察一下arm的栈帧: 80000000 &lt;entry&gt;: 80000000: e1a0000f mov r0, pc 80000004: e2400008 sub r0, r0, #8 80000008: e59f100c ldr r1, [pc, #12] ; 8000001c &lt;kernel_start_addr ess+0x1c&gt; 8000000c: e2411102 sub r1, r1, #-2147483648 ; 0x80000000 80000010: e0811000 add r1, r1, r0 80000014: e1a0d001 mov sp, r1 80000018: eb000000 bl 80000020 &lt;init&gt; 8000001c: 80002000 andhi r2, r0, r0 80000020 &lt;init&gt;: 80000020: e1a0c00d mov ip, sp 80000024: e92dd800 push {fp, ip, lr, pc} 80000028: e24cb004 sub fp, ip, #4 8000002c: e24dd008 sub sp, sp, #8 80000030: e50b0010 str r0, [fp, #-16] 80000034: deadbeef cdple 14, 10, cr11, cr13, cr15, {7} 80000038: e320f000 nop {0} 8000003c: e24bd00c sub sp, fp, #12 80000040: e89da800 ldm sp, {fp, sp, pc} 我们来看一下当init被调用时首先做了什么: 我们发现当有函数调用时，arm和x86类似， 会首先将原来的sp放到ip中，保存当前的fp, ip(原来的sp), lr, pc 到栈上。 之后将原来的sp - 4存放到fp里面; 所以现在fp就指向了当前函数栈的栈底， sp由于push的原因指向了当前栈的栈顶。 我们可以利用monitor来验证一下: (0x80000038行是我们的0xdeadbeef, 会导致程序挂在这里) [0] % telnet localhost 1234 Trying 127.0.0.1... Connected to localhost. Escape character is &apos;^]&apos;. QEMU 4.2.0 monitor - type &apos;help&apos; for more information (qemu) info registers R00=60010000 R01=60012000 R02=60000100 R03=00000000 R04=00000000 R05=00000000 R06=00000000 R07=00000000 R08=00000000 R09=00000000 R10=00000000 R11=60011ffc R12=60012000 R13=00000000 R14=60010038 R15=026f7c00 (qemu) x /4x 0x60011ff0 60011ff0: 0x00000000 0x60012000 0x6001001c 0x6001002c 我们查看一下Push的值: (push {fp, ip, lr, pc}) 可以看到，R11(FP)指向当前栈底(0x60011ffc)，R12(IP)根据上面的反汇编， 存的就是之前的栈顶(0x60012000). 而LR指向了0x6001001c; 我们现在看一下entry在bl到init后的下一条指令(0x8000001c), 正是init如果返回的话应该执行的地址! (换算成Load Address) 所以总结一下: ARM在函数调用时会产生栈帧，所以如果我们一上来要call C代码的话就要初始化栈; ARM的栈结构如下: Pointer Content Note IP(old SP)-&gt; Prev Stack Content 前一个函数的栈 FP-&gt; pc Curr Stack Bottom - lr Return Address - old sp - SP-&gt; old fp - 而当init执行完毕时, arm会首先利用fp(当前栈底) - #12移动sp到栈顶, 之后恢复fp, sp, pc. 这里我们注意一下, ldm sp, {fp, sp, pc}依次将old fp, old sp, return address; 恢复到fp, sp 和 pc中。 控制流跳回，sp恢复，fp恢复，函数调用完毕。 Next现在我们已经可以运行C代码了， 但是我们当前的代码还是无法获取data， data实际都在0x60010000往后的地址里， 而生成的代码是按0x80000000计算的。 所以接下来我们就要想办法让物理地址0x60010000映射到0x80000000这个虚拟地址上。 Note当前这个栈帧之所以如此明显是因为我们没有打开编译器的优化， 如果打开优化之后看到的就不一定是这样了~]]></content>
      <tags>
        <tag>os-dev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alice OS 2-Load Address]]></title>
    <url>%2Fblog%2F2020%2F01%2F29%2Falice-2-load-address%2F</url>
    <content type="text"><![CDATA[为了方便不同平台的演示，这次我们添加一个新的平台， 是ARM versatilepb 平台的arm926ej-s处理器, 这是一款比较老的ARM处理器 CPU是A9系列的ARM926EJ-S, ARMv5TE架构; 我们来看看这个CPU起始的地址，并且考虑如何给我们的Alice OS初始化一个临时的栈~ Alice-OS: Load Address Versatilepb &amp; ARM926EJ-S我们仿照vexpress-a9建一个新的平台，并用类似的方式看看启动之后的LR地址: 123456789101112131415# Another shell:alice@MacAlice ‹ 521074d ↑●● › : ~/Codes/alice-osmake PLAT=versatilepb qemu-telnetalice@MacAlice ‹ 521074d ↑●● › : ~/Codes/alice-os[0] % telnet localhost 1234Trying 127.0.0.1...Connected to localhost.Escape character is &apos;^]&apos;.QEMU 4.2.0 monitor - type &apos;help&apos; for more information(qemu) info registersR00=000000a3 R01=00000183 R02=00000100 R03=00000000R04=00000000 R05=00000000 R06=00000000 R07=00000000R08=00000000 R09=00000000 R10=00000000 R11=00000000R12=00000000 R13=00000000 R14=00010008 R15=00010004 可以发现，这次的LR (R14)是0x10008了, 说明启动是从0x10000开始执行的, 所以我们现在知道, vexpress-a9是从0x60010000开始执行, 而versatilepb是从0x00010000开始执行的 接下来让我们给他们都给一个初始的栈吧 Init Stack我们在汇编里面声明一段空间，并把它当做我们的内核栈: 12345678910111213141516171819202122232425.global entryentry: mov r0, pc # R5 save PC mov r5, r0 # make r0 4k aligned mov r0, pc bic r0, r0, #0xFF0 bic r0, r0, #0xF # This is the .L_stack_start add r0, #0x2000 mov sp, r0 ldr r1, =.L_stack_start ldr r2, =#kernel_stack_start mov r3, sp push &#123;r0&#125; mov r4, sp .word 0xdeadbeef .align .section &quot;.stack&quot;, &quot;aw&quot;.L_stack: .space 4096.L_stack_start: 我们在代码段的最下面声明一个4K大小的空间，并将它连接到”.stack”段里面: 1234567.bss : &#123; *(.bss COMMON) &#125;. = ALIGN(4096);.stack : &#123; *(.stack);&#125;kernel_stack_start = .; 我们可以看一下，r0到r5里面的值都是多少: r0是我们计算出来并赋值给sp的栈; r1是直接加载.L_stack_start这个tag得到的地址; r2是从linker script中取得的kernel_stack_start这个symbol地址; r3是赋值之后的sp; r4是push一次之后的sp; r5是程序一开始的PC; 123456789101112131415alice@MacAlice ‹ 521074d ●● › : ~/Codes/alice-os[0] % telnet localhost 1234Trying 127.0.0.1...Connected to localhost.Escape character is &apos;^]&apos;.QEMU 4.2.0 monitor - type &apos;help&apos; for more information(qemu) info registersR00=60012000 R01=80002000 R02=80002000 R03=60012000R04=60011ffc R05=60010008 R06=00000000 R07=00000000R08=00000000 R09=00000000 R10=00000000 R11=00000000R12=00000000 R13=00000000 R14=60010034 R15=016a8000PSR=400001db -Z-- A S und32(qemu) x /x 0x60011ffc60011ffc: 0x60012000 我们计算栈的方式是这样: 假设启动这部分代码最长不超过4K大小, 那我空4K出来将当前PC后12位清零， 加上两个4K页就是我的栈底。 但是我们直接Load Symbol会发现, 无论是tag还是从linker script取出来的 地址都是0x80002000。这是由于我们linker一开始给的其实地址是80002000, 导致我们的栈变成了这样。 但是至少我们了解了，代码开始往后2个页就是栈底，所以我们使用 0x60012000作为栈底是没有问题的! 通过 x 命令我们也看到了，push一次之后，栈里确实存了我们要的数据。 那么接下来，我们就考虑如何更优雅并且正确的设置栈，尽快从汇编跳到C代码吧!]]></content>
      <tags>
        <tag>os-dev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alice OS 1-First Commit]]></title>
    <url>%2Fblog%2F2020%2F01%2F28%2Falice-1-first-commit%2F</url>
    <content type="text"><![CDATA[本篇我们主要来看一下第一个Commit里面的Makefile, alice.ld 以及最开始代码startup.S. 这里会介绍一下查看反汇编的方法以及写ARM汇编的小技巧。 Alice-OS: First Commit Makefile &amp; Monitor我这里使用了Makefile来进行构建，关于Makefile的教程有很多, 由于我也不准备构建多复杂的系统，所以Makefile写的会比较简单。 这里给两个链接以供参考: A Simple Makefile Tutorial Unix Makefile Tutorial 里面的规则等等都比较简单，这里主要说一下启动Qemu的一些区别: 123456789qemu: $(OS).binqemu-system-arm $(QEMU_FLAGS) -kernel $(OS).binqemu-gdb: $(OS).binqemu-system-arm $(QEMU_FLAGS) -gdb tcp::1234 -S -kernel $(OS).binqemu-telnet: $(OS).binqemu-system-arm $(QEMU_FLAGS) \ -monitor telnet:127.0.0.1:1234,server,nowait -kernel $(OS).bin make qemu 会直接编译并运行，make qemu-gdb和make qemu-telnet则分别让 qemu将1234端口开放给gdb与telnet; QEMU Monitor可以让我们在系统挂住的时候查看一些寄存器的状态 nowait的作用是为了让QEMU在monitor连上之前自己也会往下跑， 因为我们主要是为了查看最后系统hung住时的寄存器状态. GDB的使用我们以后再说~ Link Script链接脚本的语法讲解网上也非常多，这里提供一个链接供参考:Linker Script. 这里主要看一下我们的地址: 12345678910111213141516171819ENTRY(entry)start_address = 0x0;SECTIONS&#123; . = 0x80000000 + start_address; .text : AT(start_address) &#123; *(.text) &#125; PROVIDE(etext = .); ... .stack : &#123; *(.stack); &#125; kernel_stack_start = .; PROVIDE(kernel_end = .);&#125; 我后面打算让Kernel从 0x80000000开始映射，所以把kernel最开始的代码放到了 0x80000000地址上， 这里引入一个start_address的原因是因为不同的平台会默认让系统从不同的地址启动. 为了让后面映射地址时方便计算而引入的。 也就是说，当我们的虚拟地址映射建立好之后, 内核的第一行代码应该是从0x80000000 + start_address开始的。 Bin &amp; Elf接下来就是我们的第一行代码了，ARM平台上当内核镜像被放到内存中之后， CPU会从加载的第一条指令直接开始执行。 这也就要求我们编译完内核镜像后去掉开头的elf header; 我们用gcc编译完的镜像本身是elf格式的，这个格式有一个header: xxd alice.bin &gt; alice.bin.dump xxd alice.elf &gt; alice.elf.dump 1234567/* alice.bin.dump */ 00000000: 3302 00e3 efbe adde 0000 3........./* alice.dump.asm */80000000 &lt;entry&gt;:80000000: e3000233 movw r0, #563 ; 0x23380000004: deadbeef cdple 14, 10, cr11, cr13, cr15, &#123;7&#125; 用xxd查看16进制，会发现alice.bin的内容也就是我们内核实际的内容非常简单, 开头的 3302 就是我们的 0x233的小端写法，与我们的反汇编一致，开头就是指令; 那么alice.elf.dump呢？ ... 4096 0000fff0: 0000 0000 0000 0000 0000 0000 0000 0000 ................ 4097 00010000: 3302 00e3 efbe adde 0000 4126 0000 0061 3.........A&amp;...a 4098 00010010: 6561 6269 0001 1c00 0000 0543 6f72 7465 eabi.......Corte 4099 00010020: 782d 4139 0006 0a07 4108 0109 022a 0144 x-A9....A....*.D ... 发现我们的代码3302 00e3是从第二个页(4097)开始的, 第一个页是elf自己加的东西; 在后面也还有一些跟体系结构相关的东西(Cortex-A9). 所以elf文件本身有自己的格式, 但是ARM设备是从第一条指令直接执行的, 所以我们要用objcopy把我们要的东西从 elf文件里面copy出来! 再次看makefile: 123456...$(OS).bin: $(OBJS) $(OS).ld $(LD) -T $(OS).ld $(OBJS) -o $(OS).elf $(OBJCOPY) -O binary $(OS).elf $(OS).bin $(OBJDUMP) -D $(OS).elf &gt; $(OS).dump.asm... 可以看到, 我们的alice.bin实际上就是 arm-none-eabi-objcopy -O binary alice.elf alice.bin生成的. 但是我们的objdump又需要用到elf格式，这样它才认识里面的debug symbol, 才能生成方便我们调试的反汇编。 First Instruction现在终于可以来看看我们的第一条指令了: 1234.global entryentry: mov r0, #0x233 .word 0xdeadbeef 内容非常简单，就是把0x233放到r0里面， 这里.word 0xdeadbeef就是在代码段里面插入一个错误的指令， 当CPU执行完mov r0, #0x233后就会尝试解析0xdeadbeef, 由于解析失败，所以就会卡在这里。 Register Info使用 make qemu-telnet 并且在另一个shell连上, 我们来看一下寄存器信息: 123456789101112alice@MacAlice ‹ 9d021c0 › : ~/Codes/alice-os[0] % telnet localhost 1234Trying 127.0.0.1...Connected to localhost.Escape character is &apos;^]&apos;.QEMU 4.2.0 monitor - type &apos;help&apos; for more information(qemu) info registersR00=00000233 R01=000008e0 R02=60000100 R03=00000000R04=00000000 R05=00000000 R06=00000000 R07=00000000R08=00000000 R09=00000000 R10=00000000 R11=00000000R12=00000000 R13=00000000 R14=60010008 R15=0eb25134PSR=400001db -Z-- A S und32 R0和我们想的一样，内容就是233, 启动寄存器这里也一并介绍一下: Reg Alias Purpose R0 - R3 - Caller Saved General Purpose R4 - R8 - Callee Saved General Purpose R9 - Might Callee Saved General Purpose R10 - Callee Saved General Purpose R11 FP Frame Pointer / Callee Saved General Purpose R12 IP Intra Procedural Call (Used by Dynamic Link) R13 SP Stack Pointer R14 LR Link Register (Save Return Address) R15 PC Program Counter PSR - Program Status Register Caller / Callee 相关的可以看一下aapcs calling convention. 主要是说函数调用时, r0-r3我们可以随便用; R13是我们的栈, R14存的返回地址, R15是是PC. 但是我们发现，本应该存返回地址的R14里面存的是什么呢:0x60010008 也就是说，现在CPU认为我们之前是从60010008跑到了异常的地方. (我们执行了0xdeadbeef, CPU会产生异常，PC会变, 由于现在还没设置异常向量表，所以跳到了一个奇怪的地址: 0xeb25134. 同时LR保存之前PC的地址: 0x60010008). 这也就是说我们的系统一开始是从 0x60010000 开始运行的?! 下一次我们来验证一下我们的猜想!]]></content>
      <tags>
        <tag>os-dev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alice OS 0-Preparation]]></title>
    <url>%2Fblog%2F2020%2F01%2F27%2Falice-0-environment%2F</url>
    <content type="text"><![CDATA[许多学习OS的小伙伴最终也只是停留在买一本翻了一半的《操作系统原理》、 一个下下来没看几眼的Linux源码，和一个甚至都没怎么跑起来过的Qemu。 关于OS最有名的课程就是MIT的6.828 Operating System Engineering课程， 课程讲解xv6，并附有一个难度颇高的JOS操作系统实验。 即使是一个专业的计算机学生、全程跟着上这门课在做这门Lab的时候也会 遇到遇到非常多的困难和阻力，操作系统本身的高难度门槛、不便的调试环境、 和狭窄的就业方向使得有兴趣的小伙伴也往往绊倒在学习的路上。 本系列博客旨在从0构建一个用于我演示各种Demo的小小小OS: Alice OS; 由于x86硬件的复杂性，为了简化，我会从arm，使用Qemu去构建Alice OS。 希望能对OS的一些概念进行一些解释，辅助小伙伴们的学习，也是对自己 在ARM的近两年开发进行一些点滴总结。若有本人理解不对的地方，欢迎指摘。 Environment首先安装我们所需的工具链和qemu: Linux: sudo apt install binutils-arm-none-eabi sudo apt install gcc-arm-none-eabi sudo apt install qemu MacOS: brew tap PX4/homebrew-px4 brew install gcc-arm-none-eabi brew install qemu 安装完后，就可以查看一下有没有: 123456789101112alice@MacAlice : ~/Codes/temp[0] % arm-none-eabi-gcc --versionarm-none-eabi-gcc (GNU Tools for Arm Embedded Processors 7-2018-q2-update) 7.3.1 20180622 (release) [ARM/embedded-7-branch revision 261907]Copyright (C) 2017 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.alice@MacAlice : ~/Codes/temp[0] % qemu-system-arm --versionQEMU emulator version 4.2.0Copyright (c) 2003-2019 Fabrice Bellard and the QEMU Project developers Manuals刚开始构建的时候，与其说是OS，不如说更像是一个bare-metal的app, 所以可以参考一下ARM上 Bare-metal的写法: Bare-metal programming for ARM https://github.com/umanovskis/baremetal-arm/ 一个模仿JOS的ARM上的OS: Arunos JOS和MIT 6.828课程相关的链接: 6.828 Operating System Engineering SJTU的ICS课程Introduction to Computer Systems 后续开发需要用的一些手册: ARM® Architecture Reference Manual ARMv7-A and ARMv7-R edition ARM® Developer Suite Version 1.2 CortexTM-A9 MPCore® Technical Reference Manual Versatile Express motherboard Address Map on QEMU 由于我们默认使用的Cortex-A9的核是ARMv7的，所以需要相关手册; QEMU模拟的Vexpress板子的文档直接看qemu的代码就行, 在编写过程中会用到一些ARM汇编，所以备一本汇编手册。 Start那么首先我们先搞个工程出来吧: Alice-OS: First Commit 这个是最开始的小工程，下一篇我们看一下Makefile和link script, 这次先说一下我们调试的方式: 进到git clone下来的代码仓，切到9d021c0这个commit之后执行 make qemu-telnet 1234567alice@MacAlice ‹ 9d021c0 › : ~/Codes/alice-os[0] % make qemu-telnetarm-none-eabi-gcc -mcpu=cortex-a9 -g -c -o kernel/startup.o kernel/startup.Sarm-none-eabi-ld -T alice.ld kernel/startup.o -o alice.elfarm-none-eabi-objcopy -O binary alice.elf alice.binarm-none-eabi-objdump -D alice.elf &gt; alice.dump.asmqemu-system-arm -M vexpress-a9 -cpu cortex-a9 -m 512M -nographic -monitor telnet:127.0.0.1:1234,server,nowait -kernel alice.bin 再开个shell, 通过telnet 连上去，并使用info registers 查看寄存器信息: 123456789101112alice@MacAlice ‹ 9d021c0 › : ~/Codes/alice-os[0] % telnet localhost 1234Trying 127.0.0.1...Connected to localhost.Escape character is &apos;^]&apos;.QEMU 4.2.0 monitor - type &apos;help&apos; for more information(qemu) info registersR00=00000233 R01=000008e0 R02=60000100 R03=00000000R04=00000000 R05=00000000 R06=00000000 R07=00000000R08=00000000 R09=00000000 R10=00000000 R11=00000000R12=00000000 R13=00000000 R14=60010008 R15=0eb25134... 可以看到 R0里面是 0x233, 这个是一开始写进去的值，至此我们非常简易的Alice OS启动啦！ 开始我推荐的调试方式就是让代码hang住，并通过qemu的monitor进行查看, 等到后面我们会改成用GDB的方式来调。]]></content>
      <tags>
        <tag>os-dev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 Summary]]></title>
    <url>%2Fblog%2F2020%2F01%2F05%2F2019-summary%2F</url>
    <content type="text"><![CDATA[2019 是没有大起大落平稳生活的一年，生活和自己当初那朴素的设想一样，没有豪运眷顾， 也没有与毕业时的憧憬产生错位。 相比去年多了一点点的沉稳，少了一点点的假想。 少了一些年初的雄心壮志，多了一些生活的苟且，却也过的更加真实和自然。 流水账 Jan. 回了趟母校，看到了实验室墙上也挂上了自己的照片，实验室里看着我的新面孔，就像我当时进入实验室时看到那些即将毕业的学长学姐们一样充满好奇。 当时的我还觉得学长学姐对新人一点也不热情，如今自己却也体会到想打招呼却连名字都不知道的尴尬。 工作紧锣密鼓的进行着，虽然刚刚完成了一波小小的攻关，然而前路漫漫，面对不知道还有多少的Bug和工作，部门兄弟们大家都心里没什么着落。 大框是博士，小框是硕士~ 公司鼓励新人的明日之星奖，奖牌做的是真不错hahaha Feb. New Year, New House 每年过年回去的时间都是可以提前一个月安排好的，就算以每天看三家的速度去逛亲戚也需要大半个春节才逛的完，现在回去的乐趣除了和长辈们的相谈，看看自己一年比一年高的外甥、侄女也是一件乐事。 2月我从公司附近搬到了地铁线上,每天上下班地铁通勤占掉了两个多小时，比以前骑车多了一个多小时， 但是地铁上的时间也能让我多一些思考、发呆、看书、玩耍的时间，未尝不是一个留给自己的机会。曾经住在单位附近，下班的我回到家里就会待在电脑前; 而如今强制给自己划出的这两个小时的时间，反倒让自己有了一段可以看新闻、看动漫、看书、思考的时间，让自己在每日繁忙的工作中能够休息一下大脑。 中间去了上海的抖音网红点星空艺术馆，没有经验的我们拿着快没电的手机赶紧拍了不少照片… Mar. 平淡的一个月，毕竟工作后没有假日就没有什么玩耍的机会，3月的我们还在适配产品的功能，除了工作就是看动漫玩游戏，平平淡淡。 LLJ夹机占在附近开了一家店，之所以去这家是因为这家的玩具做的好还是正版，关键是必然能用差不多的价格抓上来！ 只要投钱就一定能拿到的抓娃娃，比那种不靠谱的抓娃娃要快乐多了… 抓到了一只狗子，代抓的娃娃非常有弹性，从爪子上掉下去又弹到了出口里，属于快乐的白给😁 Apr. 计划了去普吉岛的旅行，其他也就没什么特别的事情了。 春天公司园区养的乌龟会经常出来晒背，忙起来的时候大家都非常羡慕悠闲的乌龟呢。 May. 5月也就在平平淡淡中度过了。 这段时间是项目的攻关期，大家都为了能满足功能而奋战，相比较去年没有刚入职的轻松自在，开始体会到社畜的心酸。 买了小黄鸭，希望能有助于Debug~ Jun. Phuket 出发！ 6月终于迎来了去普吉的日子，请了两天假和着端午出海游玩了一把~ 具体的体验已经在 普吉岛之行说过了~ 不过运气不好的是6月泰国已经进入雨季，而且同游的D桑不适应水，最终出海的体验没有想象中的好。 海风是真的咸咸的，而且粘的很… 部门组织的春游也因为攻关的原因一直拖到了6月，去了上海的崇明岛玩耍了两天，天然的空气氧吧洗刷攻关期的疲惫。 Jul. &amp; Aug. 这个月真的是平淡到连照片都没有… 在这期间度过了自己的26岁生日，在奔三的路上飞驰了… Sep. 看到了真人的汉服！确实很好看, 顺带关注了一个不错的时尚up主: 机制的党妹，在这里也安利一波：机制的党妹 Oct. 阅兵 &amp; 陪母上出游 10月最重要的国事就是建国70周年大阅兵，听着钢铁洪流进行曲，看着先进的武器装备让非军迷的我也热泪盈眶。十一长假母亲大人莅临指导，父亲大人也不远万里从苏州赶来， 一同去了西溪湿地。不得不说，还是母上大人厉害，走一天路我们两个大老爷们都走不动嚷嚷着要坐船，母亲大人步履轻盈还意犹未尽… 看来自己还需锻炼… Nov. 买买买 今年算是学习了一波薅羊毛攻略，从前期的卖楼和互换盖楼，到每天抢秒杀，到前一天做Excel攻略表，最后10号晚上奋战到凌晨…… Pad、Mac、手机无一不用, 我第一次如此用心的过了一回双11， 真是身心俱疲…同时也无比佩服那些羊毛党们在双11这件事情上的强大战斗力。 每天盖楼奋战是日常了， 以后再也不想参加了… Dec. 年末攻关 整个年末就没怎么休息，产品性能攻关，所有的大佬亲临一线，都在一起Debug、采数据做性能分析优化，跟我们一起联调的别部门小姐姐，每天工作到凌晨3、4点…… 也再次见证了华为这个公司在面对目标打攻坚战时的强大，即使是为了一同奋战的同事们，自己也要尽己所能贡献一份力。 双12又买了扫地机器人，用过之后立即种草，这东东真的是解放生产力、提高幸福感，推荐推荐。 Note2019年有很多目标没有完成，与其说是没有践行目标，其实是生活工作进入常态之后不得不对年初的诸多奢望进行一些裁剪， 以保证自己的精力能够更多投入生活与工作。 记录每天的花销由于过于琐碎而被抛弃了，曾经记录了两个月最终发现自己实际上也不关心它具体是多少，一日三餐在公司吃饭，周末也就吃两顿好的。剩下的钱也只有双11、618这种大节和过年回去花一花了，在日常工作已经占据大脑，每日恨不得倒头就睡的日子里，又能有多少精力去记录这连自己都不关系的每日开销呢？反倒是De了多少bug、完成了多少需求、每周工作的内容倒是老老实实的记了下来，或许这才是社畜该有的样子吧… 锻炼没有完成预定的次数，不过也陆陆续续有在坚持，就是游泳改成了方便的跑步，从目标美型转到了纯为续命上… 英语、日语都被抛到了脑后，只保持了最基本的说写和专业阅读能力，在使用率越来越低的现在拓宽阅读是目前优先级更高的事情了。 画 画…真的是惭愧，深刻意识到忙起来后就没时间顾及业余爱好的无奈，何况自己有空还要看综艺、看动漫、玩游戏、写博客，画画就真的是被撂到一边了，连自己都有点懊恼… 游泳/健身 70+ -&gt; 30+ 读5本专业以外的书，这一年读了有十几本，这个目标还是达成了的 拔草日记 -&gt; 忙了起来后还哪来的拔草呢😔 画至少四幅插画… 日语/英语单词的学习… 记录每天开销-&gt;记录每周工作的内容 2020年还是希望能动两笔，写两句，读读书，看看番，锻锻炼，赚赚钱~ 健身 50+ 读10本专业以外的书 画4副插画 写5篇技术博客(博客是一个自己总结的好机会) 开开心心 2020年加油！]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泰国的明珠——普吉岛之行]]></title>
    <url>%2Fblog%2F2019%2F08%2F04%2Fphukey-trip%2F</url>
    <content type="text"><![CDATA[明媚的阳光下，伴着尖叫与欢笑，玩拖曳伞的游客们像大鸟追逐快艇一样在空中翱翔； 在这一望无际的蓝色背景上，云彩像泼墨艺术般层层洒在这蓝色的画布上， 碧绿的丘陵在翡翠色的海水上划出了一个个海湾，白色的小浪花则跨过这巨大的海湾， 轻轻地拍在海滩上细密的沙子上，尽全力一次次尝试浸湿更远处的沙子， 不过无情的艳阳则让这绵薄的努力顷刻间化作了虚无。 海里是嬉水的孩子们，海滩上则是忙于凹各种造型摆拍的大人们， 每拍个十几分钟，都会筋疲力尽地躲在各种小店摆出来的遮阳伞中。 而女孩们则无暇休息，趁着这拍照的间隙疯狂给自己身上涂防晒。 紧靠沙滩的小路上则是陆陆续续过来的游客，而小路的边上则是各种拾趣、小食与药店，当然还少不了想着歌声与音乐的海边餐厅~ 普吉是泰国的明星景点，而普吉岛的巴东地区则是普吉最最热闹与繁华地段，巴东海滩亦成为了游客们的打卡必经之地， 虽筋疲力尽，但也不会忘记这夏日海滩的美丽。 对国人友好的旅游胜地随着我国经济的发展，以往国内的旅游计划也渐渐将目的地改为了周边的国家， 泰国则成为了东南亚最受国人欢迎的旅游国之一。 平易近人的消费承担的起的消费水平是最主要的原因， 在国内，面对五花八门的商店中琳琅满目的商品， 不提前查一下指不定就会出现逛了半天满面红光，一问价格一脸羞涩的窘地。 而在泰国，你就像是带着大金链子，叼着雪茄，穿着豹纹夹克，留着莫西干头似的土老大， 想买什么买什么，想逛什么逛什么，积攒了一辈子的穷的忧伤，都可以随着撒钱的畅快而烟消云散。 想做Spa? 哪里贵去哪里；想吃海鲜？哪里豪华吃哪里！ 我和D桑就去了网红店Let’s Relax最火的第三街道分店，点了3个小时的“天堂般的享受”，全身放松按摩! 全世界都在说中文英语还过得去的我对出国旅行一向是不怵的，曾经单人飞德国转维也纳都经历过了， 区区泰国还不是小Case? 当我想着秀一把时，眼之所见、耳之所闻则令我震惊不已， 当地人的汉语感觉和英语一样好，周围都是说着中文的服务人员。 从曼谷到普吉，从普吉到巴东，从巴东到皇帝珊瑚岛，最后返程的过程中， 英语几乎没有用过。机场的客服、宾馆的前台、餐厅的菜单、商城的指引， 等带有中文翻译，甚至连出海时船上的泰国导游也操着一口流利的中文给我们介绍游玩的路线。 在这里，无法提供中文服务就意味着拒绝巨大的商机， 作为游客的我们则不必担心沟通问题，畅玩普吉。 万能的阿里帝国出国游繁琐的地方之一在于办理签证，对于像美帝这种又是面签又是check的根本就是在拒绝普通百姓， 我们这时段泰国虽说时落地签，但茫茫长的队伍也令人望而止步。 但是万能的淘宝A梦则可以解决一切烦恼，从签证办理到宾馆机票这种常见服务， 到出海游玩项目、免税店接送这种细致日程都可以在淘宝/飞猪上一条龙订完。 而到了当地也不用带现金，支付宝同样走天下， 阿里再一次展示了它帝国的威势，在一遍遍被掏空钱包的同时也一遍遍说着真香。 价格比当地使用的打车软件Grab的费用还低，游玩项目则更是现场价格的一半。 快乐的小岛到达素万那普机场时恰逢阵雨，吃着汉堡的我们看着窗外的焕发盎然生机的热带植物吮吸着夏日的甘露， 心中充满的对热带小岛的各种美妙想象。 到达普吉机场后，接机的当地司机已经在一辆小轿车内等着我和D桑， 司机是位大姐，虽然不会中文但也熟练地使用Google翻译给我们介绍路况， 淡黄的灯光与舒缓的音乐让因旅途奔波的我们可以在车上小憩片刻。 两车道的山路潘延30多公里，只有像大姐这样的本地老司机才能驾轻就熟， 我则在心中默默摁灭了想要自己租摩托兜风的小火苗。 当司机叫我们向西边观看时，已是到达巴东海滩的时候了， 夜晚的海漆黑而神秘，海边的灯光则宣扬着小镇夜生活的开始。 出海若是天气晴朗，幸运的游客可以在平稳的帆船上喝着冰镇汽水，一遍听着扬声器里的音乐，一边冲向美丽的海岛， 还可以在海上浮潜，甚至邂逅精灵般美丽的海豚。不过如果像我们此次行程一般不走运， 遇到了阴雨天的话那海上的航行就更像是探险了。 稍起风，海浪就会让船上下颠簸，没有一个常年行走在陆地上的游客能够经受住着长时间的颠簸， 凡是不吃晕船药的都会埋在呕吐袋上…… 好在到达海岛的时候雨没下，得以玩一下丛林穿越。 当划扣挂在钢绳上时，心里咚咚的心跳对即将到来的滑行既期待又有点害怕， 这种肾上腺素溢上来的感觉着实让人欲罢不能。 当我们踏上寻找海豚之旅时，大海似乎非常的不乐意，在变大的风浪和颠簸的船上， 包含我们在内的所有旅游都嚷嚷着赶紧回去。 为了生命安全，也为了晕乎乎的脑袋，帆船掉头向着出发时的港口缓缓驶回。 SPA &amp; Massage幽暗的房间中飘逸着令人愉悦的芳香，悠长的音乐抚摸着因一天旅途而疲惫的心， 按摩师用专业的手法揉捏着小腿酸痛的肌肉，每一次用力都仿佛能感到藏在肌肉中的乳酸被一点点挤出来， 一声声酸痛的嗷之后是舒畅的啊~ SPA &amp; Massage已经成为了泰国旅游的必备活动， 项目从理疗到解压，从适合新人的精油按摩到资深人士才敢挑战的泰式四手， 泰式按摩是必须要体验的。 价格从每小时几十RMB到几百RMB不等，如此看来作为按摩师的收入相比也不会太多。 海鲜盛宴无论哪里的泰式餐馆都会有招牌的冬阴功， 各种贝蚌与虾蟹在泰式餐馆都是必备。 在泰国，物美价廉的海鲜应有尽有， 在国内高档日料店才能享受到的大龙虾，在泰国也不过是几十块RMB的弟弟。 如果着实不适应泰式的味道， 为国人口味改良的菜品也不在少数。 若是吃了太多的海鲜想要换换口味， 街边小摊的各种轻食也非常不错。 来了泰国，只要注意不要因为吃海鲜吃进医院就可以了O(∩_∩)O 旅游攻略 签证建议提前办好，淘宝包邮包照片7天内只要200多RMB，省心又省时； 机票: 越早订越好，直飞普吉是没有黄金航班的，想坐黄金时间就需要从曼谷转；廉价航班不一定有行李额，订机票时买； SPA&amp;Massage: 网上提前个3天订好，不是所有的店当场就有位置； 接送机、出海、游玩项目：全部淘宝订，我们订的浪花朵朵那家的，还不错；接送机提前一周能便宜，出海早一些比较保险，旺季不一定有足够位置，游玩项目提前一天订就行，便宜不少； 宾馆: 淡季就选好一点的，也不是很贵一晚上一人300左右，旺季就酌情；我们选的Burasari Phuket，酒店的SPA听说比Let’s Relax的还好，露天泳池+餐厅非常不错； 插座：2孔和国内一样，三孔的需要带转换头，而且宾馆不一定有，当然周围都是7-11, 可以方便买到； 泳衣2套+: 宾馆都是露天泳池，出海、海滩都需要泳衣，一套一般不够换； 沙滩衣与沙滩大毛巾: 雨天保暖(雨天出海非常冷)，晴天防晒(化学防晒都是没用的，必须物理防晒)； 防晒：防晒霜防晒喷雾都带上，晴天的话要仔细涂抹各个部位，一不注意就是晒伤； 防蚊虫：泰国多蚊虫，当地7-11有买绿药膏很好用； 浮潜袜：浮潜、沙滩出海必备，脚踩沙滩都是电视剧里演的，不想被划伤隔住老老实实带上； 浮潜咬嘴：这个攻略一般不说，但是对于初次浮潜的人可能会不喜欢他们给的咬嘴，如果自己带个习惯的会舒服很多； 充电器、夏天的衣服、墨镜等等，当地非常多7-11，需要什么可以直接买，支持支付宝 行程 我们第一天去出海，出海回来会非常累，而且身上都是海水想要洗澡， 不建议当天晚上再安排SPA等活动，而且回来的时间不确定，晚上逛逛海滩夜市或者休息就行； 第二天我们逛的王权免税店和普吉镇，王权免税店不如机场日尚的便宜， 只有欧莱雅的价格还行，其他的就是宰客，所以我们吃了免费的自助后就去普吉镇玩了。 网上会有很多免费接送王权还送自助的，可以参加，免费送过去后可以逛逛，没什么想买的话吃完自助就可以自己去普吉镇， 逛整个普吉镇差不多要1-2小时，逛完后可以回到王权再免费被送回宾馆…… 我们是取消了返程接送，在普吉镇自己打车回的， 差不多要快100RMB； 巴东海滩可以租摩托，不过那边骑的飞快，只逛一个海滩的话步行即可，推荐白天逛，晚上去SPA； 出海如果时间充裕可以选择在海岛上住或者出两次海(出一次后其实就不想再出海了)，时间还充裕可以选择再逛逛其他海滩； 当地晚上有泰拳与人妖表演，还有各种露天酒吧，不过我们没什么兴趣就没安排； 曼谷转机的话，除非在曼谷过夜，不然没有时间逛，市内景点距离机场都是10+~20+公里； End这次出国旅行，大体上非常顺利，除了中间我脑抽12点退房，下午15：30才订的送机害的我们在酷暑下怏了几个小时外， 其他行程还算不错。游玩时间有限所以安排不是特别多，不过哪怕是天天Massage也是很不错的！只能等到下次去其他东南亚岛国再体验一次了。]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用免费的亚马逊云服务(AWS)]]></title>
    <url>%2Fblog%2F2019%2F03%2F03%2Faws%2F</url>
    <content type="text"><![CDATA[之前一直使用的搬瓦工: https://bandwagonhost.com/, 使用上感觉还不错，但是当vps IPf被封了之后， 需要等待180天才能更换一次IP。 而且其速度并没有非常的快(当然也是因为买的是最便宜的19$/year的套餐)。 听闻Amazon的云服务AWS(Amazon Web Service)可以试用，第一年免费，今天便拿来尝试了一把。 本篇记录了使用Amazon的服务建立一个自用VPS的过程。 Preparation 信用卡一张(国内的银联就可以) 一个可用的Email账户 虽然是免费的，然是要求绑定一张信用卡，当我们使用量超出免费服务的限制后它会从信用卡上按月扣钱。 Apply a Instance/Virtual Machine (VM) 进入AWS官网: http://aws.amazon.com/ 右上角-&gt; Create an AWS Account Sign up注册一个新账号 (如果已有账号Sign In)，跳过注册 需要注意的是信用卡绑定国内的信用卡就可以了，我试着绑Visa还失败了.. 密码需要还有大写字母和数字/符号 登陆进去后进入的就是我们的控制台界面: https://console.aws.amazon.com/console/home 右上角分别是通知、账户、区域、和支持(Support)，在区域里面选择自己服务器想要申请的区域。 听说国内用Tokyo东京的比较快。 在页面中Build a solution中选择Launch a virtual machine 在给出的选项里面，找一个带有Free tier eligible的就行,常见的几个: Amazon Linux 2 AMI(HVM): 属于Selinux, 使用Yum包管理器，只安装了最基本的工具 Amazon Linux AMI: 还安装了常用工具: python, perl, Java, Ruby, Docker, MySQL等等 Microsoft Windows Server 2019 Base: Windows的直接跳过不看 Red Hat Enterprise Linux 7.6: Red Hat的企业Linux Ubuntu Server 18.04 LTS (HVM): Ubuntu, 使用apt包管理器 如果是习惯了使用Ubuntu的，装Ubuntu Server这个就行；如果仅仅只是想弄个代理服务器什么的， 考虑到我们的VM空间也不大，可以像我一样申个最简单的Amazon Linux 2 AMI。(2023年Amazon出了新的AMI, 可以用新的) 这几个VM类型除了Windows家的, 都是HVM类型(全虚拟化), 所以使用上没什么差别。这里我们选第一个Amazon Linux 2 AMI(HVM) 选择instance type 在给出的免费选项里面，只有t2.micro, 1个vcpu, 1GB内存，Low to Moderate的网络能选了… 选择配置 大部分用户可以直接选择右下角的Review and Launch，如果想修改详细配置，在最上方的选项卡里面可以选。 需要注意的是，Add Storage里面，免费的磁盘最大可以选到30GB的SSD，默认是8GB。 在Configure Security Group选项卡里，可以给我们的安全策略组起个容易理解的名字。 Generate Key Pair 熟悉ssh Key使用的也可以跳过这一步，如果跳过这一步那在服务器端没配置好authorized_keys之前就不能通过ssh访问了 之后就可以点Launch来启动我们的VM了。这个时候会弹出一个配置Key Pair的页面，这个页面只会出现一次。 我们选择Create a new key pair来生成一组新的RSA密钥组。其中的公钥会被放到我们的VM里， 私钥我们要下载下来保存起来之后用ssh连接VM的时候使用。Key Pair的名字随便起。 点击Download Key Pair下载私钥文件，这个可别弄丢了哦, 在.ssh/config里面指定为这个密钥就可以了, 具体的可以在Aws Instances 那边点Connect，照着ssh的方式配置就可以。 Launch VM 点击Launch (Instances/VM)后，我们的VM就会启动了。启动后我们可以选择最上面的菜单Services-&gt;EC2进入 EC2 Dashboard: 当我们看到有一个Running Instances时，说明我们的VM启动成功了。 Configure VM 这里我们看到右上角的Tokyo表明了当前的DashBoard显示的是哪个区域的VM, 如果我们继续Launch Instance的话， 还会在相同的区域中起VM。如果我们在右上角切换了Region, 那么我们就可以在其他区域中起VM。 常用的选项我已经用红框标记了出来: Instances: 里面会显示我们启动的VM的状况 Security Group: 显示我们的安全策略组，这个会有一个默认的策略，我们在配置VM时设置的安全策略会作为一个新的Group。 Elastic IP: 这个允许我们的VM对外显示为另一个IP, 可以在我们的IP被封后换掉。 Key Pairs: 显示了我们目前设置的Key, 如果我们之后想换密钥了可以在这里操作。 Associate Elastic IP 这里我们选择Elastic IP选项卡，点击左上角的Allocate new address分配一个IP, 分配好了后在旁边的Actions里面选择Associate Address。 在新的页面里面选择我们的Instance, Private IP不要动(Private IP)是我们VM真正的IP。 勾上Allow Elastic IP to be reassociated if already attached，然后点Associate。 再回到Elastic IP选项卡，就能看到我们刚刚申请的IP已经和Instance关联了， 之后就可以通过这个Elastic IP来访问我们的VM。 Configure Security Group 选择Security Groups选项卡，点击我们自己的Security Group, 最下面会显示Description, Inbound, Outbound, Tags。我们需要修改Inbound的安全策略: Inbound默认只允许ssh协议的链接通过22号端口访问我们的VM，如果我们想用它作为代理服务器的话， 还需要添加一个规则, 比如我想用shadowsocks, shadowsocks的链接用的TCP协议: Edit, 选择Custom TCP Rule, Port Range 我填一个22334, Source 选择Anywhere。 这样我们的VM就允许来自任何地方，连接Port 22334的TCP协议包。 这些都弄完了后，我们的VM就可以开始使用了。 Setup Proxy Server这里简单介绍一下如何搭代理服务(以Shadowsocks为例)。 Connect to Instance 选择Instances选项卡，在上方有Launch Instance, Connect, Actions。 我们点击Connect，它会告诉我们如何访问我们的VM。最简单的方式就是用ssh， 里面会直接给一个Example: 1ssh -i "keypair.pem" ec2-user@xxxxxx.compute.amazonaws.com 找一个shell照着敲就OK. 123456789101112131415161718192021222324252627282930$uname -aLinux ip-xxx-xxx-xxx-xxx.ap-northeast-1.compute.internal 4.14.97-90.72.amzn2.x86_64 #1 SMP Tue Feb 5 20:46:19 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux$lscpuArchitecture: x86_64CPU op-mode(s): 32-bit, 64-bitByte Order: Little EndianCPU(s): 1On-line CPU(s) list: 0Thread(s) per core: 1Core(s) per socket: 1Socket(s): 1NUMA node(s): 1Vendor ID: GenuineIntelCPU family: 6Model: 63Model name: Intel(R) Xeon(R) CPU E5-2676 v3 @ 2.40GHzStepping: 2CPU MHz: 2400.224BogoMIPS: 4800.04Hypervisor vendor: XenVirtualization type: fullL1d cache: 32KL1i cache: 32KL2 cache: 256KL3 cache: 30720KNUMA node0 CPU(s): 0Flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx rdtscp lm constant_tsc rep_good nopl xtopology cpuid pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm cpuid_fault invpcid_single pti fsgsbase bmi1 avx2 smep bmi2 erms invpcid xsaveopt 可以看到亚马逊的AWS用的是基于Xen的虚拟机监控器，Virtualization type:full, 表明我们是全虚拟化。 Install ssserver 简单瞄两眼后，我们就着手安装自己要的工具吧。 123$ sudo yum install m2crypto python-setuptools$ sudo easy_install pip$ sudo pip install shadowsocks 这里pip可能因为更新导致Amazon的pip版本过老出现错误，我们重新装一个就行~: 12$ sudo yum install python37$ sudo pip3 install shadowsocks 这样我们就安好了shadowsocks服务。建立一个配置文件: 123456789101112sudo vi /etc/shadowsocks.json# Write following contents&#123;"server":"0.0.0.0","server_port":22334,"password":"your_passwd","timeout":300,"method":"aes-256-cfb","fast_open":true&#125; 里面password是连接代理服务时需要输入的密码。里面的server_port记得和 我们AWS上Security Group里面Inbound配置的内容一致，不然会被AWS拦截下来。 启动shadowsocks server 1234sudo ssserver -c /etc/shadowsocks.json -d start# Stop service: sudo ssserver -d stop# Restart service: sudo ssserver -c /etc/shadowsocks.json -d restart# View logs: less /var/log/shadowsocks.log 设置我们的IP table, 不要屏蔽掉22334的包: 1sudo iptables -I INPUT -p tcp --dport 22334 -j ACCEPT 大功造成，剩下的就是常规操作了(Client端的就省略了，相信看到这里的你不可能不会用的) Install V2rayV2ray的使用参考: http://silentming.net/blog/2023/03/25/v2ray Delete Instance如果需要删掉Instane, 需要Terminate Instance, 并解除与释放Elastic IP，处于Terminated状态的Instance经过一段时间就会被Amazon回收 End代理服务有很多种，比如我之前介绍过的cntlm也可以用，shadowsocks的好处是对包进行了加密, 你可以用自己设计的协议= =。 AWS的Free Tier一个月的上下行流量总和为15GB, 超了会扣钱钱，可以在左上方Services-&gt;CloudWatch 里面看看Bill相关的统计，也可以研究下怎么设置Budgets, 在用超的时候发警告。 使用使用上，感觉连接速度比搬瓦工的更快一些，但是流量上限就没有那么高了， 而且一个月15GB的流量限制也确实不能干太多事情。 不过能看出来AWS的易用性非常的高，无论是后续切换Region, 还是更换Key Pair、换IP等等， 在EC2 Dashboard上面非常显眼的就列出了所有的常用功能。再一次深刻意识到Amazon作为公有云领域的老大， 其技术能力的深厚与用户体验的优化都铸就了它现在巨大的成功。 Note 20230325: Update Delete Instance 20210405: Update V2ray configuration]]></content>
      <tags>
        <tag>tutorial</tag>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上海迪士尼初探]]></title>
    <url>%2Fblog%2F2019%2F01%2F30%2Fdisney-land%2F</url>
    <content type="text"><![CDATA[来到上海之后一直没有什么契机让我这个深度宅去一趟童话般的迪士尼， 不过全能的D桑竟然能买到打折票， 也促成了这次的童话世界游园之旅。 作一篇小记希望能帮助到同样想去迪士尼的小伙伴们~ 准备工作 下载”迪士尼度假区App” 这个App可以直接买票，不过如果想买打折票之类的，那就找一些第三方的渠道买就可以了~ 这个App是必备的，因为需要用它来看每个项目的等待时间以及领免排队的Fast Pass。 携带物品 如果是小孩的，需要注意下里面不能带自己的推车，会提供统一的推车租赁，长伞好像也不可以， 安检的时候会搜包，也不允许自己带吃的；最简单的就是带好手机、身份证和水杯就可以了， 饮水点非常多，不用担心。 饮食 园区内有餐厅，不过旁边的迪士尼小镇有丰富多样价格合理的餐厅，当天的票可以凭票多次入园， 所以可以规划好路线去迪士尼小镇就餐；我们由于不知道，中午的时候看到迪士尼小镇在出口外面， 最后还绕了远路在宝藏湾附近吃的不好吃还非常贵的快餐… 交通 地铁11号线是直达的，而且出口距离园区不是很远。需要注意的是，如果晚上回来的时候， 地铁的人会非常的多！因此晚上不要卡点去做最后一班地铁。 自驾的话停车场好像有很多，收费在网上查了下，13:00以前是100，以后是30。 攻略 提前做攻略是必要的，看这篇的你可真是个小机灵鬼~ 地图 在园区内请使用官方的APP来导航，因为上面有每个项目的等待时间提示。 从地图上可以看出来，迪士尼乐园被分为了几个大的板块：奇想花园、探险岛、宝藏湾、梦幻世界、明日世界, 每个板块都有标志性的项目，游玩顺序可以自定，我和D桑的游玩顺序可以提供个参考。 入口入口在地图右下角，这里排队请提早来。假设园区是8点开门，那么7:20左右就会开始放人过安检， 过了安检才能开始领票和领Fast Pass, 因此不要想着8点开门7:30到就OK了。 我们去玩的时候，早上9：00开门，我们8点多到，从地铁站走过去开始排长长的安检队， 由于是周内工作日，人已经少很多了，节假日简直不敢想。即使是这样，我们进园区的时候也已经超过9点了。 不过相对的，玩一整天非常消耗精力，我和D桑最后选择不看夜间的烟花..实在是太累了， 来的早也就更累，怎么就看各位小伙伴怎么权衡了。 过了安检的门之后，直走50m就可以领票，领了票就立刻在app上绑定，然后领Fast Pass, 一些火爆的项目会在每个时间段分配一些FP的票额，选择领的话就需要在规定的时间段去游玩才可以， 一个FP没有使用完之前是不能领第二个的，而FP本身的领取资格也是两个小时一次。 推荐领FP的一些景点我会放到下面一起介绍~ 探险岛想必大家都非常熟悉人猿泰山了，热带雨林的潮湿配上仿佛部落中的鼓声，鸟儿的欢叫，猴子的嬉闹…… 纵然这些只是从扩音器传出来的声音，但闭上眼，自己仿佛真的进入了充满冒险的岛屿森林中； 睁开眼，两边是慑人的图腾，怀着期待的心情，我和D桑首先踏入了探险岛…… 翱翔飞越地平线 (FP)这个确实是迪士尼标志性的项目之一，所以很多攻略上会推荐先领这个项目的FP, 然后去游玩其他项目。 我们实际体验来看，如果你去的比较早，这个项目可以直接排队，差不多只要20min (高峰的话要90min+)， 而FP可以领其他的。 里面是个穹形屏幕，沉浸式的带你飞跃五大洲，幸运的话最后能坐第一排(排队的时候在这一批靠前一些), 因为后排的会看到上面人的鞋底…影响观影体验。个人感觉非常适合初中、高中的少年们， 对于我们这种成年人，更像是看一部沉浸式电影，震撼或许没有那么强。 (这个沉浸式体验非常强，有恐高的话不建议看(当然你可以闭眼)), 身高限制102cm 雷鸣山漂流 (FP)这个很不幸的是我们去的时候在维护，所以没能玩上，不过如果选择FP的话可以选择领这个项目或翱翔飞越地平线 其中之一，然后自己排队玩另一个。 传言橡皮艇会在水里撞击，身高限制107cm, 提前在淘宝上买个一次性雨衣会比较好，没有玩成不做评论， 不过能玩还是要玩一下的。 古迹探索营这个想玩随时去玩，主要是给小朋友玩的，一些木头做的装置，玩过一些吊桥、独木桥、高空桥之类的对这个也不会有 太大兴趣，还有一些沙坑供小朋友玩耍，我们没去玩。 宝藏湾“我是杰克船长。独此一家，如假包换。”我们现在踏入的无疑是伟大的杰克船长的领地，这里有沉船、 有宝藏、有海怪与海战，当然，还有最擅长享受的海盗们了。 不知跟随杰克船长的你们是否能唤起自己对金钱、名声与势力的渴望， 毕竟，我可是要成为海贼王的男人 (的粉丝) 加勒比海盗——沉落宝藏之战这个让我非常震撼，可能是我见识少，会坐一个船型的轨道车，在水里航行，旁边是杰克船长的一些主题机关， 中间还有一些穹形屏幕的沉浸式影片，真正体验身临其境的海战，是我为数不多想要再去游玩的项目之一； 需要注意一点，这个项目的处理速度很快，所以不必一上去就去排队，我们当天这个项目从来没有要求30min以上的排队时间。 这个项目小孩子可能会被吓到，所以还是要注意一些。 其余项目其余项目从游玩体验上都比较无聊，不过里面有很多照相、探险这种不那么有紧张感的项目。 以及这里有快餐午饭，所以路线可以规划到中午过去，在那里吃个饭什么的。 梦幻世界抛下面具，收起欲望，这里是童话的世界，这里是梦的回廊； 在这里你可以看到白雪公主与女巫、小熊维尼与美人鱼、爱丽丝的仙境，小矮人的矿洞， 在这里你会找到儿时听童话时的惊叹与欢笑， 见到从小就向往的公主与城堡。 这里时北方的乐园——梦幻世界。 七个小矮人矿山车(FP)喜欢可爱事物的请一定不要错过这个项目，这个项目最好领一个FP， 矿山车本身不会像过山车那么可怕，而且里面的场景非常梦幻， 奈何一辆车一次只能坐8个人(没记错的话), 导致该项目的排队时间一直都很长。 坐着小矮人的小矿车，感受矿工(误)挖宝石的日常~ 小飞侠天空奇遇(FP)乘着飞腾的马车，飞跃各种童话故事中的场景。这个项目每次打开一扇门就真的有一种进入童话世界的感觉， 虽然整体时间比较短，但是D桑评价甚高~ 小熊维尼历险记(FP)这个项目我们没能去成，去的时候在维护，一直到下午才开放，但是刚开放的时候我们在岛的南边， 走过去的时候已经要排1个多小时的队了，索性放弃。 下次再来玩的话是准备过来体验一下的，毕竟这么火爆呢。 迎宾阁注意，这里仅仅是和白雪公主合影！如果想去城堡游玩的话直接从旁边过去就可以， 不需要在这里排长队。 城堡&amp;漫游童话时光这个是在城堡内部，会讲述一些白雪公主的故事， 这个项目比较冗长，而且要爬楼梯，在冗长的故事结束以前还无法提前离开； 适合的是喜欢童话故事的孩子，我呢就是复习了一下白雪公主的故事。 晶彩奇航这个项目会坐一艘船，跟随一只蜻蜓来游览童话中的经典场景。这个项目排队情况不一定， 一阵一阵，而且晚上会有灯光，所以白天晚上景色差别很大，推荐白天晚上各来一遍。 如果人多的话就先玩别的项目之后再来排就好~ 其他项目其他项目相比宝藏湾仍旧出彩，如果是带小朋友过来的话这边的项目都可以玩一遍， 大龄青年的我们则跳到了后面更刺激的项目去了。 明日世界充满科技感的银白色环行坡道在阳光的照射下，亮闪闪的光在四周飘散的水雾中闪烁着， 招牌的创极速光轮轨道横跨在这些环形坡道上，一辆辆映射着幽幽蓝光的摩托在 轨道上疾驰，划过空气的尖啸声、游客们的喊叫声和扩音器中的奇幻配乐一起， 无一不在将版区上的游客吸入一个异次元的世界。 创极速光轮(FP)作为明日世界的招牌项目，对于玩不来过山车的人来说，实属可惜。该项目推荐使用FP, 队伍不算太慢，但是排挺久的队玩一次也不过2min. 不过就像骑哈雷摩托就是比开四轮的跑车拉风一样， 创极速光轮的摩托设计更能带给游客飞驰的感觉。 巴斯光年星际营救(FP)这个项目其实挺无聊的，就是坐在一个可以360度旋转的小车上那个激光枪打靶。 如果喜欢玩具总动员里巴斯光年的来这里倒是比较适合， 这也是为什么这个项目虽然属于(FP)但基本上没什么人排队的原因。 喷气背包飞行器这个项目排队非常长，由于一次好像只能两个人玩，而且也没有FP，所以我们没有参加这个项目。 跟弹射座椅一样，而且可以自己控制高度。阁下何不背包起，扶摇直上九万里？ 创界：雪佛兰数字挑战这个里面有很多交互式的游戏，算是个小游戏厅了吧。而且不需要排队，在未来世界逛的时候可以进去 转一转玩一玩。 其他项目其他项目依旧是粉丝向or儿童项的，比如这里有大白的表演、有乐高的积木室，有《星球大战》中的千年隼号驾驶舱…… 我们兴趣不是特别浓厚，就没继续转了。 值得一提的是，明日世界出来就是迪士尼小镇，所以在路线安排上可以把它放到中午，要么转完去吃午餐， 要么吃完午餐来这里玩。 奇想花园如果说梦幻世界是童话的乐园，奇想花园就像小朋友的乐园；这里的娱乐设施都是面向小朋友的， 旋转木马、小飞象…… 不过看着这些场景，让我不由得想起来尼尔·机械纪元里的游乐园， 米奇童话系列演出这个算是白天的重头戏了，在游玩之前一定要先看好这个表演的时间，等到表演快开始的时候去米奇大街这里 找一个好位置。能看到迪士尼的经典动画人物随着 我们一起快乐无边 我们一起亲密无间 我们陪在彼此身边 我只想大声对你说 多么美好的一天 音乐向你招手。无论此刻的你多么匹配，也都会被他们的微笑和热情所治愈。一定要看的节目！ 烟花表演这个也算是招牌了，看好烟花表演的时间，如果转累了可以提前去占座；毕竟可是有人下午17:00就开始坐在那边等烟花了… 我们因为太累了，所以将这个作为下次的游玩项目之一。如果精力充沛或者时间紧迫的话，这个项目可以纳入游玩列表中。 游玩顺序A. 进门直走拿票-&gt;向探险岛出发(同时绑定票拿FP) -&gt; 拿雷鸣山漂流/飞跃地平线的FP, 然后玩飞跃地平线/雷鸣山漂流 -&gt; 加勒比海盗沉落宝藏之战 -&gt; 第一个FP的时间应该到了,去玩雷鸣山漂流/飞跃地平线 -&gt; 此时的时间应该是快中午， 拿七个小矮人矿山车/维尼小熊历险记的FP -&gt; 然后去未来世界排创极速光轮or火箭背包, FP的时间应该已经到下午了 -&gt; 玩了创极速光轮后，可以根据时间在未来世界再转转 -&gt; 随后去迪士尼小镇吃饭 -&gt; 吃完饭在米奇大街说不定能看到上海迪士尼乐团的表演 -&gt; 饭后回来看一下米奇童话系列的演出时间 -&gt; 可以继续玩未来世界剩下的项目等游行 -&gt; 游行时间到了后去米奇大街看游行 -&gt; 去梦幻世界玩FP的项目以及其他项目。 梦幻世界的项目内容比较多，几个FP、城堡、晶彩奇航都是值得一玩的，而且还有冰雪奇缘的表演——《冰雪奇缘：欢唱盛会》可以看，所以比较适合放到时间安排不固定的下午， 可以随时加减。玩的差不多了走奇想花园转转然后去迪士尼小镇吃晚饭。晚饭后可以选择去找烟花的座位，或者就直接在迪士尼小镇逛逛， 结束后就可以撤了。 B. 也可以进门就去未来世界玩创极速光轮，不过FP还是拿探险岛的吧，目前看下来还是飞跃地平线的队伍总是最长；这样的话未来世界就只玩创极速光轮， 然后就去探险岛玩漂流和地平线，随后去宝藏湾玩沉落宝藏之战；午饭可以选择在宝藏湾or探险岛的园内餐厅就餐；下午去梦幻世界和奇想花园继续玩， 这样是可以在中午的时间看宝藏湾的表演——《杰克船长之惊天特技大冒险》，这个表演质量十分不错，推荐一看；下午还可以去探险岛看《人猿泰山：丛林的呼唤》 End迪士尼的一天不光是自身体力的考验，也考验精力。大部分的时间都是在排队和走路，和朋友一起要考虑如何安排这些冗长而无趣的时间，和小朋友or老人一起的 要考虑他们的体力是否能承受像我们那样过于紧凑的游玩安排。纵然项目质量上乘，也耐不住人海的拥挤熙攘；所以如果不想自己此程大部分时间耗在无意义的排队、 犹豫的决策和无休止的尴尬或争吵中的话，去之前请做好计划、攻略和身心准备。 我几乎不看迪士尼的片子，在去之前甚至不觉得迪士尼对我的吸引力能超过游戏的折扣、漫展的本子；我也去玩过一些像广州长隆欢乐世界这种比较大的游乐场； 不过对于我这个没有去过香港、日本迪士尼的人来说，此番游玩依旧令我觉得十分震撼。我终于理解了小时候表姐从东京迪士尼回来后告诉我： “你无法想象那里的人在炎热的夏天，穿着布偶装还能如此的热情和敬业，园区的卫生是那么的干净！”时的激动了，彼时的我还认为是日本服务业人员职业精神强， 游客民众的个人素质高。而当我从上海迪士尼回来后，我也同样能够说”你无法想象在那么忙碌的一天后，穿着布偶装的工作人员还能露出让你瞬间忘掉疲惫的可人笑容； 你无法想象在经过每日如此多游客的洗礼后，园区的卫生和环境依旧那么整洁和清新；你无法想象当现代科技和这些刺激感官的项目结合起来后，那沉浸式的体验让人是多么的难忘！”]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 追番总结]]></title>
    <url>%2Fblog%2F2019%2F01%2F15%2F2018-acg-summary%2F</url>
    <content type="text"><![CDATA[不得不说工作之后看动画的时间就少了许多，一方面是时间的原因，也有一方面是是因为为了赶时间许多动画出了后就直接补漫画了… 不过总的来说2018的动画仍然有不少精品(紫罗兰万岁)。 给有兴趣补2018番的小伙伴提供一些参考, 也给自己一个小小的总结。 (由于百度云盘在Mac上的同步功能去掉了，所以中间有次记录从Excel到github的变更, 漏了一些不太重要的动画, 忽略就好啦) 与去年的变化: 都写出来的还是太多了，且大部分都没什么用，所以就把个人认为3分以下的动画分到Others里面了, 实在无聊再看吧 去掉了日文原名, 毕竟中文博客并不关心原名 续作类和Others都单独归类，不按月份来啦 Jan.5.0 紫罗兰永恒花园-京都动画 人类圣经，可以作为2018年度霸权的最有力竞争者之一了。 从战场上归来的薇尔莉特·伊芙加登从仅知道服从命令的杀戮兵器到成为为他人传递心情、代笔写信的自动人偶， 主角慢慢成长，慢慢取回作为人的感情，慢慢学会人心… 京阿尼精美的作画，可以直接和剧场版比肩了， 沿袭了小说改一向剧情丰富的有点，女主无口、反差萌， 作画、人物塑造、音乐、剧情均无可挑剔的动画作品，满分强推，吹爆！ 给满分女主额外的大图~ 4.8 我的三体 逻辑传-神游八方 从图就可以看出来，这个虽然模型类似我的世界， 但是实际上是用专业的动画/3D软件做的，听说是MAYA， 能够看出来作者已经尽力在还原原著的各种细节了， 动画里面也有许多细节很值得一看，无论是水的描绘、烟、人物的表情， 个人感觉都不会让三体的粉丝失望。 非常推荐！ 4.3 刻刻-GENO Studio 精巧的叙事不必采用宏大的时间观，而是能够将一个小的故事全面完整的表述出来。 挖坑填好、人物丰富、剧情跌宕，就可以视作不错的作品了。 刻刻讲述的是女主一家与反派在静止世界中的一次对抗， 动画杰出的地方在于对静止世界的刻画， 静止世界中物体与人物互动也有对应的逻辑进行解释， 作画还算精细，整个故事叙述也很完整。 对于静止世界的描画还是很有启发性的(也可能我静止系的看的太少)。 推荐~ 4.2 比宇宙更远的地方-MADHOUSE 高中女生去南极探险的过程， 四名女主因各自不同的理由集聚一起，最终完成了梦想中南极的游玩。 女一敢于为理想付诸行动的果敢、 四位少女穿越艰险的不易， 高中妹子间的友情， 游玩南极路途间的趣事，都可以成为此番的看点。 这是一部一月的黑马，能让无数看过的人热泪盈眶。 4.0 citrus~柑橘味香氣~-Passione 这是一部可以载入百合番经典的动画，而且是纯粹的深度百合，和摇曳百合那种轻百合可不一样， 一迅社出品，漫画的正版在布卡上， 作为百合向这一小众作品，漫画就具有极为优美的画风， 动画也是出色复现了漫画人物的美。 虽说剧情不是特别的优秀，不过在百合漫里面已经属于上品了。 3.5 Fate/EXTRA Last Encore-SHAFT 直到如今，个人也感觉Fate系列的巅峰是 Fate/Zero，也即第一部作品Fate/Stay Night的前传，卫宫切嗣作为Saber御主的故事。 与之相比，如果说Fate/Stay Night是因为初次制作资金不足的情况下获得爆炸性成功；那么Fate/Extra Last Encore的作画就不得不被吐槽一下了。 尼禄的眼睛下面那三个点是什么鬼啊！然后剧情完全没有原设定中那种紧凑和线索缠绕的感觉， 给人一种男主带着女主一边卖萌一边打怪升级刷副本的感觉，没有悲壮的剧情，没有宏大的设定，人设也很一般，感觉还是挺失望的， 不过看在是Fate系列也不会给太低的分就是了。 3.5 龙王的工作！-Project No.9 萝莉控的福音，不过整部番实际上是个以萝莉为噱头的将棋番， 值得称赞的地方在于能够能够将将棋这种文艺活动描绘的热血沸腾， 女二师姐也是萌点颇丰的角色， 整体是一部不错的将棋/萝莉番，即使是将棋0基础的也可以一看~ 3.4 爱吃拉面的小泉同学-Studio五组/AXsiZ 说真的..我真没想到这部番就真的是从头吃拉面吃到尾…正常来讲，吃也要换几种嘛..结果女主就是在换拉面口味。 不过微百合+女主萌，也就奠定了这部分是个为萌而去的番了。 消磨时间可以看看~ 3.4 宅饮。-Production IMS 喜欢喝酒的4个社会女性的日(夜晚)常，镜头锁定的是下班后的4位酒友+合租人的生活， 每一集都会出现一种酒，不过也不是什么高度数的劲酒，更多是一些啤酒和鸡尾酒。 不过这种描绘工作人士下班后生活的动画则很容易让已经大学毕业or准毕业的小伙伴们代入， 从而获得些许治愈，毕竟下班后开罐啤酒确实不错呀~ 3.0 DARLING in the FRANXX-TRIGGER/A-1 Pictures 这就是号称国家队的动画，单看阵容都是动画界的大佬，让人不得不期待一下其极高的质量和剧情， 不过实际上成品却是个依靠些许色情暗示卖一点点福利, 开着莫名其妙的机甲对抗莫名其妙的敌人的动画， 打着打着敌人还瞬间从以为的大boss变成了天降外星人。 作画不少崩坏，剧情也十分平庸的作品。 依靠女主一人撑起这部作品的片子， 说实话十分的失望，爱奇艺押宝也是押错了，哎…（-_-#) Apr.4.7 黑社会的超能力女儿-feel. 超能力妹子被黑帮撞到作为养女的故事， 这部番我是先追的漫画，最令人印象深刻的就是“智障”式的搞笑， 虽然作画和搞笑的方式比较令人无语，然而故事本身却很温情， 几个人物的塑造都包含了反差在里面，可以作为比较好的利用反差来描绘人物的参考了， 非常推荐！ 4.4 工作细胞-david production 这部番非常令人意外， 中规中矩甚至可以说是科教片的题材。 里面涉及到的生物/医学知识其实不多， 都是初中生物上的内容, 然而配上生动的动画比喻和优秀的人物设定, 使得这部番成为了一部老少皆宜的动画, 其中的血小板这一形象更是萌出天际，曾霸占P站和B站。 4.2 MEGALO BOX-TMS Entertainment 4月的黑马，一部让人热血沸腾的动画。 拳击这一最冲击的暴力能够激起男性最原始的野性、 那种血与汗的刺激。我想每个男生都梦想过自己一身硕肌站在斗技场上， 经过一番番的战斗最后虽然满身是伤，但是高举右手享受冠军的高光时刻。 动画中拳击的动作非常专业，而且配乐令人亢奋， 单单听其音乐就能唤醒战斗的欲望。 3.8 奴隶区-ZERO-G/TNK 一部游戏、诡辩、欺诈加上奴隶这一阴暗的主题能够满足我这种烧脑剧情爱好者的胃口， 带上特殊的牙套，与他人进行游戏，输的人就会成为赢的人的奴隶，无法反抗其命令； 喜欢这类的(狂赌之渊、达尔文游戏、全职猎人、惊爆游戏)的推荐观看， 毕竟当加上规则之后，一切会变的如此的有趣。 3.7 B：彼之初-Production I.G 这部番是网飞(NetFlix)爸爸买的独播，网飞的眼光也确实不错，剧情风格有点像心理测量者，不过叙事上个人感觉还有所欠缺。 整部番的基调给人一种推理番的感觉，然而剧情则和推理没有太大关系，侦探也一直不过是出现在主角所在的各种场合而已。 而未来风的战斗在加上超能力这个设定后，说实话就显得有点不伦不类了。 然而制作、动作、画面依旧不错。 3.6 宅男腐女恋爱真难-A-1 Pictures 又一部名字与内容相反的动画， 宅男腐女第一集就恋爱， 可能画风有的人接受不了，不过剧情本身还是挺甜的。 说来也奇怪，即便是单身狗的我们为什么也喜欢吃狗粮呢？ 汪汪汪汪~ 3.3 Comic Girls/漫画女孩-Nexus 微白合的动画， 可能由于主角们的年龄偏低， 或者是作者的编剧能力较弱， 与New Game这种已经工作的少女们的日常相比， 漫画女孩在一起画画集训的日常就显得单薄许多， 加上和漫画这一主题挂钩不深， 使得剧情除了微白合以外几乎就不剩什么看点了。 3.2 老子是魔法少女-pierrot plus 猎奇类的动画， 只能说看了可以扩宽三观，开拓视野。 两个主角就能满足百合、BL、攻受互换、男女三角各类口味挑剔的看官， 女装大佬肌肉男in魔法少女装，简直辣眼睛， 然而就是有让人忍不住一看的魔力。 Jul.3.8 后街女孩-J.C.STAFF 三名黑帮被老大罚去整容变性做偶像的故事， 这种超级反差带来的矛盾冲突必然让剧情不会平淡， 其老大”毕竟我也不是魔鬼”也成为红极一时， 以至到现在依旧能在弹幕中看到。 正式由于三名黑帮混混变成偶像这种荒诞的设定， 才能够打破偶像这一形象的固有束缚， 也能更加夸张对其进行描绘， 这一点使得即使是偶像部分的剧情也比真正的偶相番有趣的多。 3.3 碧蓝之海-ZERO G 嘛..讲道理，虽然我也喜欢看搞笑的，但是不喜欢画图突变类的。 而这种潜水的题材，本来还是挺不错的，不过动不动喝酒裸奔让我有点跌眼镜， 一群潜水社的裸奔(误)醉酒日常， 傲娇表妹、温柔表姐和大叔学姐加入让整个团体的人物性格也得到了平衡。 3.2 千绪的上学路-Diomedéa 曾经的我认为日本由于高中有社团，所以可以将高中生活描绘的有声有色， 而国内的小伙伴则必须紧锣密鼓备战高考，才会相较乏味无聊许多。 然而这部番能够颠覆我的这一认知， 仅仅是上学路上就能将腹黑与宅女这说翻就翻的友情小船晃荡的和剧情一样充满起伏, 能够借助想象将日常生活编织为有趣的故事的能力则非常值得借鉴和学习。 Oct.4.2 青春猪头少年不会梦到兔女郎学姐-CloverWorks 这是一个被名字耽误的番， 名字中的猪头更多是描绘男主的一股莽劲而非笨。 作为一部青春系的番， 男主虽然特立独行，由于一些流言而被同学疏远， 但是对自己在乎的人则能够拼尽一切。 依旧采用日本常见的“青春期综合症”这一题材， 不过剧情则是完整而紧凑的。 (XX准的某番剧情真的是一个天上一个地下) 4.0 关于我转生变成史莱姆这档事-8bit 还有什么比看主角开挂装X更享受的呢？ 龙傲天式的番多了虽然会无聊，但是在没什么能打的十月， 一部剧情完整，人物可爱，稍稍再给点福利的异世界开挂番还是很爽的。 与骨王那种一上来就满级满属性还满身氪金装备去新手村虐菜的设定不同, 这部番里面就是带了挂从新手村打到Boss点最后成为大Boss的剧情。 这种一上来就告诉你老子带挂的要比那些什么假装男主废柴， 时不时开挂一秒翻盘的要好看多了， 毕竟都是开挂吊打，我为什么要看主角假装挨揍呢？ 3.4 邻家索菲/隔壁的吸血鬼美眉-Studio 五组，AXsiZ 日常微百合萌妹番，讲述的就是喜欢人偶的女主:灯偶遇(?)住在隔壁的吸血鬼萌妹子索菲， 之后带着自己的好姬友日向以及后来又过来的索菲的好姬友艾莉的日常故事。 与普通的日常相比，吸血鬼+宅女的结合让观众常常发出“这可真是真实”的感叹； 在一开始就加入了待看列表，不过正式上映时名字叫做邻家索菲没有认出来， 导致最后才补完的，喜欢《向阳素描》、《黄金拼图》、《点兔》等微百合、萌妹纸日常、吸血鬼Loli的可以一看。 3.3 终将成为你-TROYCA 纯爱百合番，不过剧情比较有趣，营造了一个不可解的结： 一个人讨厌自己，如果你爱上了她，那么她也会讨厌这个爱上她讨厌事物的你； 而你如果对她没兴趣，她却会喜欢这个远离她讨厌事物的你； 所以，如果想要继续获得她的爱话，请不要爱上她哦~ 续作类个人评分直接写到前面啦~ 4.6 吹响吧！上低音号2-京都动画 京都动画对于软妹之间微百合的描绘、精致的作画，依旧和前一部一样的高质量，继续顶~ 4.6 命运石之门 0-WHITE FOX 0是β线，相比较于α线，这条线的剧情更加虐心，不过叙事上依旧非常出色，比普通的续集要好看许多！ 4.5 RWBY 5, 6 剧情依旧出彩，而且还介绍了真正的大Boss，就是不知道后面该怎么圆… 4.2 刀剑神域 Alicization Alicization 是刀剑系列里面最为出彩的一章，动画要播4季整整一年，不要错过哦~ 4.1 OVERLOAD/不死者之王 2, 3-MADHOUSE 骨傲天依旧不会让你失望，看着男主装X自己莫名也很爽~ 4.0 超能力者齐木楠雄的灾难 2-EGG FIRM/J.C.STAFF 依旧如前作一般，夸张的搞笑手法加上时不时的发糖，让人不能拒绝呀。 3.8 食戟之灵：餐之皿-J.C.STAFF 熟悉的配方，熟悉的味道，熟悉的爆衣，熟悉的嘴炮~ 3.3 魔法禁书目录 3-J.C.STAFF 魔法禁书目录整体上没有炮姐成功的原因在于女主是个酱油，而且没什么萌点, 所以一直就这样。由于设定上的庞大，所以想要看的话最好补补以前的剧情。 3.2 東京喰種：re-Studio Pierrot 剧情其实还是挺不错的，不过动画作画上还是有点经费不足的样子，没看过漫画的可以看看，男主成为CCG这边的了~ 2.5 女神异闻录5-CloverWorks 个人始终不喜欢女神异闻录5，可能是因为这个迎合的是初中生的叛逆期，因此我这种中年人只觉得无聊… 当时玩游戏也觉得挺无聊的.用替身在幻想世家攻击的剧情。 Others 2.9 少女☆歌剧 Revue Starlight-KINEMA CITRUS 作画和动作还是很精致的，不过剧情就？？？ 莫名奇妙打来打去，就一种虽然不知道发生了什么，但是好厉害的样子，因为还有歌剧，所以歌唱的还不错… 2.8 多田君不恋爱-动画工房 这种名字的肯定是要恋爱的，分低的原因在于女主塑造的过于刻意，作为国家公主形象是没有智商的傻白甜，还经常尬演一些动作, 不过百合工房的基本功还是有的。 2.8 邪神与厨二病少女-nomad 本来以为是个可以和小林家的龙女仆一战的番，不过剧情相比之下无聊的多，完全就是看小邪神卖萌和卖蠢，作为开心剂就OK啦。 2.7 魔法少女サイト/魔法少女网站-production dóA 感觉自从魔法少女小圆成功后，猎奇的魔法少女越来越多了，本番也是一样，不过在作画和剧情上要更弱一些，还是可以看的 2.6 刀剑神域外传 Gun Gale Online-Studio 3Hz 外传只是个借用GGO世界观的微白合番而已，不过作画和剧情和原著相比确实弱不少，作为剧情主要人物，女主要打倒的人也没给很多合理的解释，女主的现实和虚拟之间的矛盾描绘也不到位。 2.5 A.I.C.O. Incarnation-BONES 由于是骨头社+网飞爸爸，所以制作上还是属上乘的，里面衣服的创新设定、女主的剧情设定还可以认同，不过剧情的进展着实无聊，打斗也很一般，结局也很容易猜出来。 2.5 爆肝工程师的异世界狂想曲-SILVER LINK./CONNECT 骨(龙)傲天式的番，男主作为游戏程序员穿越到了一个与自己开发的游戏类似的游戏中开后宫的故事 2.4 Alice or Alice-EMT Squared 四格漫画改变，讲述的是男主和两个妹妹的日常, 因为是日常..所以真的挺无聊的，只是卖萌而已，因为剧情过于无聊，漫画我都已经弃了😔 2.2 One Room-ZERO-G 第一人称视角的动画，可以理解为I社XX女友orXX少女orXX之狼样式的全年龄动画版… 1.8 赛马娘 Pretty Derby-P.A.WORKS 赛马变成萌妹来赛跑..个人很不喜欢猫耳以外的兽化，而且这个剧情实在没营养 1.4异世界魔王与召唤少女的奴隶魔术-亚细亚堂 和爆肝工程师的异世界狂想曲差不多一样无聊，然而为什么这个分低更多呢？因为莫名其妙的两个后宫还是不如明明白白的后宫看着舒服。 1.2 实验品家庭/実験品家族 -クリーチャーズ・ファミリー・デイズ–大火鸟动画 作为国产动画是个不错的尝试, 家人都是异能/异性，描述的家庭的亲密关系, 不过剧情get不到什么点 1.0 原书·原书使-Hoods Entertainment 女主上来啥都不会但是却被最强的xxx附身/选中， 然后一路嘴炮到最后开挂收尾和女儿亲亲我我的故事… End7月之后工作上开始步入正轨，有了小可爱一起玩耍， 动漫看的相比之前就会少一些，加上7月本身的动画质量一般， 所以追的少了许多。 加上愈发感觉自己的知识储备过少， 涉及面单一， 所以新的一年还想要多读一些书、 看看综艺和电影什么的， 或许从今年之后， 追番总结会变成娱乐总结了吧~哈哈哈。]]></content>
      <tags>
        <tag>ACG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Summary]]></title>
    <url>%2Fblog%2F2019%2F01%2F06%2F2018-summary%2F</url>
    <content type="text"><![CDATA[2018 注定是我人生中极为重要的转折点之一，我的学生时代暂时要告一段落了，正式踏入这个 无论曾经憧憬也好、现在逃避也好的巨大社会。迎来自己的第一份工作， 赚取自己的第一份薪水，发布自己的第一张插画… 或许是因为这众多的变化，让我觉得去年的一年似乎经历了好多好多… 流水账 Jan. 毕业答辩 在元旦的时候和自己很尊敬的一个初中同学长聊了一番，欣赏她的洒脱，能够同时进行西语的翻译和演员的工作，这样优秀的斜杠青年在她的人生活划出了让我极为羡慕与憧憬的多彩一笔。 暗暗为自己也立下了同样的目标并奋斗… 我的博客也是在这段时间从已经没人维护的Octopress迁移到了Hexo，并进行了整理，之后招待招待同学，打打尼尔机械纪元就回家过年啦。这个月唯一重要的事情可能就是毕业答辩吧， 不过毕业过的小伙伴也都知道，这过程中最麻烦的实际上是论文的撰写，倒不是答辩， 所以轻松答辩完后就愉快的回家啦。 这里必须吹一波XBox精英手柄，玩第一人称游戏真的是赞爆，Nier还是Steam国区刚出时Bug价买的，首发199元 哈哈哈 Feb. HPCA @ Vienna! 二月可以说是这年最爽的一个月，首先就是寒假过年各种high, 月末从家回到学校搭乘飞往维也纳的航班，参加HPCA, (详细的游记在这篇 《维也纳的七日之行》)。也完成了第一次去欧洲、第一次单人搭航班出国、第一次参加学术会议等等成就， 收获颇丰。 萨尔兹堡的雪景 Mar. Graduation! 毕业啦！ 1号才从维也纳搭乘飞机回到上海， 回来之后便是学生时代最快乐的时光: 完成了毕业前的工作但是还没开始工作。 这一个月主要就是在学画画、看动漫、打游戏与弄报销，整理整理照片、写写游记，以及最重要的，搬家。 和同一个学院又同在菊厂工作的同学合租，在3月初就租好了，不过月底才搬了过去… 我的小窝~ Apr. Cooking &amp; Exercising 4月底才入职，在入职前就学做饭、健身以及学画画，每天其实过得还是很充实的，花了茫茫多的钱配了一台8700K, 1070, 360mm水冷，4K显示器的顶配电脑， 做过几个自己喜欢吃的饭，请了私教进行增肌，新买了一款Filco 圣手二代红轴的键盘，一个月花掉了我一年的积蓄…在入职前进行充足的休息和放松！ 红轴小白 茶轴小黑 高级游戏机 ✧(≖ ◡ ≖✿) 自给自足的龙须面 May. Begin to Work! 五月正式开始工作啦，工作上其实适应的还是挺快的，因为比较对口，所以基本上不到一周就适应了.. 又是做系统开发，连开发环境用的都还是研究生时期配好的。海波老师要求组会用英语的作用也体现了出来， 刚到公司就和德研的开发团队进行合作，自己的英语也派上了用场。新人还是很轻松的，没有高负荷的工作， 给了充足的学习时间，我甚至也在这个月完成了自己画画的课程，那幅画依旧摆在那.. 处女作~ 上海华为的办公楼 Jun. Work! Work! Work! 工作了之后生活就比较稳定了，上班下班，倒也没有什么新奇的事情，中间和实验室的小伙伴一起骑行了一次，终于来了次世博园的中国馆！ 因为骑行才有机会去的中国馆~ Jul. 台风好大 Aug. 一刀和铲屎官 工作上的事情不再赘述，也没什么有意思的东东，这个月我的Mentor搬家，有幸去吃了开火饭，尴尬的是当时买的香槟忘带过去了= = (事后感觉幸好没带，Mentor的父亲是位对酒颇为讲究的人，我这种外行买的只能是过家家的饮料…)， 撸到了他的爱猫：一刀，遗憾的是另一只小七怕生没出来，只能远远看看。 8月底出差去了北京研究所，也能一睹我们的架构师大神楠哥和雨总的真容！ 一刀: 这次让你拍是你的福分，回去好好欣赏哀家的身姿。 Sep. 水族馆 &amp; 乌镇 去了上海海洋馆，在中秋节的时候去游玩了乌镇，乌镇的游记要之后补了…(估计咕咕咕了) Oct. 同学婚礼 十一国庆期间回西安参加了本科团支书同学的婚礼，随后就回了趟老家看望爷爷奶奶。爷爷奶奶的小院还是那样充满生机，小时候玩土用的小铁铲也依旧静静躺在那， 不过现在爷爷奶奶也不怎么种庄稼，想必也没太多的使用机会了吧。 团支书的婚礼 Nov. 出差杭州 &amp; 迪士尼 11月出差去次了杭州，和德研所的兄弟们连续奋斗了十几天，每天都是早出晚归，不过不得不说杭州的兄弟们是真的拼，经常晚上还能看到好多人在加班… 月底去了上海迪士尼，因为是请的调休假周内去的，所以人也不多，游记嘛..之后再补吧..总之玩的很开心 咔咔~ 杭研所的黑天鹅 迪士尼圣诞点灯 Dec. 年底Rush &amp; 跨年 临近年底，项目的Deadline越来越紧，工作却依旧剩的很多，所以就各种赶赶赶；跨年是在Mentor家过的，有幸品尝了Mentro大师级别的厨艺，也能一睹小七的美颜。 过了这么久，小七终于敢出来见人了 hhh，吸猫吸猫。 傻乎乎的小七 Note 2018年我开始了自己的第一份工作，完成了自己心中一直不忘的画画学习，进行了健身，坚持背了一年的单词并完成了扇贝的365计划… 这一年过的非常充实，不过生活的挑战才刚刚开始，自己想要在这个繁华的大都市立足， 而现在则离这个目标还有不小的距离… 扇贝365计划的完成徽章 虽然看似这一年过的还挺不错，不过实际上还有一些没有完成的2018年初立下的目标 回顾一下2018年初给自己立下的目标: 把画画学完，交个作品 英语单词学习 快速适应社畜生活 记录每天做了什么 -&gt; 记录每天的花销 日语单词学习 -&gt; 看各种综艺 画至少四副插画 -&gt; 健身 没能完成每日记录、画画和日语学习的目标，不过对应的时间用到了其他方面… 也算是过的非常充实啦，自己觉得还是挺满意的=v= 2019年的Flags!!! 游泳/健身 70次+ 读5本专业外的书 画至少4副插画 日语/英语单词的学习 记录每天做了什么 记录每天的开销 希望2019也能过得开开心心~ 赚好多的钱钱~]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VIM Search and Pattern Regex Summary]]></title>
    <url>%2Fblog%2F2018%2F06%2F30%2Fvim-regex%2F</url>
    <content type="text"><![CDATA[既然已经选择了VIM，那么当然要在文本处理效率上走向极致， 本篇主要记录一下vim中常用的正则表达式操作， 来进一步提高自己的效率。 Quick Index1234删除行尾空格: %s/\s\+$//删除行首空格: %s/^\s*//删除空行: g/^\s*$/d # g: line matching pattern, d: delete交换前后两个单词顺序: %s/\(\w\+\)\(\W\+\)\(\w\+\)/\3\2\1/gc 基本操作12:[line num1, line num2]s/str1/str2/flag # 匹配num1-num2的行:%s/str1/str2/flag # 全文匹配 也可以先用visual (v) 来选择一段文本再使用:s进行替换。 Flags12345g: Global - Apply to each occurencec: Confirm - Ask for each replacemente: Error - Don not display errorI: Case sensitivei: Ignore - Case insensitive Metacharacters (元字符)vim定义了一些元字符，具有特殊的作用: ., *, \, [, ^, $ 是元字符，具有特殊意义 Collection: [1a-c] : (1, a, b, c), 反选用^ ([^a-c]) Complete matching: &lt;str&gt; 不会匹配 string +, ?, |, &amp;, {, (, )需要escaped的方式来使用它们的特殊功能(\+) Backreference: \(str\), 之后可以使用\#进行选择 Meta Description . 任意一个字符 [abc] 集合中的任意一个字符 \d 阿拉伯数字 [0-9], 大写反选 \x 十六进制 [0-9A-Fa-f], 大写反选 \l [a-z]大写反选 \u [A-Z]大写反选 \w 单词字符[0-9A-Za-z]大写反选 \t tab \s 匹配空白字符[ \t],大写反选 ^ 匹配行首 $ 匹配行尾 \r 新一行 \n null \&lt; 词首 \&gt; 词尾 \zs patter 的开始 \ze patter 的结束 `\ ` 或者 \&amp; 分开匹配，匹配项的先后顺序无关 关于zs和ze非常好用: :s/Copyright \zs2007\ze All Rights Reserved/2008/g 就会只替换2007, 能避免我们敲一堆东西 Repetition: 重复vim可以重复某一匹配patter, 也同样有一些具有重复作用的元字符: 匹配foo以及任意两个字符: 1\&#123;#\&#125;: (/foo.\&#123;2\&#125;) 用于重复的元字符: Meta Description * 匹配0-任意个 \+ 匹配1-任意个 \? 匹配0或1个 \{n, m} 匹配n-m个 \{n} 匹配n个 \{n,} n-任意个 \{,m} 0-m个 Backreference 用\( \)可以建立一个backreference, 之后使用\# (#为数字)进行引用: 1234567Original Text:Hello, Alice:s/\(hello\)\(s*\)\([\u\l]+\)/\3\2, welcome!/gAfter substitution:Alice, Welcome! Using Current Register or Word我们有的时候可能首先全文搜索某些东西，然后想直接对其进行替换的话，在搜索完直接替换即可，不需要再次输入search的pattern 1:%s//new str/g 或者我们首先剪切or复制了一些东西，这些内容会被存到寄存器里，(可以通过:reg)查看这些寄存器里面存的都是啥， 用下面的命令让字符替换为我们寄存器里的值 1:s/ffo/&lt;c-r&gt;0/g &lt;c-r&gt;指的是按Ctrl+R，之后指定寄存器的名字即可 Reference: Vim Tips Wiki Vim Documentation Changelog2019-03-08: Fix typo in title (Thanks to Yeezhou Tang)]]></content>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARM Device Tree 1 - PCIe]]></title>
    <url>%2Fblog%2F2018%2F06%2F20%2Farm-device-tree-1%2F</url>
    <content type="text"><![CDATA[续上文《ARM Device Tree 0》, 本篇看一下中断部分和一些Device Tree的相关总结。 Overviewfoundation-v8.dstilink1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/ &#123; model = "Foundation-v8A"; compatible = "arm,foundation-aarch64", "arm,vexpress"; interrupt-parent = &lt;&amp;gic&gt;; #address-cells = &lt;2&gt;; #size-cells = &lt;2&gt;; smb@08000000 &#123; compatible = "arm,vexpress,v2m-p1", "simple-bus"; arm,v2m-memory-map = "rs1"; #address-cells = &lt;2&gt;; /* SMB chipselect number and offset */ #size-cells = &lt;1&gt;; ranges = &lt;0 0 0 0x08000000 0x04000000&gt;, &lt;1 0 0 0x14000000 0x04000000&gt;, &lt;2 0 0 0x18000000 0x04000000&gt;, &lt;3 0 0 0x1c000000 0x04000000&gt;, &lt;4 0 0 0x0c000000 0x04000000&gt;, &lt;5 0 0 0x10000000 0x04000000&gt;; #interrupt-cells = &lt;1&gt;; interrupt-map-mask = &lt;0 0 63&gt;; interrupt-map = &lt;0 0 0 &amp;gic 0 0 0 0 4&gt;, &lt;0 0 1 &amp;gic 0 0 0 1 4&gt;, &lt;0 0 2 &amp;gic 0 0 0 2 4&gt;, &lt;0 0 3 &amp;gic 0 0 0 3 4&gt;, &lt;0 0 4 &amp;gic 0 0 0 4 4&gt;, ... &lt;0 0 42 &amp;gic 0 0 0 42 4&gt;; ethernet@2,02000000 &#123; compatible = "smsc,lan91c111"; reg = &lt;2 0x02000000 0x10000&gt;; interrupts = &lt;15&gt;; &#125;; ... &#125;; ... /* In foundation-v8.dst */ gic: interrupt-controller@2c001000 &#123; compatible = "arm,cortex-a15-gic", "arm,cortex-a9-gic"; #interrupt-cells = &lt;3&gt;; #address-cells = &lt;2&gt;; interrupt-controller; reg = &lt;0x0 0x2c001000 0 0x1000&gt;, &lt;0x0 0x2c002000 0 0x2000&gt;, &lt;0x0 0x2c004000 0 0x2000&gt;, &lt;0x0 0x2c006000 0 0x2000&gt;; interrupts = &lt;1 9 0xf04&gt;; &#125;;&#125;; 我们再来看一次SMBus的内容，这次我们主要看中断映射部分。 SMB并不是中断控制器， 我们可以发现，在SMB上的设备只用一个中断cell, 比如ethernet@2, 02000000的interrupts = &lt;15&gt;. 这个中断需要被映射到GIC上的中断，这里就需要用interrupt-map。 Interrupt 的模型也同样是一个树形结构，子节点有自己的中断空间(Interrupt Space)， 如果需要把子节点的中断空间与父节点的联系起来，与地址空间类似， 中断也就需要映射。Interrupt-map描述的是一种接线的规则， 或者中断路由的规则(子设备的中断如何均衡地发给中断控制器). 具有interrupt-map的结点必须也同时定义#interrupt-cells， #interrupt-cells定义了子节点的interrupts要用几个cell来描述。 如果需要interrupt-map但是没有发现这个属性，那么映射被认为是1:1的映射。 interrupt-map-mask会对unit interrupt specifier进行Mask后再进行map的映射， unit interrupt specifier顾名思义，就是子节点的地址child-unit-address+中断说明interrupt specifier interrupt-map里面数据项的格式一般为: child-unit-address child-interrupt-specifier interrupt-parent parent-unit-address parent-interrupt-specifier 0 0 1 &amp;gic 0 0 0 1 4 0 0 2 &amp;gic 0 0 0 2 4 0 0 3 &amp;gic 0 0 0 3 4 … 0 0 42 &amp;gic 0 0 0 42 4 child-unit-address: 0 0, 这个是12行的#address-cells = &lt;2&gt;决定 child-interrupt-specifier: 1, 这个是22行的 #interrupt-cells = &lt;1&gt;决定 interrupt-parent: &amp;gic, 这个的值就是phandle, smb继承自4行root指定的interrupt-parent = &lt;&amp;gic&gt; parent-unit-address: 0 0, 这个是45行GIC的#address-cells = &lt;2&gt;决定 parent-interrupt-specifier: 0 1 4, 由root下第44行， GIC中的#interrupt-cells = &lt;3&gt;决定 现在我们再次看ethernet@2,02000000的15号中断，通过interrupt-map我们知道， smb下设备的地址和gic中的地址没有区别, interrupt-map-mask为&lt;0 0 63&gt; or &lt;0 0 0x002f&gt;. 也就是最大支持64个child-interrupt-specifier, 其中15号中断会被映射为GIC的&lt;0 15 4&gt;, 也就是SPI的15号，flag为active high level-sensitive. ARM GICfoundation-v8.dtslink12345678910111213/ &#123; gic: interrupt-controller@2c001000 &#123; compatible = "arm,cortex-a15-gic", "arm,cortex-a9-gic"; #interrupt-cells = &lt;3&gt;; #address-cells = &lt;2&gt;; interrupt-controller; reg = &lt;0x0 0x2c001000 0 0x1000&gt;, &lt;0x0 0x2c002000 0 0x2000&gt;, &lt;0x0 0x2c004000 0 0x2000&gt;, &lt;0x0 0x2c006000 0 0x2000&gt;; interrupts = &lt;1 9 0xf04&gt;; &#125;;&#125;; 从Linux中ARM GIC的文档我们可以知道， 第一个reg区域是GIC distributor的基址和大小，第二个区域是GIC cpu interface register的基址和大小, 后面两个区域和interrupts又表示什么呢？ interrupts有两种情况可以出现，第一个是作为二级GIC, 那么其自身会将中断连到上一个GIC上，也就需要指明自己的中断； 第二种就是支持虚拟化的primary gic，GIC virtualization extensions (VGIC). 第三个区域&lt;0x0 0x2c004000 0 0x2000&gt;就是GIC virtual interface control register 的基址和大小； 第四个区域是GIC virtual cpu interface register 的基址和大小, virtual cpu interface使得GIC能在不退出guest的情况下发送IRQ ACKs 和 EOIs，从而减少VMExit。 interrupts则指定了VGIC maintenance interrupt的中断号， 在ARM GIC-400(2.3.2 PPIs)的文档中: This is a configurable event generated by the corresponding virtual CPU interface to indicate a situation that might require hypervisor action. 说明了当vGIC需要Hypervisor的处理时会注入这个中断，从而产生下陷(VMExit)，之后Hypervisor就可以进行处理。 关于vGIC的用法如果有机会了我之后再虚拟化的相关文章中再介绍，本文不再赘述。 PCI(e)现在我们再来看看设备中的一大类PCI(Peripheral Component Interconnect)设备， 现在新的是PCI-e, 这类设备都会接到PCI-e总线上， 而设备的地址也更加复杂。 hi3660.dstilink123456789101112131415161718192021222324252627282930313233343536373839404142/ &#123; compatible = "hisilicon,hi3660"; interrupt-parent = &lt;&amp;gic&gt;; #address-cells = &lt;2&gt;; #size-cells = &lt;2&gt;; ... soc &#123; compatible = "simple-bus"; #address-cells = &lt;2&gt;; #size-cells = &lt;2&gt;; ranges; ... pcie@f4000000 &#123; compatible = "hisilicon,kirin960-pcie"; reg = &lt;0x0 0xf4000000 0x0 0x1000&gt;, &lt;0x0 0xff3fe000 0x0 0x1000&gt;, &lt;0x0 0xf3f20000 0x0 0x40000&gt;, &lt;0x0 0xf5000000 0x0 0x2000&gt;; reg-names = "dbi", "apb", "phy", "config"; bus-range = &lt;0x0 0x1&gt;; #address-cells = &lt;3&gt;; #size-cells = &lt;2&gt;; device_type = "pci"; ranges = &lt;0x02000000 0x0 0x00000000 0x0 0xf6000000 0x0 0x02000000&gt;; num-lanes = &lt;1&gt;; #interrupt-cells = &lt;1&gt;; interrupt-map-mask = &lt;0xf800 0 0 7&gt;; interrupt-map = &lt;0x0 0 0 1 &amp;gic GIC_SPI 282 IRQ_TYPE_LEVEL_HIGH&gt;, &lt;0x0 0 0 2 &amp;gic GIC_SPI 283 IRQ_TYPE_LEVEL_HIGH&gt;, &lt;0x0 0 0 3 &amp;gic GIC_SPI 284 IRQ_TYPE_LEVEL_HIGH&gt;, &lt;0x0 0 0 4 &amp;gic GIC_SPI 285 IRQ_TYPE_LEVEL_HIGH&gt;; ... reset-gpios = &lt;&amp;gpio11 1 0 &gt;; &#125;; &#125;;&#125;; foundation上没有pcie, 所以我们看看hikey960上的pcie。 从compatible可以知道这是hisilicon的kirin960-pcie, 所以我们可以从linux的源码里面找到它的文档: designware-pcie.txt, kirin-pcie.txt(kirin-pcie是基于上面设计的). reg就是配置的物理地址 reg-names: dbi: controller configuration registers; apb: apb Ctrl register defined by Kirin; phy: apb PHY register defined by Kirin; config: PCIe configuration space registers. reset-gpios: The GPIO to generate PCIe PERST# assert and deassert signal. num-lanes: number of lanes to use (this property should be specified unless the link is brought already up in BIOS) clocks: Must contain an entry for each entry in clock-names. See ../clocks/clock-bindings.txt for details. clock-names: Must include the following entries: pcie pcie_bus 上面这些是PCIe里面新增或者比较特殊的一些property, 从binding的文档可以很简单看出来这些用法， 我们主要看看PCI-e的地址映射。 PCI-e Address Mappingpice总线都是被唯一标记的，总线号通过bus-range暴露出来， 第一个cell记录的是这条总线被分配的总线号， 第二个cell是它下属PCI总线的最大总线号。 pcie也同样具有自己的地址空间，类似的使用range, #address-cells和#size-cells, ranges = &lt;0x02000000 0x0 0x00000000 0x0 0xf6000000 0x0 0x02000000&gt;; 这里的问题在于，为什么PCI-e使用3个cell来描述子节点的地址，外部的地址空间(64-bit)是正常的2个cell. PCI-e的子节点地址分为三个部分: phys.hi: npt000ss bbbbbbbb dddddfff rrrrrrrr phys.mid: hhhhhhhh hhhhhhhh hhhhhhhh hhhhhhhh phys.low: llllllll llllllll llllllll llllllll PCI-e地址总长为64位，地址是在phys.mid与phys.low里面，而phys.hi中的bit则有着特殊的意义: n: is 0 if the address is relocatable, 1 otherwise (doesn’t play a role here) p: is 1 if prefetchable (cacheable) region flag t: is 1 if the address is aliased (for non-relocatable I/O), below 1 MB (for Memory), or below 64 KB (for relocatable I/O) ss: space code 00: configuration space 01: I/O space 10: 32 bit memory space 11: 64 bit memory space bbbbbbbb: The PCI bus number. PCI may be structured hierarchically. So we may have PCI/PCI bridges which will define sub busses. ddddd: The device number, typically associated with IDSEL signal connections. fff: The function number. Used for multifunction PCI devices. rrrrrrrr: Register number; used for configuration cycles. 所以我们的range 0x0200_0000表示ss为10，我们的PCI-e有一个32-bit的 non-prefetchabled,大小为32MB的地址空间0x0000_0000-0x01FF_FFFF 将被映射到0xf600_0000 - 0xf7FF_FFFF这段内存区域。Kernel会找到pci，并将相关的详细数据解读出来。 关于地址这部分，ss会影响phys.hi里面的其他位的含义，具体的可以参考文档PCI Bus Binding to: IEEE Std 1275-1994 Standard for Boot (Initialization Configuration) Firmware, v2.1。 PCI-e DMA Address Translation 如果PCI-e支持DMA (Direct Memory Access)的话，还会有一个类似与dma-ranges = &lt;0x02000000 0 0x00000000 0x80000000 0 0x20000000&gt;property. 这个是告诉系统PCI-e会认为PCIe地址空间中大小为512MB，从0x0000_0000开始的地址空间会被映射到主存0x8000_0000的地方，ss为02表示这是一段32-bit的内存。 Interrupt 在PCI-e这边的中断，我们发现interrupt-map-mask多了一个cell, 这也是因为PCI-e这边的#address-cells为3的原因， 剩余的内容和上面的类似，就不再赘述了。 PCI-e Devices 配置PCI-e上的设备不能像直接挂在root下设备一样被CPU直接访问， 而是统一通过PCI-e的Configuration Space (最后一个reg region)进行配置。 phys.hi中的device-num、function-number等等就可以用上了; 从这个phys.hi的格式我们可以知道，每个PCI-e可以支持最多256 buses 32devices 8 functions, 找一个设备使用其Bus, Device, Function (BDF)就可以唯一确定， 关于PCI-e or PCI设备的访问和配置，wiki上有更详细的介绍。 Reference List Devicetree Specification v0.1 The Devicetree Specification Open Firmware: Interrupt Mapping version 0.5 CoreLink GIC-400 Generic Interrupt Controller revision:r0p0 PCI Bus Binding to: IEEE Std 1275-1994 Standard for Boot (Initialization Configuration) Firmware, v2.1 PCI configuration space]]></content>
      <tags>
        <tag>tutorial</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARM Device Tree 0]]></title>
    <url>%2Fblog%2F2018%2F06%2F19%2Farm-device-tree-0%2F</url>
    <content type="text"><![CDATA[工作原因接触到了ARM上常用的Device Tree, 本篇简单介绍一下Device Tree的由来和使用。 OverviewDevice tree的诞生是源于Linux要求启动时有所有可使用硬件的说明和描述， 不然Kernel是不知道怎么配置的。 X86的PC这部分工作是由BIOS来完成的，但是ARM没有BIOS， 因此才需要Device-tree这样一个东西来告诉kernel设备的信息。 在kernel的 /proc/device-tree/可以看到kernel识别出的所有device: 12345$ ls /proc/device-tree#address-cells interrupt-controller@e82b0000 pmic@fff34000#size-cells interrupt-parent pmualiases keys psci... History在Device tree出现之前，会有一个专门的文件来记录ARM上的设备信息， command-line, 内存大小等参数则是作为ARM Tags (ATAGs), 让bootloader作为入口参数, 通过寄存器R2(ARM)传给kernel. 而极其类型就通过R1传给kernel, 所以每个kernel就只为特定的板子进行编译。 其解决方案就是Device Tree 或者叫做Open Platform (OF) or Flattened Device Tree (FDT), 其本质是一种byte code类型的树状数据结构来描述设备信息。 当今的bootloader会使用两个文件: kernel image 和 device tree blob (DTB)来启动OS. DTB的地址通过R2传给kernel, R1则不再使用。 A device tree is a tree data structure with nodes that describe the physical devices in a system. UsageARM的device tree都在 /arch/arm/boot/dts/ (device tree source) 用Linux的脚本来编译dtb: 1$ scripts/dtc/dtc -I dts -O dtb -o /path/my_tree.dtb /arch/arm/boot/dts/my_tree.dts 或者反过来从dtb获取dts: 1$ scripts/dtc/dtc -I dtb -O dts -o /path/my_tree.dts /path/my_tree.dtb foundation-v8.dtsi dtb只不过是dts信息的二进制压缩版而已。 SyntaxStructure 每个Module在Device Tree中都是一个Node, 根据driver的实现，可以有父节点或者子节点; Root是所有module最终的父节点； 常见的Top-level module: cpus: its each sub-nodes describing each CPU in the system. memory : defines location and size of the RAM. chosen : defines parameters chosen or defined by the system firmware at boot time. In practice, one of its usage is to pass the kernel command line. aliases : shortcuts to certain nodes. One or more nodes defining the buses in the SoC One or mode nodes defining on-board devices 以ARM的foundation v8 作为例子: Foundation Platform是ARM提供的满足其Specification的虚拟板子， 有最基本的硬件功能) foundation-v8.dtsilink123456789101112131415161718192021222324252627282930313233343536/* * ARM Ltd. * ARMv8 Foundation model DTS *//dts-v1/;/memreserve/ 0x80000000 0x00010000;/ &#123; model = "Foundation-v8A"; compatible = "arm,foundation-aarch64", "arm,vexpress"; interrupt-parent = &lt;&amp;gic&gt;; #address-cells = &lt;2&gt;; #size-cells = &lt;2&gt;; chosen &#123; &#125;; aliases &#123; serial0 = &amp;v2m_serial0; ... &#125;; cpus &#123; #address-cells = &lt;2&gt;; #size-cells = &lt;0&gt;; cpu@0 &#123; ... &#125;; cpu@1 &#123; ... &#125;; cpu@2 &#123; ... &#125;; cpu@3 &#123; ... &#125;; L2_0: l2-cache0 &#123; compatible = "cache"; &#125;; &#125;; memory@80000000 &#123; ... &#125;; gic: interrupt-controller@2c001000 &#123; ... &#125;; timer: &#123; ... &#125;; pmu: &#123; ... &#125;; smb: &#123; ... &#125;; foundation-v8.dtslink12#include "foundation-v8.dtsi"/ &#123; gic: interrupt-controller@2c001000 &#123; ... &#125;; &#125;; Foundation的device tree信息非常清晰， include: 跟C一样，可以include其他文件，这里foundation-v8.dts就include了foundation-v8.dtsi *.dtsi: 扩展的dts文件，但是其本身不能include其他的dts文件。 /: root node, Device tree从该节点开始。 chose是空的，如果想看实例可以参考hikey960的devicetree: hi3660-hikey960.dtslink1chosen &#123; stdout-path = "serial6:115200n8"; &#125;; hikey960在device tree中设定了输出的串口为uart6, 这也是我们在使用Hikey960默认使用UART6的原因。 Properties上面每个Node里面都有许多关键词，称为Property, 每个property是一个Key-value键值对， Key Compatible: 这是连接硬件与Driver最为重要的一段信息， 告诉Driver应该与哪个Node相匹配。 其优先级与字符串里的顺序一致， 在Linux中用来与DT_MACHINE结构中的dt_compat进行匹配。 top-level的compatible一般是适配的板子的信息:&lt;manufacture&gt;,&lt;model&gt;。 我们的Tree中，是ARM foundation，但是实现了vexpress的接口， 所以描述时的值为:&quot;arm,foundation-aarch64&quot;, &quot;arm,vexpress&quot; Node name: must as &lt;name&gt;[@&lt;unit-address], 描述node的类型而非具体型号，最大31个char Addressing reg: Node/device 的物理地址: reg = &lt;address1 length1 [address2 length2] [address3 length3] ... &gt;， 由于address 和 length都是变长，所以需要parent-node指定下面两个Property来帮助确定reg中的值长度。 #address-cells: reg中base address 需要多少cell(32bits values) #size-cells: reg中的size大小 Interrupt interrupt-controller: bool类型来表明当前的node是不是interrupt controller #interrupt-cells: 表示interrupts属性中多少个cell是被选定的interrupt controller所管理 interrupt-parrent: 是不是有个一个phandle指向当前node value: value可以为空or任何字节流，由于数据类型信息是没有包含在数据结构中的， 所以在device tree中有一些基本的通用类型表示方法: text-string: 双引号, &quot;string-property = &quot;a string&quot;; cell: 32-bit无符号整型: &lt; &gt;, cell-property = &lt;0xbeef 123 0xabcd1234&gt;; binary-property: [ ], binary-property = [0x01 0x23 0x45 0x67]; mixed-property: 不同类型的可以放一起: mixed-property = &quot;a string&quot;, [0x01 0x23 0x45 0x67], &lt;0x12345678&gt;; string-list: 逗号也用来建立字符串列表: string-list = &quot;red fish&quot;, &quot;blue fish&quot;; Address ExamplesCPUfoundation-v8.dtsi12345678910111213141516171819cpus &#123;#address-cells = &lt;2&gt;;#size-cells = &lt;0&gt;; cpu@0 &#123; device_type = "cpu"; compatible = "arm,armv8"; reg = &lt;0x0 0x0&gt;; enable-method = "spin-table"; cpu-release-addr = &lt;0x0 0x8000fff8&gt;; next-level-cache = &lt;&amp;L2_0&gt;; &#125;; cpu@1 &#123; ... &#125;; cpu@2 &#123; ... &#125;; cpu@3 &#123; ... &#125;;L2_0: l2-cache0 &#123; compatible = "cache"; &#125;;&#125;; 以cpus为例，其拥有4个cpu@n子节点和一个l2-cache0子节点, 其中L2_0是l2-cache0的label。 #address-cells为&lt;2&gt;说明子节点中reg的地址为两个cell(uint64), 没有size。 其中cpu@0的地址为0x0 0x0, (两个cell)。 根据习惯，如果一个Node含有reg，那么其名称中必须含有unit-address也即reg中的第一个值。 所以CPU@0的0取自0x0， Memory (Mapped Device)foundation-v8.dtsi12345memory@80000000 &#123; device_type = "memory"; reg = &lt;0x00000000 0x80000000 0 0x80000000&gt;, &lt;0x00000008 0x80000000 0 0x80000000&gt;; &#125;; 内存的话，上面的信息表示内存有两个range: 分别是从0x8000_0000-0xFFFF_FFFF(2GB)与0x08_8000_0000-0x08_FFFF_FFFF(2GB)一共4GB的空间。 不过手册上的信息是，后面一段内存是从0x08_8000_0000-0x09_FFFF_FFFF(6GB)的内存, Linux只用了后半段的2GB。 Memory-mapped Device的格式与内存类似,不过要含有compatible信息。 Device Live on Bus这种设备在Bus上的设备有不同的寻址模式，一般会有片选线来选出chip号。 foundation-v8.dtsi1234567891011121314151617181920smb@08000000 &#123; compatible = "arm,vexpress,v2m-p1", "simple-bus"; arm,v2m-memory-map = "rs1"; #address-cells = &lt;2&gt;; /* SMB chipselect number and offset */ #size-cells = &lt;1&gt;; ranges = &lt;0 0 0 0x08000000 0x04000000&gt;, &lt;1 0 0 0x14000000 0x04000000&gt;, &lt;2 0 0 0x18000000 0x04000000&gt;, &lt;3 0 0 0x1c000000 0x04000000&gt;, &lt;4 0 0 0x0c000000 0x04000000&gt;, &lt;5 0 0 0x10000000 0x04000000&gt;; ... ethernet@2,02000000 &#123; compatible = "smsc,lan91c111"; reg = &lt;2 0x02000000 0x10000&gt;; interrupts = &lt;15&gt;; &#125;; ...&#125; 比如System Management Bus(SMBus, SMB)上的Ethernet@2, 就首先使用片选线2来选出对应的chip, 之后是在chip上的基地址0x0200_0000，size是0x10000。 Range (Address Translation)在root下的设备地址是可以直接被CPU理解的， 但是像SMBus上的设备， 其地址由于是有片选地址的原因， 需要映射为CPU可以理解的地址才能被CPU使用, 这时就可以使用range。 range中的每个entry都是由child address, parent address, child size组成， 格式分别按child #address-cells, parent #address-cells, 和 child #size-cells 如上所示，smb中的基址0x0被翻译为root下的0x0800_0000, 大小为0x0400_0000， 所以ethernet@2,02000000在内存中的基址是在0x1800_0000 + 0x0200_0000 = 0x1A00_0000， 最终的内存范围是0x1A00_0000 - 0x1A00_FFFF。 如果子节点和父节点的地址空间一样，可以加一个空的range property, 这表示子节点和父节点的内存一一映射。 需要地址翻译的原因在于PCI设备地址空间复杂，需要将这些详细信息交给kernel来处理， 而DMA设备又需要知道bus上的真实地址而非这些翻译后的地址， 还有的时候设备可以被分为一组而使用同样的映射等等。 有一些使用片选的外设我们会发现没有range, 这种外设说明不是memory-mapped的设备，CPU也只能通过其父节点间接对其访问。 InterruptsInterrupt signal可能由任何设备发起，或结束于任何设备，所以不同于address树状的描述方式， 中断一般是按照与Device Tree无关的节点间的Link来描述。 interrupt-controller 用于指明一个device是否接受中断信号。 interrupt-cells 中断控制器的Property之一， 用来描述有多少cell在当前终端控制前的interrupt specifier中， 作用与#address-cells和#size-cells类似。 interrupt-parent 含有phandle的结点的Property之一，不含有phandle的node可以从父节点继承这一property. 注意我们的foundation-v8.dtsi的开头有一句interrupt-parent = &lt;&amp;gic&gt;;, 所以root下的所有子节点默认继承该属性。 interrupts Node所含有的interrupt specifier，每个中断输出信号对应一个。 interrupt specifier是一个或多个cell(#interrupt-cells指定)大小的数据， 描述了某个设备中断对应于哪个中断接受者， 一个设备可能含有多个中断信号输出， 这时就有多个sepcifier来描述这些输出分别对应于哪个中断接受端。 至于specifier中的数据表示什么意思则要根据interrupt controller的手册来了。 foundation-v8.dts12345678910111213/ &#123; gic: interrupt-controller@2c001000 &#123; compatible = "arm,cortex-a15-gic", "arm,cortex-a9-gic"; #interrupt-cells = &lt;3&gt;; #address-cells = &lt;2&gt;; interrupt-controller; reg = &lt;0x0 0x2c001000 0 0x1000&gt;, &lt;0x0 0x2c002000 0 0x2000&gt;, &lt;0x0 0x2c004000 0 0x2000&gt;, &lt;0x0 0x2c006000 0 0x2000&gt;; interrupts = &lt;1 9 0xf04&gt;; &#125;;&#125;; 在foundation-v8的dts文件中，gic(v2)是从0x2c00_1000 - 0x2c00_7FFF的这段空间中， interrupt-controller，所以他是一个中断控制器。 #interrupt-cells = &lt;3&gt;, 所有以它作为中断接受者的设备都要用3个cell来描述中断信息。 gic.txtlink1234567891011121314151617181920The 1st cell is the interrupt type; 0 for SPI interrupts, 1 for PPIinterrupts.The 2nd cell contains the interrupt number for the interrupt type.SPI interrupts are in the range [0-987]. PPI interrupts are in therange [0-15].The 3rd cell is the flags, encoded as follows: bits[3:0] trigger type and level flags. 1 = low-to-high edge triggered 2 = high-to-low edge triggered (invalid for SPIs) 4 = active high level-sensitive 8 = active low level-sensitive (invalid for SPIs). bits[15:8] PPI interrupt cpu mask. Each bit corresponds to each of the 8 possible cpus attached to the GIC. A bit set to &apos;1&apos; indicated the interrupt is wired to that CPU. Only valid for PPI interrupts. Also note that the configurability of PPI interrupts is IMPLEMENTATION DEFINED and as such not guaranteed to be present (most SoC available in 2014 seem to ignore the setting of this flag and use the hardware default value). Linux源码arm gic的binding文档中对三个cell如何描述进行了说明， 第一个是指明Shared processor interrupts(SPI)还是Per processor interrupts(PPI); 第二个是中断号; 第三个是flag。 foundation-v8.dtsi12345678timer &#123; compatible = "arm,armv8-timer"; interrupts = &lt;1 13 0xf08&gt;, &lt;1 14 0xf08&gt;, &lt;1 11 0xf08&gt;, &lt;1 10 0xf08&gt;; clock-frequency = &lt;100000000&gt;; &#125;; timer就是一个PPI, 分别对应中断号10, 11, 13, 14， 并且对4个CPU与之相连, 且为adtive low level-sentitive(0xf08) 到这里为止，一个device tree中的常见信息我们都可以理解了， 不过我们还发现在smb中有interrupt-map这种东西，这个我们在下一篇继续分析。 下一篇我们主要来看PCI设备、中断的映射和对Device的一些总结。 Reference List: Linux Kernel For Newbies Linux Device tree Device Tree Mysteries Device Tree Usage Devicetree Specification]]></content>
      <tags>
        <tag>tutorial</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Virtualization Intro 0]]></title>
    <url>%2Fblog%2F2018%2F06%2F13%2Fvirtualization-intro-0%2F</url>
    <content type="text"><![CDATA[Introduction to Virtualization 0By SilentMing Blog: http://silentming.net Slides Story Line Brief introduction to virtualization (Definition, histroy …) Classification (Spectrum) Architecture on ARM (Type-2 Hypervisor) (It’s simple, but only cover partial) What is VirtualizationVirtualization: A layer mapping its visible interface and resources onto the interface and resources of the underlying layer or system on which it is implemented Abstraction – to simplify the use of the underlying resource (e.g., by removing details of the resource’s structure) Replication – to create multiple instances of the resource (e.g., to simplify management or allocation) Isolation – to separate the uses which clients make of the underlying resources (e.g., to improve security) How Dose It Come ?Run multiple OSes on a Single Computer Histroy 1960: CP-40 - full virtualization 1970: System/370 - without virtual memory, time-sharing 1999: VMware Virtual Platform - x86 virtualization support 2003: Xen and the Art of Virtualization - Para-virtualization 2005: QEMU(Quick Emulator) - rescue for those times when VMware is overkill 2005: Free Desktop Virtualization - VMWare 2005 &amp; 2006: Intel VT-x &amp; AMD-V (Hardware support for virtualization) 2007: KVM(Kernel-based Virtual Machine) 2011: ARMv8 virtualization support 2013: [QEMU 1.5] ARM Cortex-A9 &amp; Cortex-A15 2014: KVM/ARM &amp; Xen 4.4 2017: ARMv8.4: VHE(Virtualization Host Extension) Why VirtualizationConsolidation Run several different OS on a single machine Isolation Keep the VMs separated as error container Fault tolerant Maintenance Easy to deploy, backup, clone, (live) migrate Security VM introspection (VMI) Antivirus out of the OS Definition The act of creating a virtual (rather than actual) version of something, including virtual computer hardware platforms, storage devices, and computer network resources. (wiki) A layer mapping its visible interface and resources onto the interface and resources of the underlying layer or system on which it is implemented (CMU) An enfficient, isolated duplicate of the real machine (Formal Requirements for Virtualizable Third Generation Architectures) Efficiency Innocuous instructions should execute directly on hardware Resource control Executed programs may not affect the system resources Equivalence The behavior of a program executing under the VMM should be the same as if the program were executed directly on the hardware (except possibly for timing and resource availability) Basic Concepts Domain/VM (Virtual Machine) Guest VM / Guest OS / Guest App Hypervisor / VMM (VM Monitor) / host Type of Hypervisor Who manages hardware? (Type-1: Hypervisor, Type-2: Host Kernel) Type-1: Xen Own scheduler, I/O Driver… Type-2: Kvm Multiplex scheduler and drivers in Linux Classification and SpectrumClassfication CPU Virtualization (privilege level &amp; privileged instructions) Memory Virtualization (GVA -&gt; GPA -&gt; HPA/MPA) I/O Virtualization Spectrum Traditional Full Virtualization Para-Virtualization Hardware-Assistant Virtualization Approach of Virtualization Approach Traditional Full Virtualization Para-Virtualization Hardware-assistant Virtualization CPU Binary Rewriting Using hypercall Root/Non-root (VT-x) host mode &amp; guest mode (AMD-v) EL2 (ARM) Memory Software Emluation Shadow Page Table Extended PT (VT-x) Nested PT(AMD-v) EL2 translation table (ARM) I/O Software Emluation Para / virt I/O (Front &amp; Back-end) Singe Root I/O Virtualization Approach of Virtualization cont’dSoftware Emulation123456789101112131415161718/* Complete Machine Simulation */#define REG_EAX 1;int32_t eip;int32_t regs[8];int32_t segregs[4];...for (;;) &#123; read_instruction(); switch (decode_instruction_opcode()) &#123; case OPCODE_ADD: int src = decode_src_reg(); int dst = decode_dst_reg(); regs[dst] = regs[dst] + regs[src]; break; case .. &#125; eip += instruction_length;&#125; Type-2 Virtualization on ARMv8 Approach Traditional Full Virtualization Para-Virtualization Hardware-assistant Virtualization CPU Binary Rewriting Using hypercall Root/Non-root (VT-x) host mode &amp; guest mode (AMD-v) EL2 (ARM) Memory Software Emluation Shadow Page Table Extended PT (VT-x) Nested PT(AMD-v) EL2 translation table (ARM) I/O Software Emluation Para / virt I/O (Front &amp; Back-end) Singe Root I/O Virtualization Run Application Load application from image to memory; Give control to app; App trap on privileged instructions during execution; Kernel handle exception and return control; Run Guest VM Load guest image into memory; Give control to guest OS; Control return to hypervisor when VMExit happen; Hypervisor handle VMExit and return control using VMRun(AMD-V)/VMEnter(VT-x)/IRET(ARM); Challenges Privilege instructions in guest APP traps into which level? Privilege level of Guest OS? (Hypervisor has highest privilege) Guest OS need physical memory. I/O devices need to be shared by different VMs. CPU Virtualization - ARMv8 Virtualization Support EL2: New Exception Level for Hypervisor Separate CPU mode designed to run hypervisor Not designed to run full operating system Reduced virtual memory support compared to EL1 Limited support for interracting with EL0 Hypervisor Configuration Register (HCR_EL2)Purpose: Provides configuration control for virtualization, including whether various Non- secure operations are trapped to EL2.HCR_EL2 is part of the Hypervisor and virtualization registers functional group. CPU Virtualization cont’d$LINUX/arch/arm64/kvm/hyp/entry.S 12345678910111213141516171819202122ENTRY(__guest_enter) // x0: vcpu // x1: host context // x2-x17: clobbered by macros // x18: guest context // Store the host regs ... // Restore guest regs x0-x17 ldp x0, x1, [x18, #CPU_XREG_OFFSET(0)] ... // Restore guest regs x19-x29, lr restore_callee_saved_regs x18 // Restore guest reg x18 ldr x18, [x18, #CPU_XREG_OFFSET(18)] // Do not touch any register after this! eretENDPROC(__guest_enter) CPU Virtualization cont’d$LINUX/arch/arm64/kvm/hyp/entry.S 12345678910111213141516171819202122232425ENTRY(__guest_exit) // x0: return code // x1: vcpu // x2-x29,lr: vcpu regs // vcpu x0-x1 on the stack ... // Store the guest regs x2 and x3 // Retrieve the guest regs x0-x1 from the stack // Store the guest regs x0-x1 and x4-x18 // Store the guest regs x19-x29, lr get_host_ctxt x2, x3 // Now restore the host regs restore_callee_saved_regs x2 // If the exception took place, restore the EL1 exception // context so that we can report some information. msr elr_el2, x2 msr esr_el2, x3 msr spsr_el2, x4 orr x0, x0, x51: retENDPROC(__guest_exit) Memory Virtualization - EL2 Translation Table An independant translation table in EL2 GVA -&gt; GPA -&gt; HPA VA -&gt; IPA (Intermediate Physical Address) -&gt; PA I/O Virtualization - virtio in QEMU Front-driver in guest kernel; Back-driver in QEMU; Transfer data via Shared-memory (Vring); Qemu rw data using real driver; Thanks]]></content>
      <tags>
        <tag>tutorial</tag>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[硕士三年]]></title>
    <url>%2Fblog%2F2018%2F04%2F30%2Fgraduation-from-sjtu%2F</url>
    <content type="text"><![CDATA[转眼间，硕士的学习也迎来了完结。刚好最近刚入职，恰逢五一，自己重新回忆一遍当初选择硕士上硕士的心路历程以及现在的感想。以此文来为自己已经结束的硕士学习画上一个句号。 回顾2015-离开西安离开西安是一开始就想好的，“如果不能保外那么就打算直接找工作，工作的目标地点是广深“。本科毕业的我思路还是十分明确的，虽然无论是在《本科四年》的回忆还是在刚来到实验室的《2015 回顾》中我都没有透露过这一想法，其原因主要是因为我不是因为讨厌等负面情绪才想要离开西安的，所以也不想留下这种印象。离开西安主要还是出于换一个环境、离家远一点，但是以西交的教学方式，没有论文的我很难申到世界Top的大学，所以目标只是换一个起码看起来更好一点的学校。 我想对于一个没有考虑很多的本科生来说，多少都曾怀揣成为清北学子的梦，我也投过清华的面试，但是清华的计算机没有夏令营等能提前确保名额的通道，有且只有一次最终面试的方式对于我来说风险还是太大了。自己面试的“地球计算科学”那边计算机学位只招博士，大气生态海洋的老师倒是非常喜欢我这个软件出身的学生，但是多多少少都还是不合适。 在参加了上交的夏令营之后，选择了一个能让自己学到更多东西的操作系统方向，没有看过导师的介绍，没有提前问过实验室的同学，完全只是凭着自己的感觉选择了一个对于当时的我来说最为神秘却也是计算机领域非常基础的系统方向。 我们电院的人数是最多的，所以坐在最中间的空地中。 2015-降低他人期望深知自己基础薄弱的我一反常态，没有故意去网上搜罗资料来弥补自己系统知识的不足，因为我是抱着求学的目的来上研究生的，所以我想把自己的求知欲与现状展现给面试我，也是在后来教会我诸多知识的海波老师(据海波之后透露，当时看我挺机灵的，虽然没什么系统基础不过还是要我了)。 也可能本来是个门槛挺高的实验室，可能是大家都害怕被刷，报名的人反而不多，天时地利人和的作用之下，我成为了IPADS的一员开始学习。 在最开始做Lab的时候我也老老实实地承认自己参考了网上的答案，还被海波批评这样是不行的…自己因为只是摸过几次Linux，尝试用过一段时间Vim，索性就声称完全没有用过Linux、没有用过Vim。方方面面都在降低他人对自己的期望，也以此来降低自己的压力。 我的工位~ 还是非常宽敞的。 研一时期的学生宿舍依旧是上床下桌，不过是三人间。 冬天橘子跑到机箱上取暖… 2016-上课+干活研一的课业十分重，其实大部分时间都在上课和做实验，加上自己又是一门没学过的课的助教，自己不但要学一遍还要负责讲习题课，所以时间剩余的并不多。老大的目的也是希望我借助教学习一下计算机的基础知识，后来发现自己期间学到的知识贯穿了许多以往零零散散学到的内容，收获颇丰。 实验室以学术研究为重，不同于一些需要经常做项目的团队，硕士干的活和博士相差无几，只是硕士只需要填些已有的坑(改进某些工作、做些后续)，博士则需要自己挖新坑(找一个能够研究3-5年的领域)。我跟着一位本科生，在斌哥的指导下、聪聪大哥的带领下体验了一个项目从设计实现到最后发表论文的全部过程。 紧张的工作之余，大家一起看看鬼畜hhh 年会的疯狂~ 2017-专心于项目研二开始在经过大约一个多月的研究、讨论与头脑风暴后，我终于也有了自己的Idea，自己的工作目标。之后就是边学边做，就像当初那位带我的本科生那样，我也带着一名研一的学生一起完成自己的项目Fidelius。 项目是在16年的10月份差不多Nexen投去NDSS’17后开始构想的，等到Nexen被接受后又花了一个月左右的时间帮忙完善Final Version，自己着手开始的时候已经是12月份了，还记得自己乐观地列了个寒假完成大部分实现工作的Plan..目标2月的USENIX ATC… 结果一直是到5月份在疯狂赶CCS’17。连续一个多月没有休息过，为了项目不停加班加点，论文则是聪聪大哥一手起稿与指导。最终在没有通过宵的情况下成功投去了CCS。 做提拉米苏的花花和有爱的实验室小伙伴们。 2017-实习+论文在完成自己的项目后就请假回家放松去了，顺带给家里配了一台配置不低的电脑。6月开始就是在华为的实习，期间投了一篇国内小论文到《信息安全学报》。 华为上研所的美丽景色。 等到10月实习结束回来的时候刚好赶上实验室举办SOSP，因此前前后后出了不少力。11月则飞到广州参加女神姐姐的婚礼，一并游玩了深圳与香港。不得不说没项目一身轻，好像这个时候才体会到真正的如鱼得水，自由自在。 研三后就会被发配到临时座位.. 毕竟也不怎么干活了，只是写写论文而已。 最后一次参加实验室的年会~ 站着的是抽中奖的小伙伴们。 2018-毕业快乐完成毕业论文后就处于划水状态，过年回家玩新买的Nier:Automation、见各种同学；放假回来出国开个会浪一圈，回来就画画、游泳…整个四月在搬到新居后就练习做饭、出去聚餐..充分挥霍作为学生最后的闲暇。 一起毕业的同班同学~ 在毕业典礼现场 一起毕业的实验室小伙伴~ 斌哥拍摄的 毕业聚餐，因为海波老师比较忙提前走了，所以我P了一张hhh 感想现在问我是否后悔读了硕士，我是肯定不后悔的。且不说专业知识上我学到了很多，从一个0基础系统小白到略知一二的系统新人程序员，看似也没成长多少，但是前者需要师傅带入门，而现在的我则可以靠自己修行了。 我个人是相信眼界是高于智慧高于聪明才智的，而眼界的提升则必须逼迫自己离开舒适的环境不断进入陌生的恐慌区，去尝试各种未知的事物。换一个环境也能够认识更多的人，自己的眼界也变得更加开阔(至少消费观念变了不少hhh)，我也相信当那些比我跨越更远的、出国深造的小伙伴克服更大的文化冲击、语言障碍后，其眼界也必将比我更加开阔。 我非常庆幸自己能够在非常合适的时间来到IPADS，这里大神云集，良师众多，老师们正好处于需要评副教授的阶段，所以他们自己也非常拼，也一并带动了我们。每天都有至少一个导师在Lab, 80后的他们与我的代沟也非常小，可以轻松的与之交谈，这些今后也会成为我珍贵的财富。 博士？与被催婚的不同，看到我顺利毕业的家人亲戚们逢年过节都会问我一个问题：“怎么不考虑继续读一个博士？” 对于从小学一路读到大学的中国式教育，似乎学习就是用时间去换取文聘，就像论资排辈一样，耗着年限、增加自己的资历。所以不难理解大家会有这样的疑问，我的母亲也总是担心我少读一个博士会不会在以后吃亏，就像当初他们那辈没有读本科的后来确实有些吃亏一样。也感谢亲朋好友为我的担忧。 知识储备：当初选择读研是因为自己感到知识储备不够，虽然可以直接工作干活，但是我自己知道对于计算机方面的基础知识还欠缺太多，一个985高校软件工程毕业的学生却不知道虚拟内存的实现、不知道虚拟机的实现、不知道图像处理的细节、不知道的还有很多很多，更严重的是我无从下手去补这些知识……我是学过操作系统、编译理论、数据结构与算法，还能够熟练使用C、C++、Java……对于一个程序员来说，写写业务逻辑、调调API，这些大致的理论也确实够用了。但是如果想再深一步，我深知还需要补的知识太多，这些坑迟早都要填，只是有的人选择在学校填上，有的人选择在工作中再挤时间去补，我无非选择的是前者罢了。 目标方向：博士则不太一样，我们实验室的情况里一个硕士能够体验博士所做的所有工作，所以我知道一个博士是如何研究的。这与本科时的不知所措不同，现在的我知道差距在哪里，知道前进的方向在哪，剩下的只是去做就是了，所以我选择直接工作。还有一点是博士的压力其实挺大的，相比较于其他的实验室，IPADS的压力或许还能小很多，但即使是这样，面对面前这些科研任务，压力也依旧不可忽视，所以一个博士的培养并不是一件轻松容易的事情，不是用时间就能换出来的。 时机：市场是不会等我们的，在我本科毕业(2015年)那年，金融是牛市，互联网是大浪，在那时找工作没有找不到的，我一个面试时还没考过四级、留过级休过学比同龄人大了2-3岁的同学也能够进入BAT这样的企业，他也把握住了机会成功入职；金融的同学在那一年的年终奖可以拿到几年的工资…… 现在的就业状况更加稳定，但相比较三年前已经不再显得十分红火，而且我自己的系统方向远比不上现在大热的人工智能。对我来说，4-5年的博士生涯在这个快速变化的行业显得是一种高风险的赌博，硕博连读或者本硕连读的还能够一定程度上减小这些风险，但是我这种还需要至少4年的读法，我还没有十足的信心。 学历似乎没有那么重要：如果有那么一些不怎么看学历的行业，那么互联网行业一定是其中之一，在这个面试可以直接量化技术水平的行业里，第一轮靠的是在线机试成绩、面试也问的是技术点，没有多少人在乎你的学历，大家只在乎你能不能解决问题。所以我感觉似乎不需要花几年时间来刷一个博士学历… End现在再看看当初刚开始读硕的感想，感觉这几年自己也没多少改变，接下来工作后不知道以后再回过头看这篇总结时会不会有什么其他的想法。也说不定之后回炉重新读博时会再笑着看这时还算年轻的自己。]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蹒跚学画 1-左右翻转脸就崩?]]></title>
    <url>%2Fblog%2F2018%2F03%2F22%2Fillus-1-flip-mistake%2F</url>
    <content type="text"><![CDATA[这个系列准备记录一下自己学画画中间遇到的各种坑。 当个NG错题集和反思来用，一方面对自己是个激励和提醒，另一方面也希望能帮助到其他的小伙伴们~ 昨天看到自己扇贝同桌的头像是个很萌的手绘少女，于是决定临摹顺便练练表情，但是在每次左右翻转的时候都会感觉自己的脸画崩了.. 今天刚好看到蓝铅笔发文解释这个，自己感觉还是有些道理的，这里做个记录。 本文参考了为什么左右一翻转，脸就画崩了？！by 蓝铅笔-阿童木小七七 脸型不对称 比如上图翻转前后都是感觉嘴巴偏左。不过这个的原因主要是因为脸型不对称，一边脸大一边脸小，加上围巾遮住了下巴导致无法直接利用下巴作对比从而产生的错觉。 将下巴修一下后再反转就能稍微好点了。 这个是原文里的图片对比: 其实也是因为脸型不对称的原因，一边有脸蛋一边没有。 视觉习惯其实我在看上面这张康纳的时候违和感不是那么强，但是如果是自己画出来的违和感一般都会很强.. 加上每个人都有一个视觉上的习惯，比如“主视眼”.. (我的主视眼是左眼，所以画出来的东西也更符合左眼的习惯) 有的时候拿图给你朋友看他们会觉得没任何问题。。。 这个看原文好像和左右脑还有关系。 stimuli in the right half of the visual filed are registered by receptors on the left side of each eye, which send signals to the left hemisphere.stimuli in the left half of the visual filed are transmitted by both eyes to right hemisphere. 也就是说，如果你看的东西在你眼前靠左，那么是右脑来处理这些信息； 如果是靠右，那么会是左脑处理。右脑负责具象化而左脑负责抽象画思维。 所以如果觉得别扭，可以看看是不是自己屏幕是歪的，或者自己画画的姿势导致自己是斜视屏幕。 所以背单词的话单词放右边(左脑分析)，对应的图片放左边(右脑记忆).. 在画画的时候就可以考虑把任务的结构草稿放右边，图片整体预览放左边… 画线习惯我的那张图的原因就在于画线的时候习惯，我们在画一条弧线的时候会弧一般都不在中间，所以用同一只手画脸很容易出现一边比另一边高.. 这个推荐在SAI or PS里在开两个浮动视图，然后其中一个翻转，每次画的时候对可以从整体和对称两个方式来判断自己有没有画歪。 SAI里也可以随时Ctrl + R调出尺子比一比，即使水平翻转来检查。 人体结构其实最主要的还是人体结构啦、透视对不对等等，所以说这么多有的没的最主要的还是把体块画准… 锻炼右脑 越是经常用左脑好像这种情况越严重？锻炼右脑注意记忆细节，多默写一些看过的画…(比如随笔画个皮卡丘)说不定就能改善一些。]]></content>
      <tags>
        <tag>painting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蹒跚学画 0-Before Start]]></title>
    <url>%2Fblog%2F2018%2F03%2F21%2Fillus-0-before-start%2F</url>
    <content type="text"><![CDATA[趁着入职前赶紧把画画的课给结掉，这个系列准备记录一下自己学画画中间遇到的各种坑。 一方面对自己是个激励和提醒，另一方面也希望能帮助到其他的小伙伴们~ 记录一下自己学习的过程！晒出来让别人知道对自己也是一种心理暗示和提醒，免得自己懒惰！ 课程自学 or 报班?自学的大佬…纯自学入门的即使已经成为了大佬，多少在基础上都会有一点问题。我自己打乒乓在一个暑假报班学了颠球和体能提升后，后面就全是在和小伙伴随便打。 经过了十几年，现在你说打吧跟业余的也能装模作样两下，但是没有一个受过训练的人喜欢跟我打，因为对打结果其次更想要的是互相的提升，但是我这种大部分靠自学的根本不会对拉╮(╯▽╰)╭哎。 虽然教你的老师也不一定非常专业，但是多少给出的也是他的经验总结，比自己从头摸石头过河要好很多。 纯报班的话也是远远不够的，没有自学能力基本上是个废物，没人能24小时一直盯着自己，而且每个人掌握的也不一样，所以该买书自学就自学.. 不过入门还是推荐报班，无论什么，我现在入门都是要找私教、找家教…不然自己跑偏到火星都没人救。 免费 or 付费？对于一个学习系统的程序员我来说，现在已经深刻意识到付费学习与免费学习之间的巨大差异。 在自己专业没有一个老师或者前辈带，基本上这辈子我都没有自信能掌握书本上的内容。 付费课程是为了买提问权 付费的课程里面大部分内容实际上都是一眼就明白的简单的道理，网上的课程基本上都是一些录像，所以看起来没什么价值。 但是，付费课程的最大好处在于老师会回应你的问题，我自己的理解基本上付费就是为了买提问权。所以有的课只卖1v1的教辅，课程本身公开。 当然自己自学如果能解决掉大部分问题，那么对于自己的提升是最大的，然而这种过程十分枯燥而且消耗时间，所以在学习初始，时间的转化率相对比较低。 老师指导能及时纠正我们的前进方向，能针对性的告诉我们应该怎么练习。我自己学板绘，所以上的是网课，画室那种不了解不予评价。 付费内容有人负责 在选择软件时，付费的软件不用说质量也会比免费的好。(这里说的免费不是指大公司那种免费软件、会员收费这种，更多的指的是开源社区这种)， 毕竟他们获取了利益，那么我要求相应质量的课程也是应该的。因此付费的课程更具有条理性、拥有大纲、主题贯穿始终。 这一点对于我这种刚进坑的小白来说再重要不过，更别说有的课的方法还不对把自己反而弄进坑。 大佬不出高质量免费课T.T 一个大佬既然可以通过课程获取利益，他自然不会选择将自己多年的研究免费公开..(已经经济自由做慈善的毕竟还是少数)。 这里或许有人反驳，网上xxx就出了好多免费课。但是大佬的免费课更多的是一种表演、宣传, 或者就是人人都知道的基础内容。 我上课的老师说过，他自己的免费课也都是干货，但是没那么时间解释，能看懂你拿去，看不懂你看了也没什么用，主要是为了吸引别人付费上他的课， 所以都是在炫技法…想通过免费课来系统学习是相对困难的.. 专业壁垒 我还记得我看的第一本纯英的专业书是Introduction to Java using IBM Rational Application Developer V6，(IBM课程 Course Code SW244)。 当时西交和IBM合作，加开了Java课(一般高校面向对象因为已经讲过C++了，所以不会专门开Java的)。第一次啃的时候各种认识不认识的的单词Class、Object、Primitive、Override… 但是就是不知道它在说什么。 所以这也是没有老师带的情况下自己啃书最为困难的地方，我们需要不断试错来定位在专业语境下术语的具体含义。 画画也是一样，虽然术语问题相对少了一些，，但造成壁垒的更多是一些过程中的方法、一些看不到的细节。 这是我第一次临摹的线稿，可以看出来都是在拉一根根的辅助线，然后照着抄。 但是实际上肩膀的线全靠随缘，自己画的时候可能一个弯钩带过，而忽视这块肌肉，造成线不准的问题。 并且，原图是Saru大大画的，所以自己想当然会当做权威，但是实际上Saru大大手的比例是改过的， 正常的手张开可以盖住整个脸，但是原图的手小了很多。 这个问题就是在1v1的时候老师点出来的，虽然说完后自己一眼就能看出来，但是在养成随时校准比例的被动技能之前自己想发现这个还是挺困难的。 免费不要了？No! 免费课的价值在一定阶段后反而更大，就像所有计算机毕业生不会重新翻《C语言入门》一样，入门课冗长的内容已经不适合具有基础的小伙伴了。 这个时候炫技法的免费课反而具有极高的价值，因为这个时候我们已经能够举一反三，能够将看到的东西迅速拆解并加入到自己的知识树中。 这个是第一次旋转椅子时的线条，然后辅导老师给了他的画作为样板(最右)让我临摹，自己又开始关注线条的画法。 就这样练了大概十天左右，单根线虽然知道两头要细，但是画面整体还是生硬死板。 在搁置了半年回来继续的时候这个问题依旧存在，后来就在B站上找了一个原速勾线视频.. “SAI线稿绘制 练习勾线技法详细解说(av10628199)“， 这个免费课也是一个网课公司的(邢帅教育)的课程，看了之后就开始模仿，其实效果还挺显著的.. 这是看完视频后一个下午的画，最开始没看之前(1)自己怎么都画不好，看完后就开始自己琢磨(2)， 之后的线条就比之前好了很多.. (1)并不是草稿，而是因为当时自己能画出来的就是这种水平。 目的个人觉得在干什么之前一定要明确目的，知识是学不完的，所以盲目学虽说不算浪费时间，但是带给自己的幸福感也没有带目的性的强。 先明确自己要不要以此为生，是不是要通过它找工作，还是只是像我这种沙包一样只是爱好，这些决定练习强度和方向。 我打死都不要连续十几天每天十几个小时只画画，我热爱我的专业，也不想转行..而且我就是喜欢萌妹子，并不想迎合市场。 这是当前的目标，那么就以此努力；等到年终的时候如果调整了目标再重新制定计划。 不过盲目的画可能是今天十几小时拼命练，然后连续几天一笔不动..制定明确的目的，并为此分配合理的时间。 工具作为一个外行，可以不购买顶配的装备，但是如果不是仅体验一次的话，专业的设备是必要的。 无论硬件还是软件，如果要上就上专业设备，可以是专业里面的低端，但也不要上杂牌。 软件..不想写代码，也没什么选就不提了。直接上WACOM，直接上中号以上.. 当时去日本旅游想着便宜又没下定决心学画画的时候买了个小号的板子，根本不能用..后面还是含泪继续买 哎。 软件截图用SETUNA2 (windows) or Mapture (MacOS)，简直好用，谁用谁知道。 SAI2 Mac上没有，不过听说PS CC的线条也很好用，所以自己斟酌吧..我Mac买了一个CLIP Studio， 因为自己笔记本废的原因，Windows上用的是SAI2。 人偶模型我用的是Pose Studio， 当时在找Clip Studio的时候发现的，目前感觉还是挺好用的。 这个可以导入FBX、LWO、LWS、OBJ、M3C这些格式，所以能找到喜欢的模型过来可以各种扭=v=， 并且这个支持透视。 网站推荐有一些是课上老师推荐的，有一些是自己之前做网页的时候找到的。 Color Scheme Designer 我做网页或者PPT一直会用的配色网，估计以后学到上色了还是会用这个，能按各种原则(三角原则等等)直接帮你配好色，不用自己再去色轮上找了。 Sketchfab 一个3D素材的网站，可以在上面各种自己喜欢的3D模型，支持在线换视角。 Posemaniacs 各种人体Pose，好处是上面有肌肉，所以比自己用模型扭能更好的观察肌肉，同样是3D的。 Textures 顾名思义，材质网站。可以找各种材质后期叠到自己的画上。 Costumers’s Guide 欧美电影的各种服装剧照，用来当做参考。 顺带推荐一本「おんなのこの服の脱がせ方」(おんなのこのふくのぬがせかた)， 虽然我自己还没学到衣服..但是这本一看就是满满的干货，尤其是对于我这种连一堆妹子衣服都不知道叫什么的人来说…(比如提袜带这种·///·) WorldCosplay 毋需过多介绍，著名的Cosplay网站，找衣服和Pose参考的时候可以用，毕竟Coser的姿势都是能比较好展现萌点的，就算背过这些Pose都不为过。 AKIBAPHOTOGRAPHY 全是最新的手办信息，个人感觉用手办学褶皱和光影是最好的，因为手办本身对实物做了简化，光影明确，比较适合我这种新手去分析。 Line of Action 各种人物、动物动作的速写，感觉是个学动态和线条的好网站。 ColorHexa 也是顾名思义，为Color建立六边形能力图的网站！随便输入一个颜色该网站都会对其进行非常详细的分析。 包含对颜色的各种转换(rgb、hsl、cmyk…)、模拟色、三角配色、相近的备选色、在网页上的预览、甚至有在色盲眼中颜色的样子… 色彩的Wikipedia。 Nipponcolors 名字一色是日本色彩，是一个给各种各样颜色起了非常文艺的名字的网站..老师推荐的，但是我更感觉像一个设计系学生的作业orz… End其实这些更多的是自己的思想斗争，学板绘是长期的心愿，加上年事已高，玩不动大型网游的原因，所以现在正处于转型期… 理想的生活是有时间能画画爽图，就看自己能不能挤出这些时间坚持下去啦。 以及给自己上的课的老师打个小广告，Dan·Evan, 丹艾凡, PIXIV ID:142066， 他在哪教课就自己找吧..我也没拿推广费 ╮(╯▽╰)╭。我记得他之前说过他是学室内设计还是什么的，也是自己当时跟着日系插画兴起的浪潮开始学的日系， 其实有人批评他的人体，他自己也说过人体在板绘之前没怎么练过。不过我个人觉得他教的逻辑和我之前学习理工课的逻辑很像，所以还是挺喜欢这个老师的课的。 也可能是因为其他老师我看的是免费课的原因，有看过所谓的定线.. 草稿中那么多凌乱的线条就说”定线定线”鬼知道怎么定哦。为啥你定出来就好看，我自己定就崩.. 所以这个老师画画前先讲逻辑讲方法这点极其对我口味，试听了两节1v1辅导课后当时就交钱了..虽说自己毕业各种赶论文荒废了将近半年,不过现在还剩60天赶紧趁最后一期学完。 交一次费可以上重复上4期同样的课，个人感觉需要上两遍..我第一遍根本跟不上..第二遍现在才感觉速度刚好。 最后也祝愿各位小伙伴能找到自己喜欢的事情，也希望自己能继续坚持下去，完成这次的课程。~~]]></content>
      <tags>
        <tag>tutorial</tag>
        <tag>painting</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[维也纳的七日之行]]></title>
    <url>%2Fblog%2F2018%2F03%2F04%2Faustria-trip%2F</url>
    <content type="text"><![CDATA[HPCA’18圆满落幕，为了调整时差，回来的航班上也没怎么睡觉，看了三部电影..疲惫不堪的身体今天才刚刚恢复完毕。 不得不说在欧洲开会随便走走都是景啊，借着这次HPCA’18的契机，我也得以度过这充实的七天。虽然不是纯旅游性质，不过有去奥地利游玩的小伙伴也可以参考一下，价格默认都是欧元(€, Euro) 概况这次去维也纳是因为要去HPCA’18做Paper的报告，不过我只需要参加主会(只有两天半)，会议全程还有Workshop，得以申请到5天+前后各多1天共计7天的出差。 导师由于工作事宜而无法陪同，但是恰好这次HPCA1、PPoPP2、CGO3、CC4是在同一个地方开， 另一个同学F中了PPoPP的会议，所以我也能够有个同行的伴。 航班去维也纳的直飞航班不是每天都有，我这次来回都是在德国转机，虽然每次转机只留了2小时左右的时间，不过好在飞机比较准时也没有造成什么影响, 如果订机票的话强烈建议转机时间留足够长4小时以上比较好。 因为去欧洲的话会在第一个落地的地方入境，入境安检如果人很多的话会花很多时间，而且这次发现欧洲内部的航班真是不够准时，各种延误，所以留足转机时间比较好。 汉莎航空的航班全程是可以购买wifi的，65元不限时间只能发文本信息(WeChat、没图的知乎etc)的套餐，和其他价格更高能随便上网的套餐… 以及小伙伴的建议，国际航班尽量不要在携程、飞猪这种地方买，航班信息变动都不一定会告诉你的…还是查好航班去官网买最好。来回机票共计6000-7000，旅游淡季，红眼航班。 住宿国外的宾馆没有牙具牙膏拖鞋，洗发液这类东西最好自己也带上，不一定有瓶装水或烧水壶= = 也要带好转换头应对不同国家插座的问题。 会议酒店在Austria Trend Eventhotel Pyramide,在官网预定的。交通还是非常方便的，不过地方非常偏…坐轨道交通去市里需要30min-50min，不过酒店对面有奥地利最大的SCS Shopping Mall, 虽说可以买各种东西，但是真的贵啊… 一晚上88欧的酒店: 酒店的早餐就是普通的西式自助餐，各种各样的奶酪、芝士还有蛋卷、面包等等。 会议结束后我还去了趟萨尔茨堡(Salzburg)，在那边住的酒店是在Booking上订的 H+ Hotel Salzburg，一晚上87.87欧。 这个酒店的收费在周围的酒店里面属于比较低的了，早餐也非常丰盛。 关键是位居火车站门口，而且离这里的主要景点也不远，非常适合旅游的时候居住。 酒店能直接看到火车站，床也非常大。 酒店的早餐: 交通维也纳的公交分为轨道交通、火车、公交车等。轨道交通和国内的地铁差不多，U1、U2这样， 基本上覆盖整个市内，感觉是公家的。小火车都是S1、S2这样，是ÖBB管理下的。 公共交通只要随便找个自动售票机买个48小时卡之类的就可以随便坐了。 轨道交通有地上也有地下部分~ 通票的话只要第一次上车打一下就行，之后只要带在身上预防查票就可以了，所以买票全靠自觉..被查到没买的话一次罚100欧。 ÖBB还管理着Railjet这种长途的高铁，去欧洲其他国家的时候可以坐，网上有售票: ÖBB官网，和国内的高铁差不多。去Salzburg的话54.1欧/人。 如果只是要去奥地利的其他城市，也有WestBahn，双层高铁，可以上车后买票也可以在官网订好到时候让她扫码：WestBahn官网。这个的好处是买了票可以坐任意班次，一般一小时会有一班来往东西的列车，买这个的话比较自由不用卡时间，游玩结束直接坐下一班就行，而且相比Railjet便宜得多，去Salzburg的话26.5欧一人。我对比了一下，和国内的高铁速度差不多的。 ÖBB的Railjet以及Westbahn内的售票员 从机场出发还有专门的机场专线CAT，单人一次12欧。 行程Day 1由于坐的是红眼航班，从凌晨1点多上海起飞，München转机到当地的时候是中午12:00，外面大雪纷飞，零下几度.. 出来后就在机场吃了顿麦当劳当午餐。 在吃饭的时候刚好认识了一位来自中科院计算所同样去开PPoPP的同学， 我们一起等到同行的老师也到机场后就坐Uber去了会议宾馆。 Uber不需要手机也可以，上面可以与司机打字聊天。接我们的小哥是个约旦人，大雪天怀中抱着一个自己救助的受过伤的小狗狗， 人家十分聪明，过来看我们像是打车的，主动走过来领我们去他车那！！ 需要注意的是，中国移动的国际漫游是30元一天，4G不限流量，但是！由于流量会经过移动，所以还是会从中国大陆向外经过防火墙的..Google上不去= =；不过相对的，可以以中国IP访问一些只有国内才能上网站╮(╯▽╰)╭。 会议宾馆的服务员说话有口音，听起来稍稍有点吃力，入住洗漱完毕就去SCS采购了+吃晚饭了， SCS里面大概有400家左右门店，真的超级大… 晚餐吃的是一家日料快餐店，点的牛肉炒面打包，晚上修改Slides。 Day2早上完成了会议注册报到，吃罢早餐就去美泉宫转了，夏天去的话据说有很多花，不过冬天只能看到厚厚的雪。 中午在网红餐厅Figlmüller吃的炸猪排，(我吃的炸牛排)，这边的分量都超级大…总共28欧。 下午去地标St.史蒂芬大教堂玩了一波,教堂本身是免费游览的，里面有6欧一趟的电梯可以上教堂塔顶俯瞰维也纳， 运气好的话能看到没有因为维修而被围起来的教堂。 老教堂的庄严神圣依然如旧，不愧是维也纳的地标。 宾馆有泳池和健身房，一起的F同学去健身，而我继续在导师指导下默默改Slides… Day3这一天气温零下十几度！！简直不是人呆的地方… 而且周末整个城市就像我们这里初一一样，超市关门、商店停业，只有麦当劳依然是我们的好伙伴，能让我填饱肚子。 因为我的报到临近，这一天都在修改Slides，在下午交给导师最后一版后趁机溜到外面浏览了Hofburg Imperial Palace 霍夫堡皇家宫殿，也包含Sisi博物馆，门票十几欧。 这边是认可国内的学生证的，27岁以下的学生都能便宜个1、2欧，不过需要自己给他解释上面的中文是什么..她不认也没办法..好在我们学生证上有个xxx University，似乎还是认可的。 晚上乘坐了维也纳具有百年历史的摩天轮~ 这个摩天轮就亮相过理查德·林克莱特的《爱在黎明破晓时》，可以说为这座本就充满艺术气息的城市更添浪漫..已经能够脑补不少情侣在这秀秀秀了… Day4HPCA’18主会正式开始！HPCA General Chair Michael Gschwind、PPoPP 的Chair Andreas Krall与CGO的Chair 分别介绍三个会的概况。随后由体系结构大佬Margaret Martonosi (Princeton University)介绍量子计算机。主要目的是呼吁更多的人加入，因为量子计算机在15年内应该就可以商用..量子计算机现在需要一个纠错层来专门纠错，Margaret主要是提出根据不同算法构建不同架构，有点像现在LibOS一样的架构来提升其性能。 中午和舍友F屁颠屁颠地跑到市里吃了之前预约好的Ribs of Vienna，这最好的烤猪排！ 这家店是防空洞改造过来的，有400多年的历史了。。 顺带一张牛排~~ 剩下的时间主要就是听会与改Slides了。 Day5早早起来练了最后一遍Slides后就轮到我去讲，有惊无险超时20s完成报告Comprehensive VM Protection against Untrusted Hypervisor through Retrofitted AMD Memory Encryption回答完提问后这次维也纳之行最重要的事情也可以放下心来，开始放飞自我。继续听完我Secure Memory Session和后面一个Novel Architecture的Session并在宾馆吃完百年不变的自助餐后，我就兴冲冲地踏上了前往Salzburg的Westbahn火车。 萨尔茨堡作为音乐天才莫扎特的故乡其艺术氛围即使是维也纳也难以匹及，错综复杂的粮食胡同让我有一种在异国北京胡同穿梭往来的错觉。 趁着夜色未至，我一路走到要塞，坐着小火车(6欧多一点)上到要塞顶端鸟瞰萨尔茨堡。其中绿色的建筑便是萨尔茨堡大教堂。 晚餐在意大利连锁餐厅L’OSTERIA…至于吃的..我实在是不认识菜单啊…10样主菜，随便翻译下有意大利语、德语、西班牙语、挪威语和英语，没有英文的小字注解我也很无奈啊..但是这家据说是以其超大Pizza闻名的。 佛系随缘点餐，一共11欧😔 回去的路上还经过了《音乐之声》取景地：米拉贝尔宫 Mirabell Palace和其背后已被大学深深覆盖的米拉贝尔花园，(花园晚上看不清，第二天早上补拍的) 晚上的时间用移动的数据流量补看了动画…30元不限流量，还是国内IP不会被Bilibili墙掉。 Day6本来预计是想去海伦贝尔宫 Hellbrunn Palace的，但是那里只在4-11月开放，以Wate Play闻名，现在这冰天雪地水机关也无法运行，残念。 在萨尔斯这条带给当地人财富的盐河周边漫步，穿过画满涂鸦的地道，拜访了音乐天才莫扎特的故居。 不过实话讲非常不值…4间小屋摆几件乐器，音频解说90%的都在放音乐，还不如自己买碟， 可能对于学音乐人来说更像是一种朝圣吧。票价11欧，学生票9欧。 F同学的报告则是这一天的上午，Efficient Shuffle Management with SCache for DAG Computing Frameworks 乘坐WestBahn返回维也纳，与F汇合时已是下午14:00多了，离晚饭还有一段时间，于是我们去了维也纳1876年开业、 位于历史建筑Palais Ferstel一层的Café Central。 在那里点了两杯咖啡作为下午茶，一杯维也纳咖啡4.9欧.. 晚饭在维也纳一家有名的烤牛排Centimeter吃的~ 与F同学的师兄夫妇一起4人美餐了一顿。 当夜晚来临的时候，随着人流我们也来到金色大厅。 金色大厅是世界上最有名的乐团：维也纳爱乐交响乐团Wiener Philharmoniker的大本营，然而他们出去巡演了。 F同学的同学的伙伴是当地音乐学院的，在其推荐下我们买了大本营在金色大厅隔壁的，与爱乐乐团一起代表了奥地利古典音乐最高的演奏水准， 同时也是欧洲有名的乐团维也纳交响乐团Wiener Symphoniker的音乐会门票..用这位同学的话说，凭我们这种外行的耳朵是听不出来他俩之间的差别的，😓，坐票39欧2楼2排的位置。不过我们前面一排没人买，所以我们自觉地升到了69欧的座位…实际上感官体验大大提高，能够看到指挥和所有乐团人员的感觉比只能看到1/3的乐团人员的视觉效果要好的多。 在现场的感觉确实极其不一样，两小时的时光在不知不觉间就结束了。引用F同学的话说，这种现场的体验即使是万元的耳机也无法表现出来。 纵然余兴未尽，但已是深夜，我们回到宾馆洗漱完毕已经快0点了，收拾行李便睡下了。 Day7一早起来赶到机场搭乘飞机，在Frankfurt机场转机返回国内，为了调时差，在飞机上没怎么休息补看了战狼II、王牌特工1和王牌特工2 =v=。 加上直接少了7小时，第二天回国后也是飞奔宿舍立刻休息.. End其实奥地利还有欧洲最美的小镇Hallstatt可以去玩，但是时间原因没能去成比较遗憾。北边的布拉格过去也只要5小时，时间足够的话是可以玩的更尽兴的。 总的来说这次旅途非常充实和开心，会议的Workshop有两天使我多出来两天可以玩耍，当地的美食也让我这个不算吃货的人都赞不绝口， 与国内都是小姐姐的服务员不同，那边大部分都是绅士，举手投足间都展现着维也纳的优雅、从容与浪漫。 随处可以感受到艺术的氛围与人们的热情，英语普及率非常高，基本上问路的时候都能理解英语，公交也极其便利，而且误差从没超过2min。 只是冬天去看不到美丽的花草稍微有点遗憾，但7天下来非常的满足！ 备注 HPCA: International Symposium on High-Performance Computer Architecture (the 24th), 体系结构的会议 PPoPP: ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (the23rd), 并行计算会议 International Symposium on Code Generation and Optimization (the 16th), 程序分析会议 International Conference on Compiler Construction (the 9th), 编译器方面的会议]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 动画回顾]]></title>
    <url>%2Fblog%2F2018%2F01%2F05%2F2017-acg-summary%2F</url>
    <content type="text"><![CDATA[寒假将至，又到了总结一年新番的时间啦~ 想看番的小伙伴可以参考一下，这是小明为您带来的2017动画回顾兼推荐~ 里面有一些个人觉得真的不怎么好看的以及本人没有看过的就不介绍啦。 满分依旧是5分哦~ Jan.3.2 Urara迷路帖/うらら迷路帖-J.C.Staff 轻松日常的微百合番， 正直元气天然的主角和一起的3个小伙伴为了成为占卜大神而奋斗的故事。 大部分的故事其实还是少女们的微百合日常， 一个说的过去的Time Killer。 喜欢点兔、喵帕斯等观众老爷们可以选择补一发， 主角千矢还算小有名气，看到了不少画师拿这个摸鱼。 4.2 珈百璃的堕落-动画工房 依旧是日常系的番， 描述的是小恶魔性格的(香菜配)天使拉斐尔、 原本三好学生榜样、现在却因为网游而变成废宅的天使珈百璃、 认真仔细好人妻的恶魔薇奈特 和天然笨蛋的恶魔萨塔尼亚之间的搞笑日常。 相比较于Urara，珈百璃的堕落由于具有天使恶魔的设定， 所以在人物塑造上更加突出了反差萌， 因而也比纯日常的番更加好笑,推荐。 3.0 清恋-Studio 五组/AXsiZ 和圣诞之吻系列很像的番， 每四集描述和一个女主之间的恋爱故事。 只能说，男主如有神助，全程各种助攻， 即使各种错误操作也不影响最后走向人生巅峰。 硬伤在于从相识到恋爱要浓缩掉4集的时间里着实太短， 所以很多事情有一种强行顺理成章的感觉， 全程就是看狗粮了… 喜欢画风的可以看看，不喜欢的话看不看无所谓。 4.2 人渣的本愿-Lerche 从封面就能看出来的一部看车看的飞起的番， 描述的喜欢老师的男主和喜欢哥哥的女主相互将对方当做自己思念之人替身的故事， 本身男女主也是俊男靓女，所以在一起也避免了许多不必要的麻烦。 这部番的看点在于两人心理的描写和成长， 男主喜欢的老师和女主喜欢的哥哥之前的微妙的感情变化也是本番的看点之一， 在彼此的恋情都无法实现的情况下两人对恋情的放手方式也可以学习一下:) 描述的恋情从一开始就注定无法实现， 也没有强行加一些不符合逻辑的剧情， 到最后男女也是默契的分道扬镳， 整体剧情安排很不错, 推荐。 3.3 Hand Shakers-GoHands等 这番的分数完全就是靠声优和特效堆出来的， 但是说句实话，剧情是个什么鬼玩意？ 不讲剧情合理性的程度和K有的一拼， 打斗的时候也是华丽丽的特效堆叠， 但是经不起什么推敲， 没有算计、没有华丽的武打， 看起来就跟宠物小精灵对打的高级版一样十分无趣。 不讲为什么反正女主就是要和男主手拉手， 不拉拉抱抱本宝宝就要死的设定也是醉人的很， 个人十分不待见这部番， 但是里面有下作的乳量、有诱人的娇喘:) 诸君看着办吧。 4.6 小林家的龙女仆-京都动画 不得不说京阿尼的制作水准还是高， 即使是这种日常系的不需要多高成本的番但是剧情内容就已经能够为其盈利不少。 本番的剧情同样是日常搞笑番， 但是卖萌担当康纳简直是将卖萌做到了极致， 女主小林和作为龙的妹抖托尔之间温馨(惊喜不断)的轻松日常。 同人的话这个要比Urara和珈百璃多多了…果然康纳最萌了。 老少皆宜的番， 不过同样也没有太深的内涵， 高质量的Time Killer。 3.8 风夏-diomedéa 看番的时候甚至就有了“风学”的说法， 可以看出来和《白色相簿》之间还是有一些相似性的， 男主在女主之间的摇摆不定估计就是这个番的看点了？？ 描述的内容是男主优遇到了闪闪发亮充满魅力的女主风夏， 所以就被拉去组摇滚乐队。 同时从小就喜欢男主的另一女主小雪则是当红的偶像歌手， 三角恋啦… 唱歌什么的都是附带， 这个番由于我还追了漫画， 所以…我只能说作者在剧情上把控力还是太弱。 无论何时乐队遇到危机的振奋方式估计都是一样的吧， 但是每次的矛盾点总是感觉是强行找的一样， 而对于人物成长的心理描写也不到位， 乐队的维持感觉考得只是莫名的谜之振奋， 成员之间的矛盾都是像智商或情商的临时下线强行加的。 而乐队维持中真正的经费、灵感等问题， 解决的也过于随便了… 4.0 幼女战记-NUT 除了画风稍微有点奇怪以外， 剧情还是可以的。 描述的是一个不相信神存在的个人精英主义男主被神转生到了一个类似于平行世界二战时期的小女孩身上， (身体是小孩，头脑是大人，我就是——)， 女主作为类似于德国的军人不断在一线带队厮杀的故事。 里面因为有魔法的存在， 所以打起来女主所在的魔法中队在个人技术和指挥的带领下不断胜利， 最后和我们的历史类似， 虽然女主尽力想阻拦， 但是高层还是放走了盟军的投降人士(为之后的类·诺曼底登陆垫下基础)。 从头到尾都是神对男主/女主开的玩笑。 Apr.4.4 全职高手-视美经典 制作还算精良的国产动画。 讲述是的职业游戏玩家被商业运作而被逼隐退后自创战队重返联盟拿下胜利的故事。 原小说质量就很高， 中国的网络小说质量高的确实不少.. 不是种马文、不是后宫文， 剧情聚焦于职业选手和电竞比赛， 感情线没有过多着墨， 所以中心在战斗上的动画只要制作不偷懒都是很不错的， 难得一见的高质量国产动画，支持一个，安利一发！ 3.0 覆面系NOISE-Brain’s Base 女1喜欢男1，男1喜欢女1但是强行觉得自己不能够获得爱情， 为了替母亲还债按住心中的火花.. 男2喜欢女1，女2喜欢男2… 与风夏相比，这部番的重点就在人物关系上啦， 但是..你好歹是个音乐番看看你们这歌是什么鬼？ 真不是我审美不行，而是它真的没什么调啊T.T。 可以自己试听.. 4.2 月色真美-feel. 如果想看青涩稚嫩的恋爱故事， 那么月色真美完全符合要求！ 虽然画风一般， 但是对于感情的描写是真的细腻吖， 仿佛是冬天里淡淡的山药汤， 狗粮喂的你一小口一小口， 暖的你心坎都热热的。 中间没有节外生枝， 老哥告白完车技一直很稳， 一直开到结婚，没有任何翻车痕迹:) 3.5 王室教师海涅-Bridge 这番…剧情如其名， 王室教师海涅教四个王子的故事， 这个番感觉更适合中学小妹妹看… 五个男主在一起看起来只会Gay gay的， 剧情又是教育..这种太过正直、 又一本正经的番… 让我这个岁数的来看有点尴尬了… 但是番本身还是不错的。 3.5 从零开始的魔法书-WHITE FOX 典型的异世界轻小说类型… 白毛女主是个牛的不行的魔法师， 自己写了本书弄没了… 然后捡到书的人都能学会一定成的魔法， 魔法要泛滥啦！ 女主要阻止！ 和男主白虎= =一起的冒险故事。 剧情尚可， 画风尚可， 不过没有太多感情线的描写， 冒险剧情本身也算不上惊天动地， 所以平均水平吧。 3.5 爱丽丝与藏六-J.C.Staff 拥有强大力量但是心智还不成熟的爱丽丝和视为己出一般照顾她的爷爷之间的温馨故事， 不谙世事的少女在爷爷藏六的教导下慢慢学会了待人接物， 不在是一味依靠自己力量进行撒娇的傲气小公主了。 喜欢温馨治愈的小伙伴可以补这部。 3.6 埃罗芒阿老师-A-1 Pictures 男主小说家，女主插画师，剧情你已经能想象的出来了。 这部番之所以还算比较火的原因在于女主是妹妹..又是H漫画师， 稍微带点妹妹特有的傲娇， 加上男主这个妹控， 一下子戳中广大宅男的软肋.. 说真的，我最他喵的烦傲娇这种性格了， 撒娇可以，谁陪你傲(╯‵□′)╯︵┻━┻。 不过喜欢的小伙伴自然懂其中的奥妙。 4.5 Re:CREATORS-TROYCA 原创动画， 讲述的是人气作品里的男女主跑到现世来的故事， 其中反派一号白毛是已故男主的好朋友生前创作的角色， 所以她要毁灭世界替自己的作者报仇！ 最后再各个ACG人物和作者/插画师的一起努力下， 大家给了白毛归宿， 世界和平。 这部番的亮点，一个是泽野大大和小林的配乐， 一个是对于人物性格的塑造， 里面每个出场的ACG人物性格十分鲜明， 打斗也很华丽， 所以分自然比较高。 (我的小真鉴呢？作者你是不是把她忘了QAQ) 2.5 时钟机关之星-XEBEC 男主是机械痴汉，但是是天才。 女主是机械维修师，努力型天才。 两个人一起回收神秘的Y留下的机器人的故事， 整个世界靠齿轮驱动。 这个小说的作者原本是个插画师， 但是发现自己写的小说也不错， 所以自己写小说自己画插画… 本来还可以说是个正常的商业作品， 但是动画做的质量实在是太低, 导致… 2.8 不正经的魔术讲师与禁忌教典-LIDENFILMS 我知道这种自称自己这个弱那个弱， 然后开起挂来比谁都猛的番历来都有受众， 那个屌丝不希望自己能够逆袭？ 这是很不错的精神寄托:) 这番分更低的原因是逆袭也没开几个后宫， 圆梦也不说圆的大一些。 Others进击的女人，路人女主一如既往，喜欢的继续追就好啦。 Jul.4.7 舞动青春-Production I.G 所谓好的体育番是什么呢？ 个人感觉就是有男女主不断成长的心理描写， 有体育项目本身的渐进介绍， 能够在比赛的镜头中让观众激动不已， 沉浸感的塑造等等。 这部番除了以上的内容外， 人物本身的性格塑造， 对于很多抽象概念的表现拿捏的都很到位。 合理使用夸张来表现人物舞蹈时的肢体动作， 可以说各方面都是质量上乘的作品。 强烈推荐！看完会有一种自己当初也学跳舞就好了的感觉:) 教练我想学+1 4.5+0.5 终物语-SHAFT 哈哈哈，作为本人最喜欢的作品之一， 强行加上0.5分。 即使终物语不是物语系列里面最好看的一部， 我也依旧孜孜不倦的推荐给大家~ 如果是新入坑， 还是从伤物语(现在剧场版已经出完了)开始看吧， 顺便这里给新入坑的小伙伴们说一下观看的顺序: 伤物语(和小忍的因缘) -&gt; 猫物语黑(和羽川翼的相识)-&gt; 化物语(和战场原黑仪、八九寺真宵、千石抚子、神原骏河的故事)-&gt; 伪物语(和妹妹火怜、妹妹月火、贝木泥舟、余接、余弦的故事)-&gt; 倾物语(伪物语男主暑假被各种事情荒废，和小忍穿越回去救八九寺导致世界毁灭的故事)-&gt; 猫物语白(穿越回来后解决羽川翼·苛虎的故事)-&gt; 鬼物语(真宵没有成佛被暗袭击的故事)-&gt; 终物语·中(小忍前任过来找碴的故事)-&gt; 终物语·上(与前班长育的数学题故事..)-&gt; 囮物语(抚子被扇诱导变蛇神的故事)-&gt; 恋物语(战场原请贝木泥舟解决蛇神抚子的故事)-&gt; 凭物语(余接被送给男主，和正弦对峙的故事)-&gt; 终物语·下(男主被杀，到地狱拉回八九寺，自己复活重新和小忍连接的故事)-&gt; 终物语·下(解决幕后黑手扇的问题) 续·终物语(今年动画化，镜世界与现实交换的故事)-&gt; 花物语(骏河与蜡花篮球部的故事)-&gt;… 这是目前的动画，小说还在不停的出，里面很多时间线是相互交叉的， 但是因为不同的作品叙事者不同，所以即使不按时间顺序看也没问题！ 《化物语》在《魔法少女小圆》(同是SHAFT、同为新房昭之监督)打破BD销售记录前一直保持第一， 所以入坑从化物语开始是没什么问题的。 3.8 徒然喜欢你-Studio五组 大盘狗粮一盘接一盘， 喜欢看剧组发糖就看这个就好啦， 恋人直接的笨蛋对话和行为描绘的挺好的~ 4.6 公主准则/Princess Principal-2D 大河内一楼出品， 间谍们的生活， 女主和公主之间还有另一条线， 最后一集为了防止大河内暴走换了监督… 所以剧情是Good End啦，请放心食用， 最后一集也是因此剧情有点牵强。 但是前面无论是平时的校园日常、 执行任务时的间谍工作描绘的都很不错， 虽然个人感觉单论剧情比不上《代号D机关》， 但是有萌妹子补偿一点分也少不了多少。 强烈推荐，该番在国内因为没有被B站购买所以人气一般，在日本属于当季度霸权番。 3.6 捏造陷阱-Creators in Pack 真·百合番， 你问图片里两个男的？ 两个女主表明感情前都得找个男的对不？ 动画改了剧情， 是Happy End, 漫画嘛…原名里面可是有NTR的， 你也懂得。 所以想看百合的话只看动画就可以了。 3.5 Fate/Aprocrypha-A-1 Pictures Fate系列的又一部衍生作品， 但是恕我直言，这部是我觉得Fate系列里面最烂的一部， 主要是靠厨力和贞德阿福小莫在回本吧.. 剧情的设定上本来是不错的， 但是由于涉及到的人物过多， 使得对于剧情的把控不够。 很简单的一个对比就是， 《死神》里面的打斗总是团战， 这部一样， 因为团战不用花太多笔墨和脑汁去构造各个人物的剧情线， 加上制作不如Zero精良， 所以个人感觉So so. 3.6 骑士与魔法-8bit 这部番讲述的是作为程序员的男主转生到异世界异国， 由于对机器人的热爱， 男主沉迷于构建这个世界的战斗兵器(高达)。 这部番与其他异世界小说改的不同在于， 抛弃了爱情描写， 抛弃了尔虞我诈， 将重心放在对故事的描述和对打斗的刻画上。 观看起来更像是读动画版的历史， 剧情进展非常快， 不重要的事情直接一笔带过， 所以完整看下来感觉就是讲述了一个异世界的故事， 非常适合喜欢看物语类型(我这种喜欢物语系列的就是典型)的观看。 3.2 异世界食堂-SILVER LINK 不知道为什么， 这种没有任何深奥剧情的美食番却总是能吸引不少受众， 讲述的各个世界的食客来这个异世界食堂吃饭的故事… 真·美食番， 吃货的力量是强大的， 但是确实能看得下去， 可能这就是美食番独有的魅力了吧。 4.3 狂赌之渊-MAPPA 疯狂、妹子、读博、颜艺。 这部番囊括了众多能带来肾上腺素的内容， 所以看起来觉得爽也是能够理解的。 故事的主舞台是一个以赌博为核心娱乐的学院， 在这里钱就是一切， 女主不断把各种人拉人疯狂赌博深渊的故事。 加上对人物表情的细致刻画， 不用多想就能够知道这部番的精彩之处。 4.1 笨女孩-Diomedéa 俗话说永远不要和一个SB对喷， 因为他们会把你拉到和他们同样的智商， 然后用丰富的经验击败你； 同样，永远不要和笨蛋讲道理， 你也会被他们拉到同样的智商， 然后拜倒在他们疯狂的攻势下。 看这部番吧， 体验自己智商降低后在那傻笑的快乐， 聪明男主和三个笨蛋同学+笨蛋妹妹的故事。 4.5 欢迎来到实力至上主义教室-Lerche 社会我路哥，人狠话不多。 这是个问题儿的班级， 每个在这里的人都有一定的性格缺陷， 与《笨蛋测试召唤兽》那种过家家般的班级战争不同的是， 本番的班级战争有更多的算计和勾心斗角。 A班的两大帮派、B班单一领导核心、C班的强权政治、D班的幕后操作。 每个班级都有各自管理上的特点， 对于男主冷酷无情的刻画还是挺到位的。 这部番虽然是校园番， 但绝不是日常番.. 当季度的B站霸权。(我强烈认为是因为B站没买公主准则) 4.0 NEW GAME 2-动画工房 芳文社+动画工房这俩在一起就能想象的出萌妹子的日常， 相较于普通的日常番， 这部番和《白箱》类似， 能够让观众了解到一个游戏的制作过程， 虽然主要是从画师视角就是了。 人活着就是为了日富美！ 本身也是第二季，有爱的自取。 3.7 梵蒂冈奇迹调查官-J.C.STAFF 比较冷门的小众番， 讲述的是两个调查宗教奇迹的调查人员在确认奇迹真伪过程中的故事。 悬疑推理成分要更大一些， 如果对欧洲基督教又有兴趣那再好不过。 Oct.4.8 宝石之国-Orange 画风可能上来有些不太习惯， 但是这部番确实是部十分精良的番。 主要表现在对于主角成长的刻画、 对于人物直接关系的描写， 平常的每个小日常都不是无目的的拖时间， 每个事件都在推动主角的成长， 无论是身体还是心灵上的。 同时这部番描绘了朋友间分离的残酷， 不是过家家的打斗， 不是废柴的开挂日记， 也不是屌丝的逆袭日志。 它就是在讲述主角的成长， 造成主角成长的有对于前辈的向往， 有亲友的逝去， 有对挚爱之人的怀疑等等。 本番的思路也很清奇， 里面的角色都是宝石其本身， 所以也是无性别的中性。 敌方出场时的音乐也非常出彩甚至被观众姥爷们起了“敦煌乐队”这一称呼， 剧情也有非常戳泪点的部分， 而且看的过程中心中会一直十分忐忑， 并不容易猜出故事的发展。 强烈推荐！最后一集在B站登顶。 3.6 无论何时我们的恋情都是10厘米-Lay-duce 嗯，狗粮，吃吧。 只有6集的狗粮，对应的两个剧场版是里面其他几对的狗粮。 3.6 Just Because!-PINE JAM 嗯，胃药，吃吧。 虽然最后是Happy End， 但是十分不合逻辑。 按男主这算闷骚性格不应该是一路翻车么？ 想看翻车日记的看这部就好。 3.5 十二大战-Graphinica 物语系列的作者西尾维新的短篇小说改， 剧情上还是值得一看的。 但是这部动画化其实质量一般， 12个人互相厮杀到一人存活的故事， 有点像毒盅那种类型。 不过这部真的一般..一般.. 3.8 魔法使的新娘-WIT STUDIO 治愈系的动画， 讲述的是被收养的智世被艾利亚斯收养后作为魔法使的故事。 一个是被家人抛弃、将自己拍卖的人类女孩， 一个是化身为人类、渴望了解人类感情的怪物。 喜欢夏目友人帐系列的应该会喜欢这部作品。 3.0 如果有妹妹就好了-SILVER LINK. 我是真的不懂啊， 为什么一部作品只要扯上妹妹就能成为一部成功的商业作品啊啊啊？ 轻小说男主和他的其他轻小说狐朋狗友的故事， 剧情有点拖沓， 个人不是很喜欢。 这部作品甚至都没有详细刻画妹妹好么…倒是倒贴的妹子螃蟹公挺受欢迎。 3.7 犬屋敷-MAPPA 如果你喜欢看杀戮，那么这部分还是挺适合你的。 被冒失的外星人改造的两个人类， 一个选择从善， 一个选择从恶的故事。 男主是从善的老头， 反派是从恶的帅哥。 之后就是各种无辜人员的伤亡和对打斗的刻画了。 漫画原作者是画了《杀戮都市》的奥浩哉， 喜欢这种风格的可以看看。 3.7 牙狼/VANISHING LINE-MAPPA 和《犬屋敷》一样的制作公司， 所以对于打斗的刻画非常的赞。 这部番是画画老师推荐的， 让我们学习里面的分镜， 但是作品本身也还算不错。 不过这个社的作品..emmm感觉都不是很扣人心弦， 加上音乐没有泽野那种宏大的感觉， 所以总体分数一般。 3.4 此花亭奇谭-Lerche 和Urara一样少女们的日常番， 不过比Urara得分高一点是因为’萌’的更加突出，可能也有兽耳的原因。 在一个叫此花亭的地方少女们作为服侍接待形形色色客人的故事。 喜欢日常微百合兽耳的可以看看。 3.8 调教咖啡厅-A-1 Pictures 讲述的是一个角色扮演咖啡厅里的故事， 抖·S役向往外国的和系少女、 妹妹役的冷淡女大学生、 傲娇役的游戏宅、 色气姐姐役的18X同人漫画家、 偶像役的伪娘… 游戏宅的厨师加上笨蛋意大利人店长。 作为日常番， 和珈百璃の堕落类似，由于其中本身存在反差萌所以只是平常的日常故事就能使本作比较饱满。 喜欢日常系和反差萌的可以看看。 3.2 干物妹！小埋R-动画工房 有妹妹有反差萌就是可以为所欲为！ 在第一季大热之后动画工房果然做出了第二季， 在外是万象全能的大小姐形象， 在家是可乐薯条游戏不离手的干物妹妹… 这个季度的我已经审美疲劳了… 3.8 品酒要在成为夫妻后-Creators in Pack 泡面番(2min一集？)也是美食番的一种， 就是让你看妹子在喝了老公调的酒以后幸福的样子… 狗粮和鸡尾酒更配哦~ 4.8 我是江小白-两点十分动漫 十分不错的国漫！ 讲述的是选择性失忆的男主在成为编辑后开始负责一个海归女作家的作品， 在这过程中慢慢回忆起往事的故事。 作品的精彩在于将重庆的景色描绘的非常到位， 非常漂亮， 而且这是少有的在看动画时听着中文BGM毫不违和的作品。 故事本身也不单调， 男主的记忆与日常的工作两条线的交织， 对于重庆山城的精彩描绘等等， 这部作品在豆瓣上9.6的评分不是空穴来风， 强烈推荐。 4.8 RWBY-Rooster Teeth Productions 美国原创的日系动漫， 英文配音也没有违和， 剧情、音乐、人物塑造、战斗的描绘都很不错， 除了建模不够精细以外， 是一部很不错的动画。 讲述的是主角小队Ruby, Weiss, Blake, Yang (RWBY)作为女猎人的冒险故事， 有和动画剧情相对应的游戏在Steam卖。 End17年的番还是有好多高质量的(个人认为4分以上的)，如果寒假在家没什么事做的话可以参考~ 同时可以看到国产的番也慢慢多了起来， 其中不乏一些像全职高手、江小白这样的高质量作品。 希望国漫继续壮大~ 2018继续追追追,三年大会员已准备就绪=v=。]]></content>
      <tags>
        <tag>ACG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 Summary]]></title>
    <url>%2Fblog%2F2017%2F12%2F31%2F2017-summary%2F</url>
    <content type="text"><![CDATA[2017 年的年末突然朋友圈大家都在刷18岁..说好的永远的17岁呢？？? 过去的一年是比较顺利的一年， 在工作以后，希望遇到挫折和压力时还能想起现在的幸福感。 由去年的经验，今年有好好记录每一天都在做什么，总结起来也能更细致一些。 还是先来流水账~ 每个月最重要事当做标题好了~ 流水账 Jan. Fidelius-I/O的Design 晚上的时间大部分都在看1月新番，中间帮忙Review了VEE’17的一篇Paper， 项目上刚刚进行到I/O的设计部分，和聪聪确定了这方面的设计， 为了方便项目方便在家调试, 专门买了个小米智能插座可以在家直接开关测试机， 毕竟当时订的计划是寒假期间要做完..显然有些太乐观了。 22号的时候就回家了， 寒假刚回家， 主要就是和同学朋友聚聚餐， 看望爷爷奶奶姑姑姑父… 有时间的时候， 为了即将到来的实习笔试， 还刷了点LeetCode的题。 在家也是看番233，以及每年聚餐都有人记录安排，辛苦晓艳同学了！今年继续聚起来！ Feb. 沉浸在假期的欢愉中 预计寒假在家学习什么的都是想多了，在家肝舰R的冬活、还迷上了PandaKill， 加上自己作死重新看神之塔，基本上很快一两周的时间就被荒度了， 中间的正事也就是调调SOSP的网页这种琐事了。 一直到19号返校才开始继续着手项目的事情， 研究Event Channel和XenStore。 在家学会了煎饼和椒盐蘑菇，第一次的椒盐蘑菇还获得了不少赞哈哈。 椒盐蘑菇 and 家乡的白天鹅。 Mar. 決めた、华为 实现Fidelius的I/O部分， Fidelius项目的加密部分全部交给了LRF同学， 项目进度也能更快一些。 买了最新的AMD Ryzen 1700X处理器，配好了新的测试机！ 这个月花了将近两周在项目上，两周在刷题上， 投了华为的实习生招聘，最后也选择去了华为。 期间INESC-ID的Li Cheng来实验室给了一个有关找并发程序bug的Talk。 业余时间补了致幻游行、看了几场世界杯资格选拔赛，当个伪球迷~ 实验室上一届的硕士们到了毕业季也都选择了中意的公司， 恭喜LL、大树、施大神、彦哲。 Apr. 整牙日记Start 4月初就在达哥的号召下去团建了，去汤连得泡了汤，之后去竹若金枪鱼吃的饭，真的好吃！！！ Fidelius的项目实现的已经差不多了， 但是还是要在实际的AMD机子上跑起来，花了将近一个星期的时间考虑怎么用。 因为要准备写论文，就学习了一下Latex。 期间Yale 的大佬Paul Gazzillo来实验室给了一个Talk, 不是我的方向。 这个月还投了网易游戏的实习生笔试，也通过了后面的面试。 这个月做了一个非常重要的决定，就是开始去整牙， 从决定到拔牙也就3、4天的时间， 现在还是进行时:整牙日记(有一些图片，不适者就别点啦)。 我这种对生鲜不怎么感冒的人都拜倒在它的鲜美之下。赞美达哥！ May. Rush for CCS’17 拼了命的赶CCS， 各种加班加点的干活， 五一休息了两天就开始干活， 也是今年最拼的一个月， 晚上22:00之前没走过， 好几次都是23:00赶在宿舍关大门前匆匆赶回去的， 20号投掉CCS后整个人都要升华了。 期间普渡大学的Zhang Yiying来给了一个Talk, 关于RDMA的，这篇文章后来她们组发到了今年的SOSP上了:LITE (老师好漂亮的)。 之后就开始追梦了， 多方比较后，报了一个蓝铅笔的日系插画班… 本来想的是6月-9月刚好学一期.. 结果… 五月底的时候去父亲大人的工作地转了一圈， 之后去无锡给璇姐送行， 去的那天刚好是她男友生日.. 也没提前给我说，估计原本两人约会一天的，结果陪我玩了一天…尴尬 顺带去了惠山古镇、东林书苑。 惠山古镇，以及璇姐带我去的什么什么半岛…在江南大学旁边，记性太差没记住。 Jun. 开始画画！ 和实验的小伙伴一起去西湖玩~ 因为暑期要去华为实习，所以就提前请假回家了。 趁着京东6.18的时候给家里也新配了一台电脑， 旧的电脑在我的修修补补下从初二跑到现在也算功成身退了， Ryzen 1700 + 洪博的GTX 970， 就等过几天回家玩啦，咔咔。 回来后就在公司附近租好了房子， 上海房价好贵T.T，月租3000，实习工资根本不剩什么。 空闲时间拿了Ori and the Blind Forest全收集要素， 上画画课..学到透视╮(╯▽╰)╭ 西湖鸟瞰 and 租的酒店式单间公寓。 Jul. 菊厂实习开始 7月1号IPADS团建~ 当初不知道谁提出要吃榴莲披萨，大家就跑到美罗城吃了一顿， 下午kTV，晚上上上谦吃的火锅。 之后就是规律的实习生活， 期间收到了CCS惨不忍睹的Review评分后就着手准备投HPCA。 每天的生活过的挺规律的， 白天在公司干活，晚上回去画画，也就这一个月自己画的比较用功吧。。 实习的工作地点，也是毕业后的工作地点。 实习期间白天调板子，晚上画板子… Aug. 我司的日常.. 除了实习的工作， Fidelius投了HPCA， 国内的小论文开始疯狂赶， 聪聪入职华为~ 这个月的晚上基本上就是在赶论文了， 所以画画也是从这个月开始被慢慢搁置… 中间还有很多时间是在各种面试， 参加秋季招聘的提前批。 参加了公司的团建， 为数不多能看到导师在真人CS里的机会！ 晚上在新梅联合广场吃的饭~ 看着很帅，自己去玩简直要命.. 果然还是得锻炼啊.. Sep. 小论文一定要赶上！ 实习的最后一个月，早早答辩完后就在继续赶小论文， 同时进行HPCA的Rebuttal，属于比较平淡的一个月， 偶尔画两笔.. 中间回了趟实验室，发现装了一个花哨无比的水滴帘，现在已经被拆了，为了照这张花了好久去解那些扭在一起的珠子。 Oct. SOSP’17志愿者 十月主要就是在为SOSP志愿者的事情忙里忙外， 详细的可以看这篇:SOSP 2017 Volunteer 做小册子、更新网站、做易拉宝etc. 期间看看S7系列的比赛，说好的最有希望夺冠的一届呢??? 中间补了教父1、2两部经典的电影。 Nov. 亲爱的姐姐，妳嫁人了QAQ 11月的前半个月在广深香港浪， 去参加表姐的婚礼。 回来后一方面根据Shepherd意见改Paper， 国内的小论文也要交Final Version， 剩下的时间就是写毕业论文… 玩Steam的游戏也花了不少时间就是了。 11月因为参加表姐婚礼错过了班级毕业照和院系毕业照， 看着大家的毕业照片多少还是有些遗憾的… 详细的游记看这篇就好啦: 香港之行 Dec. lol, HPCA’18 Accepted! 12月主要就是在写毕业论文啦， 毕竟3W字不是那么容易就能写出来的.. Fidelius终于确定被接受啦~~ Great thanks to Haibo、Yutao and Ruifeng! 成功了申请奥地利的签证， 一转眼就到了年末。 Note今年是比较顺利的一年， 项目论文也在毕业前成功投了出去， 自己犹犹豫豫好久的整牙也正式开始， 一直想学的画画也是进行时。 最感谢的还是聪聪大哥， 在做Fidelius的时候帮了我好多好多， 最后的Paper执笔也主要是他完成的， 抱了一路大腿。 说说为什么选择华为。 其实在去年的时候我还是想选择广深的， 一方面像广州生活压力会小一点， 另一方面是有亲友在， 自己心里更安心一些？ 改变想法的契机是导师暂时去华为工作， 等到聪聪毕业决定去华为之后我就下定决心了。 从外校保研过来的我能深刻体会到工作环境、 周围的同学、老师、同事对一个人的影响有多么大。 导师领衔创立的部门人才云集， 可以趁机学习锻炼一波。 加上这个部门刚创立， 正好可以跟同事们一起搞个新闻， 所以感觉是一个非常不错的机会。 虽然对于前途还是有些迷茫， 不过最起码现在在这里感觉对自己的提升最大。 为什么现在了却选择整牙？ 本来我自己对于整牙这件事是个挺无所谓的态度， 毕竟这么长时间也习惯了。 但是突然有一天看到老大带牙套！ 我导师的导师在带牙套！ 这就跟你突然看到父母在带牙套一样震惊， 我年纪轻轻竟然就这么随意对待， 不行，我得去看牙医。 加上当时已经确定要留上海， 所以第二天就和父母商量， 第三天就去踩点， 第四天就交钱约时间了。 对于我这种非吃货， 带了牙套其实生活也没太大变化， 不过还要再矫正18-24个月 o(╯□╰)o。 研究生的生活也快结束了，再过三个月就完全毕业， 最近常常再看一些程序员的中年危机， 40多岁被裁员后简直像是被社会抛弃一样， 不由得自己也压力颇大, 还是要保持学习能力不断提升自己， 希望自己能成长为不被裁员的那批(笑)。 自己的知识面不能过于狭窄、仅限于专业上， 还是要接受各类信息。 今年的网络舆论被媒体带了一波又一波， 以前觉得看公众号那些二手资料是一种时间的节约， 不知不觉丧失了自我思考的能力。 以后还是要思考，花些时间看看第一手的书、经典的电影。 2018的Flag 今年依旧还是要每天记录一下今天做了什么， 总结的时候什么时候时间利用率低一眼就能看出来， 非常好用。 把画画学完。钱不能白交..5月底课程结束，我现在的进度是(24/43)，争取寒假搞定。18年要画至少4幅差不多的作品出来。 英语&amp;日语单词需要继续背..重新开启背单词… 希望18年能快速适应社畜生活www。]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在读学生申请奥地利商务签证(Business Visa)流程]]></title>
    <url>%2Fblog%2F2017%2F12%2F19%2Faustria-visa%2F</url>
    <content type="text"><![CDATA[由于HPCA’18在维也纳开，需要申请奥地利的商务签，这里记一下申请的经过以供参考。 旅游签要准备的材料应该会少一点，博主是在读硕士。 网站我最后走的上海签证中心，签证中心官网: http://www.austriavisa-china.com/chinese/ 所有要的材料在官网也有， 注意给的链接是商务签的，这张表到时候负责处理的人会那一份，我们自己不用带。 护照 &amp; 复印件有一点需要注意: 签证到期后护照的有效期至少 3 个月有效。如果护照快到期的话提早换新。 护照首页(带个人信息那页)需要复印两份，一份他们会送交使馆，一份会盖个章给你。 以往的签证页也都要复印，我当时上面只有一个日本的。 照片自己提前备好35mm 45mm, 正常的证件照 *2张。官网有一份指导 自己不用贴，他会给我们贴好。 照片还是最好重新照，因为不同国家签证要求好像不太一样， 我回来比对了一下虽然和日本签证的大小差不多，但是这边照片好像要求头很大的那种？？肩膀基本上就没拍到。 那边现场也可以照相，但是不知道收费怎么收。 身份证虽然要求里面没有，但是现场的时候还是要了我的身份证复印件，所以请带一份。 户籍证明一般户口本复印件就行，如果是集体户口的话，除了户口本复印件，还需要派出所/学校户籍那的户籍证明， 户口本只需要中文就行，但是户籍证明需要英文翻译版。我当时问了学校开证明的人， 不提供英文版..没办法最后交了一份户籍证明的翻译费。 婚姻证明单身，没交。 在读证明由于是在读学生，需要提供英文版的在读证明。 邀请函会议的话都是可以直接申请邀请函的，同样英文/德文版。 派遣函/出差证明学校的话在出入境中心可以直接要，我们学校是给模板自己改完他们盖章， 上面需要写清你的出行目的、经过的所有申根国等等。 我的那份上面还写了所有费用由学校担保。 营业执照/组织机构代码这个要中文版的！我辛辛苦苦备齐了所有材料想着一次交完，没想到人家说这个中文才是原件..要中文版的复印件， 真是心塞。保险起见也备一份英文好了，反正我中英都被收走了。 资金证明这个需要注意的是不能是信用卡，拉了半年的流水。 看到签证中心的人会把开的首尾日期、余额给划出来， 听说上面还是要有一些工资入账的记录比较好， 余额的话留个3-5w应该就行。 行程安排 &amp; 机票订单 &amp; 酒店订单由于我是开会..行程就是开七天会…..正常的话需要写清每天去哪，什么交通工具，尤其是涉及到多个申根国的时候。 机票订单和酒店订单，每个人一份，因为申请的时候是一个个来的，不能合一起。 同样是英文。 医疗保险我买的安联：官网，是个中德公司，保险金额不低于30万元人民币，须有进行保险索偿的可能性, 不能包含任何免赔条件，覆盖全程并超出1-2天。我是7天，买了8天的。100元。 申请表北京和上海的表不一样，上海的是这份。 填表的时候可以到网上找个模板，这里简单说一下。 所有内容除签字外一律用英文，在签证中心没发现有大小写的要求。 日期是 日-月-年 中间去其他申根国不属于出境，入境次数依旧写1 国内的报销这种，在外费用还是选 由申请人支付 地点日期和签名可以先空着，到现场了根据要求再填，感觉这种申请对日期要求很严。 签字都用的中文，我当时填的表也没说有什么问题直接过了。 申请表的邮箱最好和邀请信这里的邮箱一致， 我交完材料后很快就给这个邮箱发邮件提醒了。 费用所有费用请现金带好.. 签证费 未满25岁开会的可以免费，但是他们这里好像只有过一个参加模拟联合国的免过， 我这种参加学术会议的当时他们问使馆那边好像不予免费。471元。 服务费 我是在签证中心递交的材料，不知道大使馆/领事馆是不是不用服务费，但是听说签证中心不额外收取任何费用。170元。 翻译费 翻译是一份材料就75元，不管翻译什么内容。 快递费 快递用的EMS，65元。学校跑过去实在是太远了… 工作时间8:00-15:00，15:00之前只要排上号就行。早上去比较好，我早上去的时候一个人都没..下午交中文的组织机构代码证的时候十几个人在排队，还好补交材料不用排。 上交的手续交大的小伙伴如果开会的话需要先申请批件，在出入境中心的网站上点系统申报-&gt;因公出国(境)申请。 需要有邀请信、会议主页和自己要宣讲的论文摘要、导师的同意函(链接是学校的模板)。 批件一般整个要一星期的时间，可以在http://my.sjtu.edu.cn里面查进度。 派遣函需要自己在出入境的网站上下载模板，然后改一改。 中间在教务管理系统里面自助打印英文(申签证用)和中文(申户籍证明用)的在读证明各一份，在陈瑞球的三楼打印。 工作日期间需要去老行政楼一楼拿中文在读证明换户籍证明；去银行开流水(这个在银行自助开就行); 批件下来后在工作日内去新行政楼B的2楼那自助打印批件(只能打印一份)，拿批件在那(出入境中心)要中文的组织机构代码证，把自己改好的派遣函/出差证明给他让盖章。 然后就没什么了。 End只花了两天就出签了，也没有要求我去面试什么的，现在的效率还是非常高的。]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给新婚姐姐的信]]></title>
    <url>%2Fblog%2F2017%2F12%2F17%2Fsister-marriage%2F</url>
    <content type="text"><![CDATA[亲爱的童童姐: 亲爱的妳结婚了，很抱歉从没有参加过关于妳的什么活动，除去妳先我出生的两年我无能为力外，其他的24个生日我也没有盛装打扮，和妳的朋友们一起庆祝。在妳一生最重要的日子，我不想再留下遗憾，所以早早地定了票，备好正装，订好行程，送去我的祝福。 爸爸那边虽说我是最大的，不过表妹在照顾她亲弟弟的时间里成熟的远比我早，于是在妈妈这边四个姨一个舅五个表姐三个表哥的宠爱下，我后知后觉地走过了一条充满叛逆的童年之路。那时的我只知道我有一个和我年龄最近的姐姐，一个可以在哭的时候依靠的姐姐。虽然结果是调皮的我竟在那找妳麻烦，自己倒也没哭。 因为住址较远的原因，相比较成成, 我和妳一起玩的时间没那么多，不过就算是现在还是可以记得妳在小学当老师教我们乘法；在我家一起玩松鼠大战；目惊口呆地看着妳随意的点播电视里10元一次10min的猫和老鼠；再后来一起玩宝贝坦克；有段时间住在妳家时看妳养小乌龟…… 细数下来都是些微不足道的回忆，而后就是看着妳作为榜样拼搏奋斗的身姿了。说这些是因为我不想再被提起的时候只有“拿(nǎ)走(zōu)，拿(nǎ)走(zōu)”这种黑历史了，就像我不想每次都只能被我妈妈想起我嗷嗷“我要吃蛋(dán)糕(dāo),呜呜呜”一样。 以后的妳长住在地球的另一边，我也深知见面的机会更少了，不过直到今天我也有个习惯是因为妳养成的。初中借你书(叫什么什么海)作为摘抄用，经过了半个学期后蔚蓝海水般的封皮被我蹭的白一块青一块，妳一句“天啊，你对我的书做了什么！”让我至今难忘。从此我借别人的书都会先包一层书皮，硬质的翻页夹角不会超过90度…… 在现在有了自己心爱的硬件设备后我已经可以深深体会到自己心爱的东西被不慎重地对待时的那种悲痛了，虽然晚了好几年，这里还是要说一句对不起和谢谢。 我看动漫也是被妳带入坑的，只不过如今越来越多的角色成为我花嫁时不知道妳还能不能想起来你当初喜欢的那个火影里的雾忍，白。我学习上也收到过来自妳不小的压力，压力大到能让一个初中班里倒数第一的小屁孩最后考上和妳一样的高中，到现在能不用劳心毕业的事情有这闲情逸致在这敲这些话，可见这压力有多么可怕；想着好不容易马上就毕业的我，看着披上婚纱的妳，望着天天被喂狗粮的自己，看来自己还是得再喝几年的苦茶了。 第一眼看到姐夫的照片时我还忿忿不平，天天给我们说有女朋友了要给妳说让妳验验， 但是突然就把姐夫的照片Po到朋友圈了，我们作为弟弟还没验过呢，作为弟弟的尊严何在？ 不过姐夫是Google工程师，还是大学霸…惹不起，惹不起。虽这么说， 但是IT的男生确实很不错啦，以我自己作为参照，没问题的。 意外的是电脑小白的妳竟然会找IT业的姐夫， 在为同样是IT男的自己是不是也能找到像姐姐妳一样女神的妹子而欢欣鼓舞之时， 也为以后不再被需要解决妳电脑方面的问题而感到些许的惆怅。 婚礼时的妳很漂亮，与生俱来的气质随便在哪张照片上显得都很美丽， 看着神圣的仪式举行的时候， 不知道为什么我自己也有一种“啊，我的女神姐姐嫁出去了”的感慨， 真的担心比我还瘦的姐夫能不能抗住以后的风风雨雨。 不过一想到当初那个端个盘子都晃晃悠悠的姐姐竟然也变成了大厨时， 这种担心也烟消云散了。 成天自负不得了的自己还只会泡个面、下个饺， 着实没什么资格有这种担心。 婚礼的结束才是开始， 是你们二人携手共进的开始。 我觉得结婚后不是0.5+0.5=1，什么在一起才完满云云; 是1+1&gt;2，希望你们一起能创造出更绚烂的光景， 但即使是妳一个人的时候也依旧能生活地井然有序。 听到姐夫说他每天工作下班都希望快点回家， 都希望能看到那个活蹦乱跳的妳时， 我能深深感受到姐夫对妳的爱, 希望你们今后也能充满激情， 保持现在的这份感动。 姐夫和我一样是程序员， 程序员单纯，也死脑筋，爱讲理， 给人印象是智商高但不修边幅， 面对不按套路出牌的东西会惊慌失措。 我想，克服这个是一个程序员、一个婚后男性成熟必经关卡， 我自己也依旧摆脱不了这些， 如果姐夫因为这些和你闹矛盾了， 妳就稍微让着他点， 毕竟他也没毕业几年， 所谓的成熟、稳重这些素质还是需经风雨洗练的， 也能显得姐姐妳的大气。 两个人在一起久的的话想必会出现一些摩擦， 希望你们能互相包容， 让这些摩擦出火花成为你们爱情的催化剂。 但是，如果受到欺负的时候请不要忘记妳身后还有我们， 遇到任何困难请不要闷着不说， 起码我还是可以出谋划策贡献力量的。 听闻妳为了婚礼减肥许久， 不过即使是在以后的日子里还是要注意锻炼和饮食， 为了身体的健康， 我也想一直看到那个美美的妳。 也请妳帮忙向姐夫转达， 让他多多运动，加班适度， 保持浪漫~ 有时间了记得回国看看， 我也会去美帝看你们的。 再次祝福你们新婚快乐，恩恩爱爱，幸福一生~ 爱你的弟弟，明明 2017-12-17. === P.S. 其实这个应该是在婚礼的时候给妳的，不过当时行程匆忙，没看到婚礼时情感也没酝酿好，所以就拖到现在了&gt;.&lt;。]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[香港之行]]></title>
    <url>%2Fblog%2F2017%2F12%2F10%2Fhongkong-trip%2F</url>
    <content type="text"><![CDATA[半个月前从香港回来的，参加了姐姐的婚礼后去深圳和好友G聚了次餐，之后就到香港在好友S老司机的带领下玩的非常充实~ 香港的价钱都是按港币算。 准备工作 港澳通行证 在上海的话港澳通行证只用一个身份证就可以办了，而且上海有个人旅游(G)签注，所以过关也不需要跟团。 即使办的是电子的卡，但是第一次过关的话依旧需要走人工通道，以后才能走电子通道。 酒店 香港寸土寸金，所以在网上搜的宾馆一般都是民俗·改，由于同学在中环那一块繁华的地带，所以考虑到安全问题直接定了一个感觉比较靠谱的酒店: 香港富薈炮臺山酒店(iclub Fortress Hill Hotel)。携程上支付用储蓄卡就可以。 酒店里面没有拖鞋，而且洗发露这些也不好，所以记得自备。 过境 &amp; Bus 由于我是先去深圳找表姐和同学了，所以过境的时候走的深圳湾。 即使不走深圳湾走其他的过境也类同， 需要注意的是，巴士的票是在过境之前买！在入口处两旁就有卖去各个地方的巴士票，提前买好， 过境之后就是排队了。 巴士票 坐巴士时穿过的长长的桥 过境 &amp; 直通车 过境还可以直接坐高铁，在广州 or 深圳都可以直接坐到九龙，叫做广深九直通车。 买票可以在大陆用人民币买，也可以在港铁的官网用信用卡买， 因为我是回程所以在同学推荐下在港铁买的。 港铁的官网:港鐵城際直通車網上購票服務 取票用的是自己的信用卡。 先坐车后过境。 九龙到广州，双层的高铁！ 纸质的票 转换器 香港的插座和国内的不一样，记得带上转换头哦。 八达通(Octopress) 香港的一卡通，可以到那再买，随便的seven-eleven等便利店都有， 用处比国内的交通卡更广一些，我们后面去坐的小火车也用到了，也可以提前买好再过去。 冲的钱可以退掉。 港币 其实港币不用带多少，那边的信用卡非常发达，和上海这边的支付宝差不多了，所以我当时换的其实偏多了。 香港的港币发行商有四个，大额的有三个银行，挺神奇的。 不同发行商的港币 日程一共玩了三天，周五到，周日下午走。 Day 1到的时候已经是下午了，入住之后就出来逛，在中环附近的一个小公园转了转，晚上去了有名的兰桂坊喝酒跳舞~ 因为第二天有行程，所以晚上也只是稍微喝了一点点，没有浪的飞起。 公园 兰桂坊 #### Day 2 去逛了香港比较文艺的原创方，很多创意工坊。 中午去茶木吃的甜点(中午不饿…)， 下午坐小火车爬的太平山，和不恐高的人一起登高十分开心。 小火车和山顶的露天观景台可以用八达通购票， 车票来回 75 * 2港币， 观景台50港币。 小货车内 小火车外都是斜的.. 全程45度爬坡 俯瞰香港维港 观景台还是推荐去一下，个人很喜欢这种俯瞰的感觉。 晚上坐了星光小轮，香港的特色小轮之一，超级便宜…2.3HKD…2元钱坐船有没有！就是有点冷… 之后我们去了星光大道，逛了各种奢侈品店..单身汪的我根本不认识那些牌子啊！！！果然程序员需要在这方面学习一下， 看着S同学对牛弹琴的无奈，我也…只能…无言以对。 维多利亚港的夜景~ 回来坐的地铁，星光小轮太冷了…还饶有兴致地坐了有轨巴士，也是双层的~ 依旧坐在2层，英占时期的产物之一吧。 #### Day 3 第三天早上专门和老太太老爷爷们一起吃了港式早茶，经典的莲香居！因为我中午要赶火车，早上人暴多，需要自己找位置，找不到位置的时候心里还是蛮紧张的。 港式早茶，@莲香居 之后去买了超有名的珍妮曲奇小熊饼干，毕竟想找点Made in hongkong带给实验室的小伙伴吃。 之后去红磡(九龙)坐的广九直通车回的广州，再回上海。 转车的时候还看到了记不住是哪个大学电子系的挑战杯队伍，做的智能车。 End 闪闪发亮的高楼大厦， 一栋有趣的客栈 这次由于我自己主要是去广州参加婚礼的，所以香港的行程就直接拜托给了超级宇宙无敌靠谱的S同学， 也确实在老司机的带领下把能玩的都玩了…我自己的话一定不会知道去做星光小轮和小火车的, 在这里对S同学表示感谢。 现在大陆已经发展的很不错了，尤其是还在上海生活了两年，以现在的眼光去香港也体验不到当初的辉煌。 看着鳞次栉比的大厦，能够看出来老香港的底蕴， 但是看着那拥挤的楼盘，感觉香港的发展空间也差不多被榨干了…]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 SOSP Volunteer]]></title>
    <url>%2Fblog%2F2017%2F11%2F21%2Fsosp-volunteer%2F</url>
    <content type="text"><![CDATA[由于之前一阵忙+偷懒，今天终于想起来把志愿者期间的工作补上了。在9月底实习结束回到学校后，经过一轮十一的休假，还没开始怎么写毕设就投入到了SOSP‘17的各种志愿者工作中，一直忙到了11月2号。 PreparationWebsite会议期间的网页其实就是用html写的静态网页，没有任何技术含量，当时可能正好我有空就让我负责管理了，前前后后一直不停更新，目前也还在不停往上放slides和videos。总的来说，下次还是准备用个静态框架，没有用框架造成的后果就是每次更新菜单都要我一个个页面挨着更新，还好vim有宏可以比较方便完成这些操作，但是还是不容易管理。会议的主页~：http://www.sigops.org/sosp/sosp17/ 由于第一次在中国举办，所以临时花了几十分钟还弄了个丑陋的中文版，估计也没人看= =。配色也是参考了2013年SOSP网页的配色和布局。 Pamphlet 十一回来后就被斌哥抓去做这个小册子了，参考了FAST’16的小册子自己第一次尝试用Adobe Illustrator来排字体，总体感觉就是个苦力活，各种调啊调，做到最后都快吐了(真正意义上快吐了)，本来打算十月写毕设，也是因为这个东西基本上泡汤。 以及不得不吐槽，会场地图竟然没有英文版，上面的英文全是我自己YY翻译的，后来跟实际的一对照，发现好多楼的名字还是翻译的有问题。以及，为什么房间名叫“北京”，叫“上海”？？我在会场遇到好多问workshop为什么是在北京开的人了。。。 Rollup 由于会场上每个房间外面要摆个易拉宝，所以做了小册子的我当然也没逃过做易拉宝的命运，当时时间过于紧张，所以用PPT赶做了一个模板，并让其他小伙伴帮忙做其他日期的。说真的，我到现在还想吐槽为什么斌哥不多找点人…累死本少了。 Certificate 对啊，你没看错，我们的志愿者证书竟然是自己做的！惊!而且又一次是我。因为模板是ai，正好我前段时间用了ai，这个是在会议期间赶做的，然而到今天都没发下来。本来想着证书发下来再写这篇日记，看来是没戏了。 Badge &amp; Package 10月27号, 会议开始的前一天，我们一行人来到香格里拉大酒店开始装package，为了提高注册时的体验，提前准备工作当然是必不可少，晚上随便吃了点后就进行分装名牌的工作。 名牌由于是提前打好的，在决定我们打算按Last Name分组进行注册时，前一天晚上我们在香格里拉大酒店的礼宾房里分装名牌，由于早上6点多就起床，当时真的是又困又累。 ConferenceDay 1 第一天也是最为忙碌的一天，缺少经验的我们想要做好却问题频出。加上我们也不熟悉宾馆的路线，被参会人员一问三不知，我们准备的invoice也由于失误造成第一批全部印错。对于On-site注册的人士，我们没有记号笔，只能尴尬地让人家在白纸上写上自己的名字。说真的，热锅上的蚂蚁… Day 2 第二天才是正式会议的开始，而第一天遇到的问题也相应得到解决。从借助胶带现场印名牌到直接用打印机打印名牌，记号笔和更正后的invoice… 第二天虽然忙碌不过也都井井有条。可能因为第一次在中国开，所以谨慎的外国友人们注册的都比较早，因而他们的注册都很顺利, 主要是一些现场注册和较晚注册的由于我们没有提前备好名牌造成的耽误。 到了晚上，我们已经像流水线里的熟练工一样能够快速完成注册、应对各种突发状况了。我也有空来到Grand Ballroom外的露天花园眺望浦西。 Day 3 早上一起来发现上海有自行车赛，道路各种被封，出租车过不去我们只能绕天桥。也有机会拍一张~ 也有机会进去听跟我相关的talk, 会场还是比较大的~ 比较气的是各种合影我都完美错过，无论是我们自己的合影还是和大佬们的合影，我都恰好因为各种事情当时不在场，这里盗用一张小伙伴拍到的野生Nickolai大佬的照片。(一个人出现在4篇里面…) 我们也是有空出来吃一些好吃的~ Day 4最后一天主要是在解决一些国际友人的旅游问题..有不能翻墙让帮忙下地图的，有问火车票信息对不对的，有办电话卡的，以及各种旅游相关的问题。不过有接机的同学帮忙所以我们这边其实没太多事情。遇到的问题是名牌不够，挂绳不够等… 最后下午是和报名的人一起游玩，我是跟浦江游的队伍。(和图灵奖得主一起游船的机会可不多吖) End 首先还是要感谢海波导师，没有他SOSP也不会在50周年第一次来到亚洲、来到中国！虽然平日不拘言笑，牛人还是牛啊。 作为Local Arrangement的斌哥可以说辛苦至极，虽然我们跟着也没多好受，不过拼过累过最后才更能品出圆满完成时的喜悦。 IPADS的部分大佬们，大爷带着不用赶Paper也没参加志愿者的博士们过来围观← ← 云昊同学的出色工作，在本科期间就能够在此等会议上发论文，未来的大牛已然抛下了我等渣渣。是时，云昊同学已经在Cornell了，还专门回来开会😂 Sub-millisecond Stateful Stream Querying over Fast-evolving Linked Data 曾经的IPADSer乃正, 现在在NYU，虽然对我这个后来才加入的人来说不熟悉，不过看着学长们的实绩，自己也是怕的不敢说话。Best Paper之一The Efficient Server Audit Problem, Deduplicated Re-execution, and the Web 楼畅和思源同学的Poster~ 也是实验室分布式组RDF相关工作的又一延续，我这个虚拟化与安全方向的就凑凑热闹哈哈~ 我的第一次国际会议参会，也是一次特殊的参会，作为志愿者，从现场外的工作到现场内的接待，到会议完成的现在还在邮件来邮件去，也是深刻体会到办一个会议的艰辛，更不用说要操心各种事情的导师们。 最后还是恭喜SOSP17的圆满成功！(P.S. 上面的照片都没我，不用找了)]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kvm Log 5-Create QEMU-kvm Guest on Hikey960 (ARM64)]]></title>
    <url>%2Fblog%2F2017%2F08%2F29%2Fkvm-log-5-create-guest-on-arm64%2F</url>
    <content type="text"><![CDATA[This post is about booting guest using qemu-kvm. Guest ImageLike create domU on xen, you still need to prepare a guest image including guest kernel, bios image. For qemu image on arm64, you can download it from official site: 12wget https://releases.linaro.org/components/kernel/uefi-linaro/15.12/release/qemu64/QEMU_EFI.fdwget https://releases.linaro.org/components/kernel/uefi-linaro/15.12/release/qemu64/QEMU_EFI.img.gz Build QemuGet qemu from source on hikey960 (I recommend to compile on board directly if you dont want to handle those annoying libs 1git clone http://git.qemu.org/git/qemu.git If your guest is downloaded from above link, set target as aarch64-softmmu is enough. Config qemu and compile it: 1234# ./configure --target-list="aarch64-softmmu aarch64-linux-user" ./configure --target-list="aarch64-softmmu" makemake install Run Guest1taskset -c 0-3 qemu-system-aarch64 -m 1024 -M virt -cpu cortex-a53 -smp 4 -bios "/path/to/QEMU_EFI.fd" -nographic -device virtio-blk-device,drive=image -drive if=none,id=image,file="/path/to/QEMU_EFI.img.gz" -enable-kvm Currently, Cortex-A73 is not supported by qemu, we have to pin vcpus on cortex-a53 via taskset -c 0-3 (cpu 0 - 3 are all cortex-a53) I dont have a screen to show results, that’s why -nographic is needed. -enable-kvm to let qemu make use of kvm to boost guest. Now you should boot guest successfully.]]></content>
      <tags>
        <tag>tutorial</tag>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上海百度校招2018面经]]></title>
    <url>%2Fblog%2F2017%2F08%2F29%2Fbaidu-interview%2F</url>
    <content type="text"><![CDATA[找学长内推了上海百度的团队，团队主要负责人工智能的全栈支持，依旧是比较底层的研发部分。从AI芯片、 到平台再到上层对百度各个部门的支持。本篇记录一下面试的经历。 简历还是之前准备的简历，由于投的都是研发所以也不怎么需要修改。没什么需要再说明的. 一面一面技术面更多的变成了对于百度内业务的介绍，主要还是在了解团队具体在做什么，这里不方便太过详细的介绍就略过了。 不过一般一面也不难，简单的算法数据结构加上一些操作系统知识都不难应付。 二面二面是团队里另一个人的技术面，算法问的是给一串整数，再给一个数字，求这些整数里面有多少满足条件的数对(a, b)，使a+b等于 给定的这个数字。 非常简单的算法题，排序+一遍遍历就可以，O(nlogn)的时间复杂度, 遍历的时候从两边向中间。 之后主要是操作系统的相关知识，在了解了我所做的项目内容后，考察进程管理、内存管理等。这些之前的也都问到了，所以基本上还是把自己所知道的内容答上来就行。而后又问了些slab和buddy system的相关问题，这些不是很难简单说下就好了。后面又问道一个Red Zone，不过这个我没用过所以就没答上来。 Red Zone 是 rsp下面128bytes的空间，可以被最后一个被调用的函数所使用，这段空间不会被exception/interrupt等Handler所使用，因此这就意味着最下层的函数可以利用这部分空间进行优化。对于RedZone的使用不需要改变RSP，因此可以减少一些开销。但是Redzone仅在rsp-1到rsp-128。所以push、pop以及function会改变red zone的位置。 之后又问Spin lock、Semaphore和RCU之间的区别, 这些具体的自己去搜一下就好。在问到spin-lock的时候，就又问到了spin_lock_irq和spin_lock_irqsave. 对比可以看这一篇 From Robert Love’s book “Linux Kernel Development”, if interrupts are already disabled on the processor before your code starts locking, when you call spin_unlock_irq you will release the lock in an erroneous manner. If you save the flags and release it with the flags, the function spin_lock_irqsave will just return the interrupt to its previous state. 如果在关中断情况下使用lock, 之后使用unlock会导致一些问题. 之后围绕中断问了非常多的问题，主要考察中断的实现，硬中断、软中断(Timer中断这种)区别，tastset又是什么(软中断的一种)。 中断的处理过程等等。由于我自己回答的时候比较了和调度的区别，因此就继续问我中断能否被调度，在中断处理过程中如果sleep让调度器进行调度会有什么效果？(中断的栈用了进程原有的栈，如果被调度的话栈会崩). 继续又问如何才能实现能被调度的中断，支持中断里面sleep？这个真是把我问蒙了，不过从实现上进行考虑至少可以说出来一些点，比如满足调度的话必须有自己的上下文，而且需要维护这些上下文，和Process原有的栈分开等等。这些东西还是需要了解调度单位的本质和中断的目的和实现才能答一些，后来也是在面试官的帮助下我也是学习到了不少。 整个面试过程不到40min。 总结研发面试关注的还是对于事物本质的把握，如果是考算法不但要会用，还要知道背后的实现原理，同时还要继续了解背后实现的设计原则。当然，一切都要先以会用为基本要求，所以还是要先刷题补一些常见算法再说。 算法的面试可能是因为我是系统工程方向的，被问到的都不是很难的算法(也有时间的原因)，正常情况下这些是笔试中会考察的。所以，主要还是了解常见算法即可。 如果是工程方向，对于系统的理解要尽可能深，书本上一般上学到的都是一些实现方法，但是具体实现还是需要自己去了解，而Linux这一成熟的操作系统所使用的诸多设计我们还是需要去深深理解的，我就属于见识还是太少… 有时间还是要把Linux Kernel Development 和 Linux Kernel Primer看一下…]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVM Log 4-kgdb KVM on Hikey960 (ARM64)]]></title>
    <url>%2Fblog%2F2017%2F08%2F16%2Fkvm-log-4-debug-kvm%2F</url>
    <content type="text"><![CDATA[kvm因为是和qemu一起跑的，想必网上搜出来的都是用QEMU-gdb去调试kernel, 本文记录的则是利用kgdb调试kvm module, 利用gdb调试qemu-kvm, 这样就能够在串口调试的基础上更方便的追踪程序的执行流了。 Configuration我用的是Hikey960的板子，里面有4个Cortex-A73和4个Cortex-A53的核，ARMv8, aarch64的架构。QEMU用的4.10.2 Run qemu-KVM需要注意的是目前Cortex-A73还没有被支持，所以直接跑的话如果vcpu被调度到A73的核上那么是会崩的, qemu会报不支持的cpu类型，所以我们要用taskset来指定线程被调度的核(0-3是A53, 4-7是A73) 1taskset -c 0-3 qemu-system-aarch64 -m 1024 -M virt -cpu cortex-a53 -smp 4 -bios "bios.fd" -nographic -device -virtio-blk-device,drive-image -drive if=none,id=image,file="disk.img" -enable-kvm Debug QEMU-kvm首先我们要下载qemu的源码并编译，之后只要正常用gdb调试程序一样即可，不过依旧要注意的是使用taskset来绑定核: 1taskset -c 0 gdb --args qemu-system-aarch64 -m 1024 -M virt -cpu cortex-a53 -smp 4 -bios "bios.fd" -nographic -device -virtio-blk-device,drive-image -drive if=none,id=image,file="disk.img" -enable-kvm 这样启动后只要使用run就可以执行qemu-kvm了。 Remote kgdb kvm module与调试Xen遇到的情况一样，由于kvm是Hypervisor，所以不能放到qemu里面去调试，但是与Xen不同的是kvm属于Linux的一个module, 这样我们就可以借助kgdb来调试kvm module部分的代码: 参考了: Reference target ARM Board (e.g. Hikey960) Host LinuxPC (e.g. Ubuntu) target is connected to host via Serial (e.g. ttyAMA6 of target &lt;—&gt; ttyUSB0 of host) 在这之前请先保证Host可以通过串口连接target~ Enable feature in kernel config:1234567891011121314151617181920CONFIG_KGDB = y/* Enable kgdb support */CONFIG_KGDB_SERIAL_CONSOLE = y/* Allow serial to debug */CONFIG_DEBUG_INFO = y/* Including debug info */CONFIG_FRAME_POINTER = y/* Using frame pointer to maintain stack for traceback */CONFIG_MAGIC_SYSRQ = y/* We can use echo &quot;g&quot; &gt; /proc/sysrq_trigger to break kernel */CONFIG_DEBUG_RODATA = n/* No readonly data */CONFIG_DEBUG_SET_MODULE_RONX = n/* No readonly kernel code */ Recompile kernel and reboot target Reinstall kernel modules Target 12345678# you can add linux_cmdline arg: kgdbwait kgdboc=ttyAMA6，115200# to break kernel at startup# or using:echo ttyAMA6 &gt; /sys/module/kgdboc/parameters/kgdboc# then break kernel:echo g &gt; /proc/sysrq-trigger 我的板子用kgdbwait并没有什么效果..所以最后还是用了sysrq-trigger的方法来暂停kernel Host 1234567apt-get install gdb-multiarchgdb-multiarch vmlinux (cross-comiled)#(gdb) set_remotebdevaud 115200(gdb) target remote /dev/ttyAMA6remote debugging using /dev/ttyS0 Remote Cross-debugging pogramYou need to ensure target can connect to host via Network Target 1gdbserver :port ./program args Host 12gdb-multiarch ./program (cross-compiled)(gdb) target remote target_IP:port 之后只要在Host上使用对应的gdb命令就可以调试运行在target上的Kernel(kvm module)了. めでたしめでたし~]]></content>
      <tags>
        <tag>linux</tag>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVM Log 3-KVM Workflow (ARM64)]]></title>
    <url>%2Fblog%2F2017%2F08%2F15%2Fkvm-log-3-kvm-workflow%2F</url>
    <content type="text"><![CDATA[本篇介绍kvm自身的执行流程，以及与qemu的交互。kvm的代码本身分为两部分，kernel态代码作为kernel module虚拟出一个字符设备，qemu通过对/dev/kvm发送ioctl来实现与kvm的交互。 KVM IOCTL在上一篇中提到过kvm作为加速器的初始化，不过没有详细说，那么首先我们先看看kvm的初始化。 $QEMU/accel/kvm/kvm-all.c12345678910111213142607 static void kvm_accel_class_init(ObjectClass *oc, void *data)2608 &#123;2609 AccelClass *ac = ACCEL_CLASS(oc);2610 ac-&gt;name = "KVM";2611 ac-&gt;init_machine = kvm_init;2612 ac-&gt;allowed = &amp;kvm_allowed;2613 &#125;26142622 static void kvm_type_init(void)2623 &#123;2624 type_register_static(&amp;kvm_accel_type);2625 &#125;26262627 type_init(kvm_type_init); 在QOM的介绍里我提到过kvm通过type_init将初始化的函数指针加入了QOM的Module_Init_Type队列中，QEMU在初始化的时候则会通过这个链表调用kvm_init $QEMU/accel/kvm/kvm-all.c123456781558 static int kvm_init(MachineState *ms) &#123;...1596 s-&gt;fd = qemu_open("/dev/kvm", O_RDWR);...1603 ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0);...1745 ret = kvm_arch_init(ms, s);&#125; 可以发现QEMU最终会通过kvm_ioctl让kernel态的kvm来完成实际的工作。 Initialization of vCPUvcpu的初始化方式和kvm类似，以arm为例: $QEMU/target/arm/cpu.c1234567891011121314151617181920645 static void arm_cpu_realizefn(DeviceState *dev, Error **errp)646 &#123;...853 qemu_init_vcpu(cs);... &#125;1648 static void arm_cpu_class_init(ObjectClass *oc, void *data)1649 &#123;...1655 dc-&gt;realize = arm_cpu_realizefn;...1691 &#125;1708 static const TypeInfo arm_cpu_type_info = &#123;...1717 .class_init = arm_cpu_class_init,1718 &#125;;1732 type_init(arm_cpu_register_types) $QEMU/cpus.c12345678910111213141516171819202122232425262728291101 static void *qemu_kvm_cpu_thread_fn(void *arg)1102 &#123;1114 r = kvm_init_vcpu(cpu);1120 kvm_init_cpu_signals(cpu);1122 /* signal CPU creation */1123 cpu-&gt;created = true;1124 qemu_cond_signal(&amp;qemu_cpu_cond);11251126 do &#123;1127 if (cpu_can_run(cpu)) &#123;1128 r = kvm_cpu_exec(cpu);...1725 static void qemu_kvm_start_vcpu(CPUState *cpu)1726 &#123;1729 cpu-&gt;thread = g_malloc0(sizeof(QemuThread));1730 cpu-&gt;halt_cond = g_malloc0(sizeof(QemuCond));1731 qemu_cond_init(cpu-&gt;halt_cond);1732 snprintf(thread_name, VCPU_THREAD_NAME_SIZE, "CPU %d/KVM",1733 cpu-&gt;cpu_index);1734 qemu_thread_create(cpu-&gt;thread, thread_name, qemu_kvm_cpu_thread_fn,1735 cpu, QEMU_THREAD_JOINABLE);1739 &#125;1757 void qemu_init_vcpu(CPUState *cpu)1758 &#123;1774 qemu_kvm_start_vcpu(cpu);1782 &#125; 从上面的代码可以发现，从vcpu初始化开始，一步步最后调到qemu_kvm_start_vcpu, 在这里QEMU会为每一个vcpu创建一个thread, thread的入口函数中则会调用kvm_init_vcpu和kvm_cpu_exec 所以在qemu的vm_start中resemu所有的vcpu后，这些会以线程的形式开始执行虚拟机的代码； 在Linux调度的头文件中我们可以发现Thread的属性有一个就是vcpu↓: $LINUX/include/linux/sched.h12345672301 /*2302 * Per process flags2303 */2304 #define PF_IDLE 0x00000002 /* I am an IDLE thread */2305 #define PF_EXITING 0x00000004 /* getting shut down */2306 #define PF_EXITPIDONE 0x00000008 /* pi exit done on shut down */2307 #define PF_VCPU 0x00000010 /* I'm a virtual CPU */ 所以与Xen不同的是, kvm复用了Linux自身的调度器，自己只负责处理这些ioctl Execution and Context Switch上面调用了ioctl, 那么处理就是由kvm kernel module来完成的，续上，qemu调用了kvm_cpu_exec后，里面会调用ioctl: $LINUX/virt/kvm/kvm_main.c1232524 static long kvm_vcpu_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg)2526 &#123;2567 r = kvm_arch_vcpu_ioctl_run(vcpu, vcpu-&gt;run); $LINUX/arch/arm/kvm/arm.c12345678910589 int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *run)590 &#123;659 guest_enter_irqoff();660 vcpu-&gt;mode = IN_GUEST_MODE;661662 ret = kvm_call_hyp(__kvm_vcpu_run, vcpu);663664 vcpu-&gt;mode = OUTSIDE_GUEST_MODE;/* Handle vmexit */... module中的代码负责处理kvm_cpu_exec的就是上面这个函数，module在初始化的时候会创建一个/dev/kvm设备，同时会注册相应的ioctl的handler, 代码同样在这个文件中，比较简单就不放了。 这里需要注意的是ret = kvm_call_hyp(__kvm_vcpu_run, vcpu);, arm中的Hypercall调用方式与x86不太一样，虚拟机的运行模式也不太一样，这里的意思就是进入Hypervisor(hyp)模式，并开始执行__kvm_vcpu_run, 这个函数最终会进入guest mode: $LINUX/arch/arm64/kvm/hyp/entry.S123456789101152 /*53 * u64 __guest_enter(struct kvm_vcpu *vcpu,54 * struct kvm_cpu_context *host_ctxt);55 */56 ENTRY(__guest_enter)57 // x0: vcpu58 // x1: host context59 // x2-x17: clobbered by macros60 // x18: guest context/* Context switch */eret 在存储host状态并恢复guest状态后, 调用eret, 根据手册中描述: In a processor that implements the Virtualization Extensions, you can use ERET to perform a return from an exception taken to Hyp mode. When executed in Hyp mode, ERET loads the PC from ELR_hyp and loads the CPSR from SPSR_hyp. When executed in any other mode, apart from User or System, it behaves as: MOVS PC, LR in the ARM instruction set SUBS PC, LR, #0 in the Thumb instruction set. $LINUX/arch/arm64/kernel/entry.S1234567891011311 /*312 * Exception vectors.313 */315316 .align 11317 ENTRY(vectors)318 ventry el1_sync_invalid // Synchronous EL1t319 ventry el1_irq_invalid // IRQ EL1t...324 ventry el1_irq // IRQ EL1h... $LINUX/arch/arm64/kvm/hyp/hyp-entry.S12345124 el1_irq:125 stp x0, x1, [sp, #-16]!126 mrs x1, tpidr_el2127 mov x0, #ARM_EXCEPTION_IRQ128 b __guest_exit $LINUX/arch/arm64/kvm/hyp/entry.S123456791 ENTRY(__guest_exit) 92 // x0: return code 93 // x1: vcpu 94 // x2-x29,lr: vcpu regs 95 // vcpu x0-x1 on the stack.../* context switch and to handler */ 加载了PC后就会执行guest代码了，则会由Exception向量表跳到对应的入口，最后借由__guest_exit返回重新加载host的context, 那么就会回到进入guest mode前的下一条指令开始处理exit。 关于exit处理在之后的文章里再说. Hypercall上面也提了，ret = kvm_call_hyp(__kvm_vcpu_run, vcpu);这个是借助Hypercall完成的，那么我们看看kvm_call_hyp: $LINUX/arch/arm64/kvm/hyp.S123456725 /* u64 __kvm_call_hyp(void *hypfn, ...); */43 ENTRY(__kvm_call_hyp)44 alternative_if_not ARM64_HAS_VIRT_HOST_EXTN45 str lr, [sp, #-16]!46 hvc #047 ldr lr, [sp], #1648 ret 实际上就是调用了hvc指令，这个指令根据arm手册，x0里面存的是下一条要在hyp mode中执行的代码。 这样就可以完成hypercall的调用，需要注意的是arm里进入hyp mode会切换页表，所以必须保证之后要执行的代码在hyp mode里面有映射 Initialization of Hyp mode$LINUX/virt/kvm/kvm_main.c123453909 int kvm_init(void *opaque, unsigned vcpu_size, unsigned vcpu_align,3910 struct module *module)3911 &#123;39143915 r = kvm_arch_init(opaque); $LINUX/arch/arm/kvm/arm.c123451410 /**1411 * Initialize Hyp-mode and memory mappings on all CPUs.1412 */1413 int kvm_arch_init(void *opaque) &#123;1438 err = init_hyp_mode(); $LINUX/arch/arm/kvm/arm.c12345671299 static int init_hyp_mode(void) &#123;1332 /*1333 * Map the Hyp-code called directly from the host1334 */1335 err = create_hyp_mappings(kvm_ksym_ref(__hyp_text_start),1336 kvm_ksym_ref(__hyp_text_end), PAGE_HYP_EXEC);... 在kvm module被加载初始化的时候，就会初始化hyp mode, 并映射相应的代码，(stage2 page table)也是在这个时候初始化的。 Note 到这里应该比较清楚kvm module初始化做了什么(初始化hyp mode, 虚拟一个/dev/kvm设备等等), 以及如何进入guest, 如何与qemu进行交互了。 与x86的独立于ring0和ring3的non-root (guest mode)不同，arm的hyp mode是在EL1之下的权限级(EL2)，而Hypercall的调用则更像一个jump而非x86中向量表的方式。 x86中Non-root下执行的代码会由VMCS/VMCB来配置下陷，而arm中则是直接跑在上面的EL0和EL1, 然后再根据情况一级级下陷，所以ARM的虚拟化方式更像没有硬件虚拟化支持之前的x86的虚拟化; (kernel跑在ring1, hypervisor跑在ring0的样子)]]></content>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVM Log 2-QEMU-kvm Startup]]></title>
    <url>%2Fblog%2F2017%2F08%2F14%2Fkvm-log-2-qemu-kvm-startup%2F</url>
    <content type="text"><![CDATA[上一篇简单说明了QEMU Object Module的注册实现，本篇简单介绍Qemu的启动整个流程。QEMU版本是2.10-rc2 (2017-08-14的版本master分支), 函数的深入细节不涉及~ StartupQEMU是从vl.c中的main()开始执行的↓: main(): vl.c123456789101112131415161718192994 int main(int argc, char **argv, char **envp)2995 &#123;2996 int i;...3039 module_call_init(MODULE_INIT_TRACE);3041 qemu_init_cpu_list();3042 qemu_init_cpu_loop();3043 qemu_mutex_lock_iothread();30443045 atexit(qemu_run_exit_notifiers);3046 error_set_progname(argv[0]);3047 qemu_init_exec_dir(argv[0]);30483049 module_call_init(MODULE_INIT_QOM);3050 monitor_init_qmp_commands();30513052 qemu_add_opts(&amp;qemu_drive_opts);... module_call_init() :实现如下↓ util/module.c123456789101190 void module_call_init(module_init_type type)91 &#123;92 ModuleTypeList *l;93 ModuleEntry *e;9495 l = find_type(type);9697 QTAILQ_FOREACH(e, l, node) &#123;98 e-&gt;init();99 &#125;100 &#125; 在前一篇中已经说明了ModuleTypeList已经在main()执行前初始化过了，所以这里QTAILQ_FOREACH就是在遍历所有的entry并调用真正的init初始化函数。 qemu_init_cpu_list(), 初始化完Trace后，紧接着初始化cpu_list, 这个主要是初始化一些锁和同步机制的相关变量。 qemu_init_cpu_loop(): 这个函数我们主要需要注意其中的qemu_init_sigbus, 其他就是初始化锁之类的 cpus.c12345678910111213141516171819202122232425262728293031#if CONFIG_LINUX988 static void sigbus_handler(int n, siginfo_t *siginfo, void *ctx)989 &#123;990 if (siginfo-&gt;si_code != BUS_MCEERR_AO &amp;&amp; siginfo-&gt;si_code != BUS_MCEERR_AR) &#123;991 sigbus_reraise();992 &#125;993994 if (current_cpu) &#123;995 /* Called asynchronously in VCPU thread. */996 if (kvm_on_sigbus_vcpu(current_cpu, siginfo-&gt;si_code, siginfo-&gt;si_addr)) &#123;997 sigbus_reraise();998 &#125;999 &#125; else &#123;1000 /* Called synchronously (via signalfd) in main thread. */1001 if (kvm_on_sigbus(siginfo-&gt;si_code, siginfo-&gt;si_addr)) &#123;1002 sigbus_reraise();1003 &#125;1004 &#125;1005 &#125;1007 static void qemu_init_sigbus(void)1008 &#123;1009 struct sigaction action;10101011 memset(&amp;action, 0, sizeof(action));1012 action.sa_flags = SA_SIGINFO;1013 action.sa_sigaction = sigbus_handler;1014 sigaction(SIGBUS, &amp;action, NULL);10151016 prctl(PR_MCE_KILL, PR_MCE_KILL_SET, PR_MCE_KILL_EARLY, 0, 0);1017 &#125; 在函数里面初始化了sigbus, 这里sigbus会建立一个sigaction, sigaction是vcpu对signal的动作，当config为Linux时，sigbus_handler会调用kvm的相关函数. 接下来都是些比较简单的初始化，初始化QOM和OPT类型的Module, 之后就是冗长的参数解析和处理过程… vl.c1234563746 case QEMU_OPTION_enable_kvm:3747 olist = qemu_find_opts("machine");3748 qemu_opts_parse_noisily(olist, "accel=kvm", false);3749 break;...4121 machine_class = select_machine(); 其中有一项就是判断是否开启了kvm, 如果开启了kvm则将accelerator设置为KVM. 当参数这些弄完后，就会开始选择target的machine类型, (机器支持的类型可以通过qemu -machine help查看到): 1234567891011121314151617# For example, arm64:% qemu-system-aarch64 -machine helpSupported machines are:lm3s811evb Stellaris LM3S811EVBcanon-a1100 Canon PowerShot A1100 ISvexpress-a15 ARM Versatile Express for Cortex-A15vexpress-a9 ARM Versatile Express for Cortex-A9xilinx-zynq-a9 Xilinx Zynq Platform Baseboard for Cortex-A9connex Gumstix Connex (PXA255)n800 Nokia N800 tablet aka. RX-34 (OMAP2420)lm3s6965evb Stellaris LM3S6965EVBversatileab ARM Versatile/AB (ARM926EJ-S)borzoi Borzoi PDA (PXA270)tosa Tosa PDA (PXA255)cheetah Palm Tungsten|E aka. Cheetah PDA (OMAP310)midway Calxeda Midway (ECX-2000)... 继续就是设置虚拟机的内存大小。 vl.c1234123 set_memory_options(&amp;ram_slots, &amp;maxram_size, machine_class);...4177 cpu_exec_init_all(); 再往下就是实际为虚拟机分配内存: cpu_exec_init_all() ↓ exec.c1234567891011121314151617181920212760 static void memory_map_init(void)2761 &#123;2762 system_memory = g_malloc(sizeof(*system_memory));27632764 memory_region_init(system_memory, NULL, "system", UINT64_MAX);2765 address_space_init(&amp;address_space_memory, system_memory, "memory");27662767 system_io = g_malloc(sizeof(*system_io));2768 memory_region_init_io(system_io, NULL, &amp;unassigned_io_ops, NULL, "io",2769 65536);2770 address_space_init(&amp;address_space_io, system_io, "I/O");2771 &#125;3215 void cpu_exec_init_all(void)3216 &#123;3217 qemu_mutex_init(&amp;ram_list.mutex);3225 finalize_target_page_bits();3226 io_mem_init();3227 memory_map_init();3228 qemu_mutex_init(&amp;map_client_list_lock);3229 &#125; 往下就是初始化smp、默认的显示器、log、Page页大小、socket, 之后就是和kvm非常相关的配置accelerator了， 与kvm的交互我们放下一篇细说，这里不深入了。 vl.c1234567891011121314154424 configure_accelerator(current_machine);44254430 register_global_properties(current_machine);...4442 machine_opts = qemu_get_machine_opts();4443 kernel_filename = qemu_opt_get(machine_opts, "kernel");4444 initrd_filename = qemu_opt_get(machine_opts, "initrd");4445 kernel_cmdline = qemu_opt_get(machine_opts, "append");4446 bios_name = qemu_opt_get(machine_opts, "firmware");...4577 default_drive(default_cdrom, snapshot, machine_class-&gt;block_default_type, 2,4578 CDROM_OPTS);...4741 qdev_machine_creation_done();4746 qemu_run_machine_init_done_notifiers(); 之后就是读取kernel镜像位置等和启动参数等，然后初始化console、设置默认的启动介质、设置watchdog、其他设备相关的初始化。 最终qemu就会初始化完成虚拟机machine, vl.c1234564786 vm_start();4787 &#125;47884789 os_setup_post();47904791 main_loop(); 之后QEMU会调用vm_start() 所有的vcpu开始被调度，QEMU自身进入main_loop(), 当我们停止虚拟机的时候，main_loop()会跳出并回收资源. cpus.c1234561845 void vm_start(void)1846 &#123;1847 if (!vm_prepare_start()) &#123;1848 resume_all_vcpus();1849 &#125;1850 &#125; 这就是整个QEMU的执行过程。]]></content>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVM Log 1-QEMU Object Module (QOM)]]></title>
    <url>%2Fblog%2F2017%2F08%2F14%2Fkvm-log-1-qemu-module-intro%2F</url>
    <content type="text"><![CDATA[KVM分为两部分，User态部分在Qemu中，Kernel态部分集成到了Linux的代码里作为Kernel Module的形式对上提供服务。由于整个大的流程还是在QEMU里面的，所以本篇先介绍一下设备注册的相关信息。 Reference: Mctrain’s Blog: Qemu中的设备注册 QEMU Object Module关于QOM(Qemu Object Module)的介绍 其发展如下图(从Mactrain’s Blog里面摘过来的，原来的PDF链接失效了) 在kvm-all.c文件的最后，我们可以发现有个type_init(kvm_type_init), 其中type_init的定义在 include/qemu/module.h12345678935 #define module_init(function, type) \36 static void __attribute__((constructor)) do_qemu_init_ ## function(void) \37 &#123; \38 register_module_init(function, type); \39 &#125;52 #define type_init(function) module_init(function, MODULE_INIT_QOM)53 #define trace_init(function) module_init(function, MODULE_INIT_TRACE)... 可以发现最终会变成do_qemu_init_kvm_type_init(void) { ... }，其中 register_module_init的实现在对应的C文件↓ util/module.c1234567891011121314151617181920212223242526272829303132333435363733 static ModuleTypeList init_type_list[MODULE_INIT_MAX];3637 static void init_lists(void)38 &#123;39 static int inited;40 int i;4142 if (inited)43 return;4546 for (i = 0; i &lt; MODULE_INIT_MAX; i++) &#123;47 QTAILQ_INIT(&amp;init_type_list[i]);48 &#125;4950 QTAILQ_INIT(&amp;dso_init_list);52 inited = 1;53 &#125;56 static ModuleTypeList *find_type(module_init_type type)57 &#123;58 init_lists()；60 return &amp;init_type_list[type];61 &#125;63 void register_module_init(void (*fn)(void), module_init_type type)64 &#123;65 ModuleEntry *e;66 ModuleTypeList *l;6768 e = g_malloc0(sizeof(*e));69 e-&gt;init = fn;70 e-&gt;type = type;7172 l = find_type(type);7374 QTAILQ_INSERT_TAIL(l, e, node);75 &#125; find_type会调用init_lists进行链表的初始化。 register_module_init里面会malloc一个新的ModuleEntry并插入对应init_type_list[Module_Init_Type]链表中， Entry的初始化函数指针init和类型type会被赋值为传进来的参数。 Module_Init_Type稍后再说，这里主要强调一下__attribute__((constructor))，这个是GCC提供的特性，能够让函数在 main()执行前被执行。所以这些代码都在main()之前执行了！ 关于__attribute__((constructor))的介绍可以参考这篇: C Language Constructors and Destructors with GCC。 因此在QEMU运行之前，全局的所有Module对应的Entry就已经被插入到init_type_list中。 KVM_accel_moduleinclude/qemu/module.h123456742 typedef enum &#123;43 MODULE_INIT_BLOCK,44 MODULE_INIT_OPTS,45 MODULE_INIT_QOM,46 MODULE_INIT_TRACE,47 MODULE_INIT_MAX48 &#125; module_init_type; Qemu里面一共就4种Module: BLOCK,OPT,QOM,TRACE，在include/qom/object.h中详细介绍了如何使用已有的接口来实现自己的Module_Init_Type, 所以根据上面的分析， 在Main函数执行之前，我们就获得了一个这样的链表↓: 1234567891011init_type_list: init_type_list[MODULE_INIT_QOM]: ↓ ↓------------------- |----------&gt; ModuleEntry-0MODULE_INIT_BLOCK | ↑ ↓ ------------------- | ModuleEntry-1MODULE_INIT_OPTS | ↑ ↓ ------------------- | ModuleEntry-2MODULE_INIT_QOM ------| ↑ ↓ ------------------- ......MODULE_INIT_TRACE------------------- 其中kvm_accel_type就是QOM的其中一个ModuleEntry: accel/kvm/kvm-all.c123456789101112132615 static const TypeInfo kvm_accel_type = &#123;2616 .name = TYPE_KVM_ACCEL,2617 .parent = TYPE_ACCEL,2618 .class_init = kvm_accel_class_init,2619 .instance_size = sizeof(KVMState),2620 &#125;;26212622 static void kvm_type_init(void)2623 &#123;2624 type_register_static(&amp;kvm_accel_type);2625 &#125;26262627 type_init(kvm_type_init); 根据上面的分析，kvm 通过type_init这个洪在init_type_list[MODULE_INIT_QOM]链表中加入了一个自己的ModuleEntry，其中ModuleEntry的init被初始化为 kvm_type_init, 进而注册了kvm_accel_type这个module的信息。 类似的，在QEMU运行的时候只要挨着调用这些List里面Entry的 .init函数就会挨着初始化所有的Module.]]></content>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯游戏上海北极光工作室2018面经]]></title>
    <url>%2Fblog%2F2017%2F08%2F13%2Ftencent-game-interview%2F</url>
    <content type="text"><![CDATA[找人内推了腾讯游戏上海的北极光工作室，腾讯五大工作室分别为：琳琅天上工作室（Jade Studios）、量子工作室（Quantum Studios）、卧龙工作室（Wolong Studios）、北极光工作室（Aurora Studios）、波士顿工作室（Boston Studio). 北极光工作室的《天涯明月刀OL》、《轩辕传奇》属于比较有名的游戏，我面的后端研发。 简历投游戏的原因是出于自身爱好和对行业的好奇，因为之前没有接触过游戏业，所以一直不知道游戏研发到底都做哪些，面试的一方面也是能够切身感受一下游戏研发的工作环境(其实我是被New Game误导了，全都是妹子的工作室？不存在的)… 投的是游戏后端的研发，游戏服务器的Coder，这个可能和我现有技能最接近吧，不过个人对于前端更好奇..虽然前端主要要图形的人.. 一面不得不说…这个面试问的内容真是太太太全了..简单寒暄后就直接进入正题。 首先是了解我做过的项目，让介绍我具体做了什么工作，具体使用了什么技术。能够看出来这个面试官是个对技术细节也比较了解的人，一直在自习分辨哪些是系统本来有的，我们具体的贡献是什么等等.. 由于对操作系统比较了解，(面试官默认学系统的对网络也了解，然而我并不怎么了解)..让解释用户态和kernel态内存如何区分，如何管理。user态程序内存如果分配，系统调用的详细过程，发生Page Fault的处理过程等等。中间问了一个问题是进程分配了4K,但写了6K的内存 (或者说分配的虚拟内存大于实际物理内存有什么后果). 我一直以为这个是想问虚拟地址到物理地址映射和swap；不过根据反应来看好像不是问这个的… 我又说了些buffer overflow相关的，最后我也没明白面试官到底是想问什么… 接下来是数据库的相关知识，因为不熟悉所以基本上都是回答不了解，Join的左右啥的只有一点点大三学数据库时的印象，想不起来。容错方面是借着当时Paper的内容答了Redo和Undo的原理，Redo log第一次还回答错了.. 代码方面让手写双向链表的reverse实现，当时有点慌写的代码实际上是有个小bug，好久不刷题的弊端..写系统代码和写算法代码思维都不一样..不过面试官好像主要是看代码的风格和大致内容吧..大概看一眼看看代码的水平? 这个没做什么评价。 之后是语言，由于我是用Pure C和Java的，它就问我C++的继承、多态在C里面如何实现，这个因为之前看过用C写面向对象程序(系统里面经常要这么用)所以比较熟悉。然后是printf变长参数实现，这个刚好前一天在看ARM的函数调用规范手册时候，里面介绍了变长参数，整个过程大致还是了解的。之后是C++里面extern C的原因，(这个之前网易游戏也面到了，当时不了解，后来就查了下)，是为了不让C++编译器在函数名后面加字符串，这样Linker在找C的symbol的时候才能找到，也就能让C++调用C的函数。最后问了C++里面析构函数调用虚函数的效果，面试官实际上是在C里面写了一个Use after free来问的, 这个因为是做安全的比较了解，所以也没什么问题。 接下来就是提问，我就大概问了问他们具体做什么，和游戏运维的区别，前端后端的区别等等。 二面二面是经理面，经理面主要问的已经不是纯技术了，一般都是问个人想法、对于未来工作的看法、对于游戏的看法等等。实际上就是一个加深了解的过程，经理给人的感觉非常年轻， 可以预料有许许多多年轻而才华横溢的大牛在北极光工作时。我们聊得也是非常愉快，让我对游戏后端的工作也有了更深的了解~ HR面HR面已经是讨论发offer和实习、时间安排等问题了，这里就不赘述了。 Note北极光的工作环境还是非常不错的，对于我这种游戏动漫爱好者在工作环境中可以随便放手办还不会引起不好的影响这一点还是非常有吸引力的，是一个超级大的房间和网吧很像一排排的电脑， 一进门就能看到天涯明月刀的大幅彩喷。不过当时我面试结束的时候已经21:00之后了还是能看到一些加班的人，所以不难想象这里的工作强度也不会低…]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[星环科技校招2018面经]]></title>
    <url>%2Fblog%2F2017%2F08%2F10%2Ftranswarp-interview%2F</url>
    <content type="text"><![CDATA[终于到了找工作的时间了，也投了星环，面了3个多小时，最后顺利拿到了offer，本篇分享一下经历。 也是听了前辈们说的后感觉星环是一个不错的选择，在大数据是未来发展方向之一的前提下，星环的技术还是国内Top的。目前的星环大概200-300人的规模吧。 官网招聘的页面:http://www.transwarp.cn/about/job. 投简历我因为是做虚拟化的，所以找了个最接近的云计算平台开发工程师投了。我是找的内推，不过流程上和直接投官方的邮箱感觉没啥区别。第二天就收到了面试通知。 面试由于目前在实习期间，基本上就是裸上，而且长期没刷题，所以算法和数据结构也基本上忘的差不多了… 一面早上一来就开始面试，也有点没睡醒.. 先是闲聊让氛围轻松一些。之后就开始问Hadoop和Spark是否了解, 异同。这里也不怕大家看到，我只是了解MapReduce和RDD这两篇Paper… RDD还是在面试前一天晚上又重新简单复习了一下就上了, 所以只能答出来Paper里有的基本概念。这个只能说很一般吧，基本上被问了10min就摸清底了，说实话这里还是很重视技术的，学一个东西就学透彻，只是看一些网上的二手资料或者Paper啥的基本上一被问就暴露了。 之后让用非递归方式实现二叉树的先序遍历，这个我在大三的考试题做过..现场直接写的时候直接懵逼…尴尬了十几分钟，被评价不熟悉程序.. 没有复习的亏，也没啥办法。递归首先要想到栈，因为实际的递归函数调用函数也是借助栈来实现的，这里每次pop(root)然后push(right), push(left), 重复这个步骤，先序其实很简单，pop的时候输出就完了；后序的话是要保存值最后输出的；中序的话 下面伪代码大致看下好了. 1234567891011121314while (p) &#123; while (p) &#123; push(p); p = p-&gt;left; &#125; /* Left is none */ p = pop(); output(p-&gt;value); /* Enter right, continue */ p = p-&gt;right; &#125; 然后一道设计题，(0 ~ 1010)的范围内取100,000个数，进行去重复和排序。 这道题其实猛地一看可能是排序，实际上是个统计出否出现的问题。所以我当时第一反应就是bitmap, 因为bitmap是表示一个东西出现或没出现过最简单的表示； 接下来自然就很想到平时我们用的是一个有1010个bits的map, 这样只要知道他们是否出现过扫一遍bitmap输出为1的就自然是排好序的数字了，而且自带去重; 由于这样会用很多空间，所以我继续提出使用Hashmap, 不过面试官指出hash的话不能保证有序，所以放弃。 继续想到数据库里面列存储的提出，列存储是因为许多entry的某一列的值都一样(比如座机这一项，基本上所有的员工都是None, 只有少部分是有座机的，所以按列存可以节省很大空间).从这得到启发，我提出将范围进行分区间，因为100,000相比较1010小很多，所以大部分bitmap的值是0，那么前面的一个bit就可以表示一个范围…如果是1，那么这个范围就有数被选中，如果是0这个范围就没有。 接下来就会想到二分，此时为了涵盖0~1010, 用40个bit(240 &gt; 1010)个bit就能表示一个数具体出现的位置。比如我们从0-7里面选了个4, 就可以用100，其中第一个bit表明数字是 7~4，第二个bit表示是 5~4, 第三个表示是4.. 最后一个数刚好二进制表示就是我们所需 那么根据二进制表示构造一个二叉树，一条到叶子节点的路径就能表示这个数本身，一个叶子就能明确表示一个数是否出现过，最后对这个树进行一次遍历就能输出排好序并去重后的结果了。也可以像B+树一样把所有leaf串起来.. 这样一个树所有数字都在叶子且高度相同(一定为40), 由于插入新叶子是常数级，所以最终只需要O(n)就能完成所有数字的去重和排序，而且空间开销只要500KB…(面试限制是500MB) 这道题可能设计的思维过程被认可了吧，之后面试官问有没有其他优化方案。我首先回答增加cache命中率，第二个是并发执行.. 好叭 这个其实是瞎扯..不过也是第一反应就说出来了 囧.. 二面二面依旧是技术面，大概30min让我讲我之前做的东西，就是让我给他讲懂虚拟化..这个比较简单，毕竟在实验室也给新来的讲过，所以没什么问题。有兴趣的看我之前的Blog有讲~ 然后就是让写一个atoi的函数. 之后让写测试这个函数的输入, 没什么太难的地方.. 不过这道题虽然简单但是是可以考察多非常多内容的，这个也是后来才知道的，在程序员的那些事这个公共号里面发现的。我当时答的其实属于比较一般的了，我强调了平常开发的顺序是1. 保证功能正常执行 2. 错误处理 3. 安全方面的考虑。 实际开发时安全方面的考虑由于会影响到设计，是需要提前就考虑的。 这里也是强调一下，一个比较合格的答案应该是怎样的: 可用 写出的代码必须是能运行的，如果写出来的语法错误或者逻辑错误…那么只能说明没什么编码水平 健壮 健壮意味着代码拥有边界检查、能进行一定的容错，包括空参数等等 可靠 这里可靠意味着程序需要有肯定的返回值，比如出错时返回错误码等等。强语言一般都有返回值，而弱语言如果有确定返回值的话那么这个程序是可靠的。 宽容 宽容意味着能够尽可能容纳客户的各种输入，比如用户输入的是浮点数3.00001或者2.99999 我们的程序是可以将其作为整数3来进行处理的，以及是否支持超过INT_MAX的整形转换。 时延 这部分就涉及到用户体验了，当程序在长时间处理时，能否定期返回某个结果或保证处理结果在一定时间内一定有个状态的回复等等， 否则当程序执行非常长的输入时，我们无法知道程序是出错还是正常运行。 我当时实现实际上是和libc中的atoi一样，没有进行什么检查，好在我提到了这些所以可能面试官也对我宽容了一些吧。 三面三面是Boss面，创始人之一过来面我，主要是让聊我的择业想法，对星环的看法，对行业的看法，我目前的状况，星环自身的状况，他们组的介绍等等；基本上就是一个相互了解的过程，当时都快1点了… HR面最后HR回来聊关于自身状况、实习等等的事情，HR面基本纯闲聊了，如果有问题也可以随时提，所以没什么好说的。 Extra面一个多月后的今天突然又收到了面试电话，了解了下好像是因为做的东西比较底层，其他组都不怎么想要的样子.. (也可能是我之前的面试答的不好，其他组看不上我…)安慰我说之前的面试是统一面，今天是分组面.. 首先是一道有向连通图，带正权重的最短路径算法，不过要记录最短路径的长度，Dijkstra最短路径算法，不过在更新点的时候要记录最短路径的长度。后面又加上如果要求最短路径本身怎么做，我答的是每个点记录更新自己的父节点，然后逆推就行，面试官好像不是很满意，问我有没有不用记录的方案，没答上来.. 后面问了一个项目中收获最大的一次经历，或收获最大的点。回答了一个调了2个多星期的bug, 有关页表管理部分struct类型数据对齐的内容。 最后问了我一下自己见到过的比较漂亮的代码，哪里我觉得漂亮。回答的是kernel里面使用goto进行错误处理的例子。 结果也不太清楚到底怎么样…突然加个面试还是慌得要死。 总结星环是个挺看重技术的地方，而且对于我这种之前做系统的感觉还挺有兴趣的，里面的人非常好，工作环境非常不错！上班时间很自由不打卡，我师兄早上10点之后到，晚上20:00左右走，也不强制周末加班，可能也是因为熬过了初期创业的艰辛，到了C轮也有上百个客户，感觉也是在慢慢变得更加规范。也是拿到了Offer，面我的Boss人非常Nice，也很健谈。 整个面试过程比我想象的要长，而且面试官也都很专业，不会故意为难，也不会问那些无聊的大概、过于基础的东西，会给你充足的时间展示自己的优势，所以不用担心自己学的和他们做的好像不符等等~]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Virtualize USB as Network Card]]></title>
    <url>%2Fblog%2F2017%2F07%2F31%2Fusb-device-networking%2F</url>
    <content type="text"><![CDATA[开发板一般最稳定的接口就是USB串口，而Linux中g_ether module允许我们将usb虚拟化为网卡， 这样我们的开发板就可以通过这块虚拟网卡借助host PC的代理连接到外部互联网。 本文参考了: How to USB device networking Compile linux kernel with USB_ETH Support在交叉编译arm的内核时我们需要配置kernel，开启USB_ETH支持： 默认是不支持的，根据搜索结果开起来就可以了 12345Symbol: USB_ETH [=n] Prompt: Ethernet Gadget (with CDC Ethernet support) Symbol: USB_GADGETFS [=m] Prompt: Gadget Filesystems Enable g_etherDevice通过指定参数dev_addr和host_addr可以制定虚拟网卡在device和host PC显示的MAC地址，方便我们host PC配置IP. 1sudo modprobe g_ether dev_addr="00:FF:FF:FF:FF:FF" host_addr="5a:77:1e:af:8e:9e" 如果这个mod是自动加载的，可以在kernel启动参数里面加上g_ether.dev_addr=XX:XX:XX:XX:XX:XX g_ether.host_addr=XX:XX:XX:XX:XX:XX 成功之后使用ifconfig usb0将可以看到相应的网卡信息，输出类似于: 123456usb0 Link encap:Ethernet HWaddr BE:B5:85:EF:48:33 BROADCAST MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) 为其分配一个IP(这里是TARGET_USB_IP)，并添加路由 12345678910HOST_USB_IP=10.0.1.1TARGET_USB_IP=10.0.1.2ifconfig usb0 $TARGET_USB_IP netmask 255.255.255.0route add default gw $HOST_USB_IProuteKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface10.0.1.0 * 255.255.255.0 U 0 0 0 usb0default 10.0.1.1 0.0.0.0 UG 0 0 0 usb0 host PC当板子上的虚拟网卡成功配置后，hostPC的log中会有相应的信息: 123456kernel: [1638241.377831] usb 1-4.4.2: new high speed USB device using ehci_hcd and address 47kernel: [1638241.510787] cdc_subset: probe of 1-4.4.2:1.0 failed with error -22kernel: [1638241.513437] cdc_subset 1-4.4.2:1.1: usb0: register 'cdc_subset' at usb-0000:00:02.1-4.4.2, Linux Device, 82:13:56:20:b4:cbkernel: [1638241.513490] usbcore: registered new interface driver cdc_subsetkernel: [1638241.533442] cdc_ether: probe of 1-4.4.2:1.0 failed with error -16kernel: [1638241.533619] usbcore: registered new interface driver cdc_ether 也能看到相应的网卡信息: 123456789ifconfig usb0usb0 Link encap:Ethernet HWaddr 82:13:56:20:b4:cb inet6 addr: fe80::8013:56ff:fe20:b4cb/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:1 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:0 (0.0 B) TX bytes:78 (78.0 B) 这个时候只要为host PC的这块网卡分配一个IP即可与板子通信 12345678910HOST_USB_IP=10.0.1.1sudo ifconfig usb0 $HOST_USB_IP netmask 255.255.255.0routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface10.0.1.0 * 255.255.255.0 U 0 0 0 usb0...link-local * 255.255.0.0 U 1000 0 0 eth0default gw 0.0.0.0 UG 100 0 0 eth0 利用上一篇所述的代理, 板子只要使用HOST_USB_IP:port即可利用host PC代理到外部网络。 引用的链接里还有NFS和Domain Server的相关配置，因为我没怎么用到就省略啦。 Notehost PC的路由表几分钟就会刷新，所以为了保证这条信息一直有，在相关配置文件添加这个ip比较好，如果有图形化界面的话 在网络设置里面为这块虚拟网卡分配相应的IP即可，由于我们配置的这块虚拟网卡是固定MAC地址的，因此配置一次后以后只要两者相连，IP就会自动分配了。]]></content>
      <tags>
        <tag>tutorial</tag>
        <tag>linux</tag>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Using cntlm Proxy on Linux]]></title>
    <url>%2Fblog%2F2017%2F07%2F30%2Fcntlm-proxy-on-linux%2F</url>
    <content type="text"><![CDATA[在公司或学校的代理往往只给固定IP(host)上网的权限，或者验证服务器只能用NTLM(v2)方式而拒绝明文密码方式，而我们的其他设备如果想通过host来上网的话就需要将host作为一个小的踏板, Cntlm 是一款能满足这个需求的轻量级小程序，本文对其进行简单的介绍。 Installation安装非常简单: 1sudo apt-get install cntlm Configuration安装好了之后在/etc/cntlm.conf这里就会有一个默认的配置文件，需要sudo权限编辑， 123456789101112131415161718192021222324252627# username of your proxyUsername username # Domain of your proxy (e.g. ipads.se.sjtu.edu.cn)Domain ipads.se.sjtu.edu.cn# Password (Not secure, we will introduce other way)Password password # Parent proxy address (e.g. 10.0.0.1:8080)Proxy 10.0.0.1:8080# Bypass some addressNoProxy localhost, 127.0.0.*, 10.*, 192.168.*# Listen port, you can add more Listen port# Gateway (if yes, other device can using hostip:listen port as proxy)Gateway yes# White list# Allow 192.168.0.0/16# Allow 10.140.23.223/32# Deny all addressesDeny 0/0 Now device can use hostIP:port to connect to internet 简单的配置文件如上，其实就是将已有的代理转到了一个本地的代理，省去了配置用户名密码的麻烦； 如果Gateway是yes的话其他的设备也可以通过host来使用代理。 不过Password如果是明文非常不安全，加上有的机构可能指定验证方式(比如指定NTLM), 这样的话我们就需要把password那行换掉: 123456$ cntlm -H(input your password)PassLM D3626C186D2CE90B552C4BCA4AEBFB11PassNT 40CC50018882A102366D14C431E315FFPassNTLMv2 B6E48FB02DE891073BB38151E826EF5D # Only for user '', domain '' 将上面所需内容直接拷到配置文件中，并添加: 12# e.g. NTLMAuth NTLM 之后就可以使用 hostip:port 代理来上网了 Proxy setting1234# Add to bashrc/zshrc etc.export http_proxy=hostip:portexport https_proxy=hostip:port... Let sudo perserve proxy1234sudo vi /etc/sudoers# Add one more line:Default env_keep="http_proxy https_proxy" if your sudores is corrupted. Using pkexec vi /etc/sudoers to repair it Git Configuration1234567# ~/.gitconfig[http] proxy=http://hostip:port[https] proxy=https://hostip:port]]></content>
      <tags>
        <tag>tutorial</tag>
        <tag>linux</tag>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Run Debian9 Linux on Hikey960]]></title>
    <url>%2Fblog%2F2017%2F07%2F18%2Flinux-on-hikey960%2F</url>
    <content type="text"><![CDATA[Hikey960目前来说是个比较新的板子，网上大部分教程都是针对Hikey，而Hikey960和Hikey的 差别比较大，现有的教程也比较杂，所以这里记录一下自己踩过的小坑。 Curently, Hikey960 is not fully supported by debian9. Tutorials and docs are all about hikey (620). This post records the process about running Debian 9 on Hikey960. (Reference)本文参考了: HikeyUEFI, ATF-UEFI-build-from-source Cross Compilation Environment先给下载链接: aarch64-linux-gnu-5.3 Download link: aarch64-linux-gnu-5.3 注意请用5.3, 5.0以下的一会我们编译的时候会有一些参数5.0以下还不支持，我用5.4的时候会遇到一个bug, 有兴趣的可以看看，一个宏展开的时候较新的gcc会报错。5.3是可以的.. Note that only gcc 5.0 is usable while there are some bugs (See this for details) in 5.4. What I used is gcc 5.3. 下载解压后把bin目录加入到自己的path中就可以了。 Add bin to your $PATH variable to use these cross-compilation tools. Hikey960 Introduction这里能够看到板子的简单介绍，我们需要注意的只有不同模式如何调: This page shows some introduction about hikey960. What we need to know is how to config it into different mode: ——–Mode——– —Link Switch— —Auto Power— —Fastboot— —Recovery— Auto Power up link 1-2/Switch 1 closed/ON closed/ON closed/ON Recovery link 3-4/Switch 2 open/OFF open/OFF closed/ON Fastboot link 5-6/Switch 3 open/OFF closed/ON open/OFF 还有需要注意的是 如果是跳线来连的属于Ver1, 如果是直接用板子背面开关调的属于Ver2 The Ver2 correspons to switches and jumper is Ver1. 这里可以看到每个signal在板子上的意义和位置: Manual This Hardware User Manual shows the meaning of different pins and components of this board. 可以连接UART_TXD, UART_RXD, GND 用TLL to RS232，再转个USB就能通过串口来调试了, 板子的信息输出可以通过这个来看，本身烧板子用的是type-c的口。 UART的接线可以看Understanding and Connecting UART Devices You can use a TTL to RS232 convertor and connect to corresponding pins to get serial (UART) output. (Or buy an integrated one) The connecting methods are shown on Understanding and Connecting UART Devices 而关于如何观察串口输出和调试，可以参考之前的这篇:Debug Xen on Physical Machine Using minicom or screen on your host machine to read the output Build UEFI loader我们的loader直接从源码编译，(现有的bin很多都是针对Hikey其他板子的，960没法直接拿来用) Compile loader from source. (Currently, it may be a little difficult to find one) Download links: ARM Trusted Firmware EDK2 OpenPlatformPkg l-loader uefi-tools atf-fastboot 下载到同一个目录，记为BUILD_PATH Move them to one dir. The path/to/this/dir is remembered as BUILD_PATH 12345678910111213141516171819202122232425262728cd $&#123;BUILD_PATH&#125;/edk2ln -s ../OpenPlatformPkg # Link file must be named as this, will be used when compile edk2# 前面提到过的，如果板子是Ver1, 需要在uefi-tools/platform.config中去掉下面这句:# Ir your board is Ver1, remove following one in your uefi-tools/platform.configBUILDFLAGS=-DSERIAL_BASE=0xFDF05000BUILD_OPTION=DEBUGexport AARCH64_TOOLCHAIN=GCC5export UEFI_TOOLS_DIR=$&#123;BUILD_PATH&#125;/uefi-toolsexport EDK2_DIR=$&#123;BUILD_PATH&#125;/edk2EDK2_OUTPUT_DIR=$&#123;EDK2_DIR&#125;/Build/HiKey960/$&#123;BUILD_OPTION&#125;_$&#123;AARCH64_TOOLCHAIN&#125;cd $&#123;EDK2_DIR&#125;# Build UEFI &amp; ARM Trust Firmware# Again, please use gcc-5.3 to build$&#123;UEFI_TOOLS_DIR&#125;/uefi-build.sh -b $&#123;BUILD_OPTION&#125; -a ../arm-trusted-firmware hikey960# Generate l-loader.bincd $&#123;BUILD_PATH&#125;/l-loaderln -sf $&#123;EDK2_OUTPUT_DIR&#125;/FV/bl1.binln -sf $&#123;EDK2_OUTPUT_DIR&#125;/FV/fip.binln -sf $&#123;EDK2_OUTPUT_DIR&#125;/FV/BL33_AP_UEFI.fdpython gen_loader_hikey960.py -o l-loader.bin --img_bl1=bl1.bin --img_ns_bl1u=BL33_AP_UEFI.fd# Generate partition table (You can download from net directly)# See generate_ptable.sh to config your own ptablePTABLE=linux-32g SECTOR_SIZE=4096 SGDISK=./sgdisk bash -x generate_ptable.sh PTABLE这一步可以根据自己需要修改generate_ptable.sh中的分区，比如如果使用的Debian的镜像的话4G的system 分区是不够的，如果板子的Flash足够大也可以自己把分区分的更大一些方便之后的使用。 Generate your own partition table via generate_ptable.sh(in l-loader dir). For example, 4G flash storage is not enough for debian 9. My system partition is 20G. Flash Loader将板子调成recovery mode, (1, 3 ON, 2 OFF), 下载tools-images-hikey960 Config board to recovery mode (1, 3 ON, 2 OFF), Download tools-images-hikey960 修改config: 把我们自己的l-loader替换原来的 In tools-images-hikey960 dir, modify config and using our compiled l-loader.bin to replace original one: 123./sec_usb_xloader.img 0x00020000./sec_uce_boot.img 0x6A908000./l-loader.bin 0x1AC00000 Linux的话要移除modemmanger: sudo apt-get purge modemmanger If you are using a linux host, please remove modemmanger otherwise there may be one bug. 利用tools的工具来刷我们的l-loader: sudo ./hikey_idt -c config -p /dev/ttyUSB1, (这个ttyUSB是type-c所连的那个) 这个刷成功后，设备就会开始跑fastboot程序，我们就可以开始刷其他的东东了: Using tools in this dir to flash our new loader: sudo ./hikey_idt -c config -p /dev/ttyUSB1, (ttyUSB1 is the one your type-c is connecting). After this step, the board will run a fastboot program which means we can flash other files. l-loader, fip这两个和板子关系比较密切，不同板子版一样，ptable则根据我们flash的容量来自己设置, boot分区我们会刷uefi的程序， system分区则会刷我们的linux所在的文件系统。 l-loader, fip is board associated. Usually, different boards has different loader and fip. ptable is generated by ourselves. boot partition will be flashed with uefi loader and system partition will contain our Debian 9. 目前支持的Linux只有rpb, 下载我们需要的dtb (device tree blob), uefi.img, 和 rootfs.img As currently only rpb linux supports hikey960, first, we will flash its dtb (device tree blob), uefi.img and rootfs.img 123456789101112131415# Using our own ptable$sudo fastboot flash ptable ptable.img$sudo fastboot flash xloader sec_xloader.img# Using compiled l-loader$sudo fastboot flash fastboot l-loader.bin# Using Compiled fip.bin$sudo fastboot flash fip fip.bin$sudo fastboot flash boot uefi.img$sudo fastboot flash system rootfs.img# Only Android will use$sudo fastboot flash cache cache.img$sudo fastboot flash userdata userdata.img Reboot Now you can login into this rpb linux using default accout linaro Run Debian 9 on hikey960To run a debian 9, we will replace boot and kernel image of debian 9 for hikey. Download Debian 9 rootfs: Debian 9 for hikey (hikey-jessie_developer_20151130-387-8g.emmc.img.gz as an example) The images are all sparse image, which means you need simg2img to convert them. Replace boot and kernel imageYou may found that uefi.img from rpb linux will read configuration from system partition/boot/grub/grub.cfg. So, just mount this debian image and replace boot dir with the one from rpb. Then you need new linux kernel image and dtb. Compile it from source. (The hieky960-v4.9 branch in this tree) Get dtb from arch/arm64/boot/dts/hisilicon/hi3660-hikey960.dtb You can get this when you cross-compile this linux. Put your new kernel image (in arch/arm64/boot/Image) in your debian image and modify grub.cfg to boot this new kernel. Reboot! Some issues Now you can boot into your debian linux. As this debian rootfs is 8G, you may use checkfs to repair the filesystem to 20G. For connecting to network, you can flash wifi module or virtualize type-c usb to netcard. Now just modify your source.list and apt-get your needed pacakages. ChangeLog 2017-09-10 添加Debian 9支持 2017-07-31 添加prm_table.sh的说明，删除无用的ToDo.]]></content>
      <tags>
        <tag>tutorial</tag>
        <tag>linux</tag>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PARSEC & SPEC CPU Benchmark Deployment]]></title>
    <url>%2Fblog%2F2017%2F05%2F31%2Fparsec-and-spec%2F</url>
    <content type="text"><![CDATA[测Evaluation的时候一般会测一下SPEC 和 PARSEC benchmark, 本篇简单介绍一下两者的部署和运行。 SPEC CPU目前比较新的是SPEC CPU 2006, SPEC主要是CPU性能测试，内存也有一部分，首先从官网下载压缩包.. 123# lsbenchspec config Docs install.bat LICENSE MANIFEST README redistributable_sources Revisions run.sh shrc.bat tools version.txtbin cshrc Docs.txt install.sh LICENSE.txt original.src README.txt result rr_moved shrc SUMS.tools uninstall.sh 解压后直接运行install.sh的话可能会有权限问题, 那么手动改权限↓: 1234find . -type d -exec chmod 755 &#123;&#125; ";"chmod 644 MANIFESTrm -rf bin./install.sh ↑中find找出所有的目录，并对每个目录调用chmod 755, &quot;;&quot;是为了结束chmod命令，否则这之后所有的东东都会作为chmod的参数。权限改为x + r。 之后删除已有的bin，安装即可。 Usage使用前需要修改shell 的source: (我用的zsh), 而后根据需要build和run我们的benchmark即可 123456source shrc# Buildrunspec --action build 429.mcf# Runrunspec --action onlyrun 429.mcf MiscSPEC的结果会放到result文件夹，跑一个比较慢，写个脚本跑一晚上第二天到result里面翻就行 PARSEC类似，下载解压: 1CHANGELOG CONTRIBUTORS FAQ LICENSE README bin config env.sh ext log man pkgs toolkit version Parsec的环境需要在bash中用，所以请先切到Bash, 而后用给的env.sh 12bashsource env.sh Usage1234# Replace 'streamcluster' to 'all' if you are going to test all benchmarksparsecmgmt -a build -p streamclusterparsecmgmt -a run -p streamcluster [-i simlarge [-n 2]]parsecmgmt -a fulluninstall -p streamcluster 具体参数自己可以查.. 这个跑一个比较快，结果直接就输出了，所以随手记就行。 Note一些依赖库↓: 1sudo apt-get install -y build-essentail m4 x11proto-xext-dev libglu1-mesa-dev libxi-dev libxmu-dev libtbb-dev gfotran libglib2.0-dev zlib1g-dev libxml2-dev gettext 其中dedup直接运行可能有一些问题, 需要替换一些东东: replace.sh123456#! /bin/bashfor i in 0 1 2 3 4 5 6 7 8 9do echo "Replacing '=item $i' to '=item C&lt;$i&gt;'" grep -rl "=item $1" * | xargs sed -i "s/=item $i/=item C&lt;$i&gt;/g"done Reference: parsec-3.0-installation-issues]]></content>
      <tags>
        <tag>tutorial</tag>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xen Log 16-Debug Key]]></title>
    <url>%2Fblog%2F2017%2F05%2F11%2Fxen-log-16-debug-key%2F</url>
    <content type="text"><![CDATA[之前介绍过Xentrace可以用来记录Hypervisor中发生的事情，不过有时我们希望手动触发print log的行为(比如观看此时Xen的页表结构、内存状态或者打印当前的cpu栈等等). 亦或是按下某个按键之后的Hypercall就会输出Log，再按一次后就停止输出Log等等。此时Xentrace或者手动添加Hypercall就不能满足我们的需求，而Xen提供了一套方便的接口可以解决这个问题: Debug Key Debug 系列: Add New Hypercall to Xen Debug Xen on Physical Machine Xentrace Debug Key(本篇) Register a key handlerDebug Key的使用同样非常简单，Xen的源码里面已经实现了一个用例: $XENDIR/xen/common/page_alloc.clink12345678910111213141516171819/* Code is in source is stale, you can refer it in latest xen source code */#include &lt;xen/keyhandler.h&gt;static void pagealloc_info(unsigned char key) &#123;...&#125;static struct keyhandler pagealloc_info_keyhandler = &#123; .diagnostic = 1, .u.fn = pagealloc_info, .desc = "memory info"&#125;;static __init int pagealloc_keyhandler_init(void)&#123; register_keyhandler('m', &amp;pagealloc_info_keyhandler); return 0;&#125; 代码中首先注册了一个key handler, 并通过register_keyhandler注册到按键m上, 之后定义 struct keyhandler变量并在其中指定handler函数pagealloc_info。而自己需要实现的功能 就在pagealloc_info中。 我们自己使用的时候可以再任何Xen的源文件中include xen/keyhandler.h而后按样例实现自己的函数即可，比如设置某个全局变量的值来控制log的打印和关闭等等。 Using debug key使用同样也很简单, 在dom0中输入: 123456789101112131415sudo xl debug-key msudo xl dmesg(XEN) Physical memory information:(XEN) Xen heap: 0kB free(XEN) heap[13]: 252kB free(XEN) heap[15]: 61184kB free(XEN) heap[16]: 3960kB free(XEN) heap[17]: 92328kB free(XEN) heap[18]: 123284kB free(XEN) heap[19]: 1031944kB free(XEN) heap[20]: 1492392kB free(XEN) heap[21]: 1501064kB free(XEN) heap[22]: 169628kB free(XEN) Dom heap: 4476036kB free debug-key需要xen tools的支持，因此安装了tool的dom0是调用debug-key最简单的地方。上面的log就是默认的pagealloc_info的信息输出。 Note如果根据Xen Log-5中配置配好了后，log同样是可以通过串口打印出来的，这又提供了一种方便的调试手段:)]]></content>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017网易游戏暑期实习面经]]></title>
    <url>%2Fblog%2F2017%2F05%2F02%2Fnetease-interview%2F</url>
    <content type="text"><![CDATA[到了找实习的时期，听说网易游戏福利不错所以就投了个简历，最后一路下来也是顺利拿到了实习Offer, 这里分享一下经历。 岗位是游戏研发岗。 投递简历一般来说到那时候随便上网搜搜就有，我是因为比较喜欢玩游戏，所以就顺手投了个网易游戏。网易游戏分网易互娱与雷火&amp;盘古。互娱做手游，雷火&amp;盘古做端游。 简历中英文都备一份，把大一到现在好看的东西往上填就行了…具体的简历写法网上一大堆我也是随便找了个模板改了改就上传了。 笔试网易游戏的面试题是在牛客网上在线做的，可以用本地IDE, 只能使用Java or C++, 其他语言不能用。一共3道题，2个半小时，第一第二题都不是很难，第三题我当时没做。 这里提醒一下，Java不知道牛客网那平台怎么实现的，匿名类用不了，我当时第一题是个非常简单的文本处理，用的Java, 1.7的JDE不能用lambda表达式，而且不支持匿名类， 用匿名类会报编译错误，所以请采用保守的方式编程，C++的话感觉要好很多， 我最后第一题就是因为这烂平台死活过不了。不过过了一道第二题就有面试机会了，也是挺意外的。 面试前收到面试通知后会发个链接，确认网上面试时间。我个人没怎么准备，之前面过其他的已经准备过面经之类的了，所以基本上就是裸上的。 面试网易游戏只有一面，面完就有结果，这一点我还是面完才知道的… 面试的时候牛客网的平台我听不到面试官的声音，最后采用电话面试，但是打字面试官还是可以看到的， 也方便发一些链接什么的，所以和网面差不多了。 自我介绍面试官先让自我介绍，以及传一份更新的简历等等。我由于研究生是系统方向，面试官好像不是很感兴趣，一直很关注我本科的项目经历。 项目经历听完自我介绍后面试官就开始问我各种简历上的项目经历，首先是研究生期间做的虚拟化部分，我做了简单介绍。之后是大四的软件测试和嵌入式开发，大三的LeapMotion和Android App开发， 之前接触过的Kinect开发等等。了解完后就开始问我熟悉的编程语言(我说的Java &amp; Pure C)。 了解到LeapMotion是做的有关一个游戏的内容后就开始问我详细内容，由于里面用到了交互设备和图形学的简单知识，问我了不了解OpenGL。(我说的不了解，但是说了一些概念)。 之后聊到 游戏开发引擎，我只说了我听说过Unity和Unreal.. 然后说的是我不了解，专业是系统方向。 游戏经历这个我其实挺意外的，面试官问了我好久的游戏经历，基本上先是从国内著名手游开始介绍，面试官问我端游，开始介绍网易代理的暴雪游戏、腾讯、盛大、空中网、久游代理过的游戏等等， 中间面试官问过我是不是只玩日系，我赶紧补充的韩国冒险岛、DNF、跑跑卡丁车，俄罗斯的战舰世界等等.. 还补充过页游弹弹堂。然后大吹自己游戏经历(小学三年级开始玩泡泡堂，一直吹到现在).. 面试官又问我是不是只玩网络游戏，又赶紧吹主机游戏Gravity, 仙境传说奥赛德(这两个是PSV上的游戏，当时舍友买的我玩过), 刚好当时Nier Automation刚出赶紧也是介绍一番。基本上都是说到 xx国xx开发商xx代理商xx平台的什么游戏，自己玩到什么程度等等，可能这个还挺加分的？ 语言知识之后面试官开始问C++问题，由于用的是Pure C, 所以其实这个答的非常糟，一度让我以为自己要被刷。我把纯虚函数和虚函数弄混了，vtable答了上来，普通的继承多态啥的根本不问， 导致我Java的知识根本用不上…问我有没有用过 C++和C交叉编译(没用过)、STL库(我没用过), 图形学的一些知识(不会)我当时真是尴尬万分…不过我说我用Lambda表达式，Java是1.8 的特性，C++里面是C++11的特性，面试官就问我Lambda的用法和好处，然后问我其他C++11的新特性有没有用过(没…) 算法&amp;数据结构算法题问了一道一串数只出现一次，给定一个输入，让返回所有数对，数对中的两个数之和等于输入。我考虑了1min回答两种思路，第一种快排后两边向中间遍历，大了右边-1，小了左边+1, O(nlogn)的复杂度，然后就是说不排序就和冒泡一样遍历，O(n2)的复杂度。 又问了游戏排行榜的数据结构应该怎么设计，我先说只取前几名的话堆排序，如果不是前几名的话要看查询多还是改动多，然后说目前只能想到BST。然后又聊会说可以先分组，再排序，就和Query 的select一样，最后join就可以了。后来上网上看了下，网上答案是桶排序和红黑树，虽然自己回答的不精确，不过看来思路还是差不多的。 之后要求我写快排，基本上就是说下思路就可以了，没什么难度。 操作系统可能面试官了解到我是系统方向，所以让我解释一个Hello World程序从C到最终运行起来的过程。 基本上就是先编译，得到Symbol, 链接器Resolve Symbol, Printf属于动态链接库里面的内容 所以涉及到GOT和PLT表，然后操作系统开新的进程，Load二进制文件，将控制流跳到程序入口Main函数执行等等。面试官听到动态链接库，又问了我一些动态链接库的内容和进程的地址空间和 内存的映射(基本上就是回答新进程的地址空间只是映射了Kernel代码，不用创建新的，动态链接库也是映射过来可以执行balabala) Misc.其中还问过我一些图形学的知识，不过我不是很了解，所以只是介绍了一下景深、3D里面摄像头balabala，把当时大三LeapMotion项目的内容说了一点点… 提问最后就是我问问题，我也就问了下网易研发和策划之间的协作和不同，研发是有自己的考核机制，也有与策划的反馈机制，所以可以影响游戏的设计，不过影响不大云云。 第二个问题就是问我这种方向差异比较大的要怎么跟进，面试官也是介绍了那边的培训制度，不用担心云云… 结果最后也是顺利拿到了实习的offer. 网易游戏的实习待遇还是挺不错的，除去薪资和补贴，有饭补、来回路费和员工宿舍。所以外地的小伙伴还是不用怎么折腾的。]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[完结]牙套日记]]></title>
    <url>%2Fblog%2F2017%2F04%2F10%2Forthodontics-life%2F</url>
    <content type="text"><![CDATA[长篇连载的牙套日记终于完结，经过三年的调整，牙齿已经尽可能变成了它最好的样子， 之所以说是尽可能是因为骨骼的原因上下牙的中线在咬合状态下不能正对齐，不过这也是大部分人的常态啦。 整体结果非常满意，在将近24岁才开始整牙的我说实话已经错过了黄金期， 这也是我前前后后花了3年多才结束矫治的原因，同样的情况对于一个青少年来说可能2年不到就可以结束了。 但是牙槽骨终身都是可以变化的，所以亡羊补牢，为时不晚吧~ 这里分享一些自己这三年带牙套的感受，也提供了矫治期间的一些照片以供参考(图片可能引起不适，请谨慎阅读~) 决定毕业后就在上海找工作的我重新考虑了一下整牙的事，牙齿比较拥挤而且还是深覆合，高中的时候一个私立牙医说要拔4颗牙还要4年…当时考虑会影响高考而且一时还难以接受4颗..就一拖再拖. 本科没怎么想过这事，最近多方咨询后决定开启牙齿正畸长篇单刷副本！ 两年半的漫长奋斗现在要开始了~ 希望最后能有一个不错的结果。 2017-04-10 - 2020-06-25 写在最前~2020-06-25正式结束矫治啦，首先去洗牙， 毕竟干净的牙齿才能帮助医生判断牙齿是不是还有未收好的缝~ 随后需要签一份同意书，然后医生才会取牙套。 说实话，我是真的没想到取托槽的过程如此的痛苦， 粘托槽的时候倒是轻轻松松，但是取托槽的体验非常糟糕： 首先取的过程是用小钳子一个个从牙齿上硬拽下来的！硬！拽！下！来！的！在拽下门牙的时候， 我都不自觉咬住了医生的手指…会有一些轻微的疼痛，不过想到马上就要去掉了，忍忍吧。 接下面，它会把牙齿上残留的胶一点点磨下来，磨！下！来！ 我开始以为这是个光敏的胶，有什么手段轻松就能再融化它擦掉呢， 你能想象将近半个小时脑袋都在嗡嗡嗡的感觉么？那个震动震得我都怀疑人生了， 比坐飞机引擎旁边都要令人不适， 真的是不愿再来第二遍了。 即使是这样还没完，由于紧接着会给保持器，所以需要取模， 取模的那个像橡皮泥一样的东西我猜是温度升高会变硬， 刚进嘴的时候是凉的，挺不舒服的…而且我还被取了3副，上下牙各3次… 明明刚洗完牙对冷热还非常敏感的啊！/(ㄒoㄒ)/ 最后还发现了左侧两颗智齿都已经快蛀的不行了，医生建议我尽快拔掉… 门牙也发现了有一点点蛀，唉。看来近期补牙、拔智齿不可避。 从此以后要过几年带保持器的日子了，不过对于我个人来说保持器没有什么不适， 平时除了饭点就不喜欢吃零食(担心会把键盘、鼠标沾上水果汁啊、零食油啊等等), 除了不能喝茶水(有颜色)，改回喝白开水意外并没有什么不适。 最后放一张最后的图吧~ 门牙中间黑黑的以前蛀过，后来补了后看起来现在又蛀了T T, 医生说一半这个都是小孩子会得的， 成年人很少看到门牙蛀的，可我也不知道怎么回事啊…门牙旁边那颗牙齿上的小黑点，也是蛀的… 我也不吃糖啊… 最后的效果就是这样啦，下牙也没有突起了，和三年前的对比还是非常大的~ 2020-06-15由于疫情的关系，加上我的主治医生刚好又是武汉旁边一个县的人， 基本上今年1月底年前最后一次复诊结束后一直到4月底都没能复诊。 从去年年初开始一直到现在，除了收缝就是收缝， 昨天最后复诊后，护士说这个月底看下没有缝隙的话就可以拆牙套了， 3年的牙套日记终于要完结了，Hiahiahia。 这次发一张照片，基本上是最后一张带牙套的照片了， 总的来说因为下巴骨骼有点歪，所以上下牙的中缝对的不齐， 但是上牙和下压分别跟嘴巴中线是对齐的， 咬合也没有什么问题。 到目前为止，位置调整最多的上门牙2号压基本上是旋转了90°， 但是现在这颗牙对冷热比较敏感， 喝稍微热点的水，或者吃冰的食物会感到酸。 医生建议我用一用抗过敏的牙膏， 也说这个过段时间就好了， 但是谁知道呢。 总的来说，整牙的过程没有想象中那么艰难， 最终个人感觉非常的满意。 2019-08-04这半年依旧是收缝，收缝是个缓慢且没有什么大变化的过程，需要依次将3、5、6、7(我拔的4号)号牙往门牙的方向一点点挪，一个半月挪一颗，每次复诊就是看看正在移动的牙齿有没有到位置， 如果没有达标，那么就要再加一个多月。所以这半年牙齿外观上没有变化，而我也惨兮兮的还在收第5号牙…每次去复诊都发现还有缝，所以基本上处于2-3个月收一颗牙的状态Orz。 照片已经将近1年没变化了，所以也就不更新啦~ 2019-02-24感觉和上次没有什么差别，上门牙已经比较齐了，中线也对住了，所以改为将后面的牙往前拉。 现在只剩左上角的4号和2号牙中间有一点点缝了。不过下门牙有点歪，整体有点偏左， 等到缝收好了考虑怎么弄吧。 2019-01-12基本上没怎么动，继续收缝，换橡皮筋… 2018-12-01换个橡皮筋，上下门牙中线不太齐，加了弹簧一起拉，和之前的照片差不多，就不放图啦~ 2018-10-21现在基本上就是收缝阶段，长期带橡皮筋，这里放一张暂时的收缝效果，这个也是最终的阶段了，收完缝如果有没对齐的对齐下就完工啦！ 2018-09-16医生姐姐感觉我的牙缝并没有缩小…发了包橡皮筋继续带，不知道什么时候能把缝收起来了o(╯□╰)o… 2018-08-04终于不用带平导了！进入收缝阶段，现在改成给我一包橡皮筋自己每天每天换了，橡皮筋一般极限是大半天，基本上大半天后吃饭的时候就会断掉，我一般是晚上睡觉前统一换。 2018-06-24复诊还是只把下面的弓丝换成了更粗的，平导和上面的弓丝没有动，把旧的橡皮筋换成了新的。 2018-05-12复诊仅仅只把下面的弓丝换成了更粗的，平导和上面的弓丝没有任何改变，所以照片不放了，没什么更新的。下面的四颗门牙已经移到了标准位置被用细钢丝紧紧拴在弓丝上固定好了。 2018-04-03这次的复诊调整了平导的厚度，整个平导缩小了一圈，主治医生说要开始收上门牙了(开心~(^▽^))。下边的门牙有点靠左歪，所以上了个推簧往中间推，上面的弓丝弄了两个”牵引钩”，上牵引钩的时候痛死我了…因为要使好大的劲把牵引钩给固定到弓丝上，不知道护士怎么弄的，我的牙当时非常痛orz.. 2018-03-05这次去复诊弓丝没有动，全程都在看护士打磨平导，最后用了一种神奇的东西和取模一样，直接放到平导上然后贴到我上颚，那个东西过一会就定好型了，平导再一次完美贴合上颚… 感慨一下技术的进步！用的材料应该是聚乙酸乙烯酯+什么东西，味道和小学的泡泡胶一模一样。 2018-01-25医生说需要再次带平导，因为现在下边的牙会挡住上边，所以上边的牙没有办法往里面收，所以这次复诊上面的弓丝没有换，只把下面的稍微加粗了一点。 基本上没有任何变化，就不不放照片啦.. 2017-12-25正常去复诊，去掉了橡皮筋，今天和主治医生聊了聊。目前的状况就是排齐上下， 等到排齐后根据侧脸的脸型再决定是门牙往里收还是大牙往外拉。 估计之后还要重新做平导，之前的模型已经不能用了，但是下门牙还是高。 2017-11-23正常复诊，准备收上门牙的牙缝，牙医说等到牙齿排齐后根据情况看需不需要带平导，如果需要的话重新做模~ 还是简单的换弓丝和橡皮筋。 2017-10-23这次去复诊简单换了下弓丝，下面把推簧去掉后连弓丝都没换就回来了。在医生建议下完成了人生第一次洗牙..和想的一样用超声波+水流，洗掉牙垢和结石后满嘴是血= =，一次将近200。 这次忘拍照了，就不放照片了。 2017-09-21因为门牙被挤歪的缘故，上牙龈被下门牙咬肿了orz，好在复诊后的牙痛已经差不多没了，之后就是等它慢慢挪位置了..这次的上弓丝有一边好扎嘴 终于体会到了满嘴伤的感觉. 2017-09-17约的周日复诊, 不知道是因为之前的助理周末不轮班还是什么情况，今天帮忙的好像是个实习生的样子，在弄牙套的时候感觉动作生疏很多(好几次隔的我牙龈痛)。 上弓丝也从1.2换到了1.6.. 橡皮筋都去掉了，不知道为什么O O。下面的弓丝没有换，好像是犬牙移动很难的样子，上次的推簧感觉把犬齿推到反方向来了，于是这次就在 犬齿和门牙间放了推簧..门牙都被推歪了T.T。 医生还质问我怎么不带平导了..(你不让我带的都忘了么..而且现在上牙都变成这样了，平导怎么可能还带的上去orz) 2017-08-12今天例行复诊,约的周六不影响实习，非常快基本上没有等，全程40min不到，一直是那个小姐姐在给我弄，也是辛苦小姐姐了。 下面的虎牙好像没怎么动, 这次加了一个推簧，下面两边都带上了橡皮筋；上面右边的橡皮筋已经去掉了，感觉牙齿的缝很大 不知道之后收的时候是什么样子.. 刚换完到晚上牙齿就非常酸软，没力气咬东西…希望过两天能好点 照片这次是用后置摄像头拍的，因为是镜子里的样子，所以左右反过来了..对比了一下上面那个原来歪的严重的右2号门牙已经基本上转过来了O O 2017-07-09本来是左边的橡皮筋掉了准备去重新挂一下，没有预约找了周六直接插空去的，早上9点等到快11点，助理说刚好一个月了就直接复诊。由于平导把下右2号牙压到里面去了，加上上门牙已经拉到外面， 上下错开了缝隙可以粘托槽了，所以就给下牙粘了托槽，平导也可以暂停一个月啦，哇咔咔~ 摘掉平导后大牙非常酸软，根本没力气咬东西，看来要过几天才能好了。 2017-06-08第一次复诊，平导只带了半个月左右，好像还没有什么效果..看网上的说法，平导应该是效果显著的吖…为什么我平导带上去一丁点作用都没 T.T。前面的1、2号牙已经往外拉出来了不少， 这次还带了两个橡皮筋想要把两个3号虎牙往两边拉。重新拉钢丝的时候还戳破了我的嘴，悲伤。 2017-05-30带了一周的平导，基本上适应了，大部分情况下说话都没问题，吃饭以米饭为主，饺子吃不了，面条吃起来非常慢，主要靠吞。不过整体来看还好，比开始的预计情况要好一些。 2017-05-23今天去上了平导…矫正深覆合真是惨，我还是重度深覆合(上牙都咬到下牙压根处了快..)。带上后嘴巴闭起来都费劲，没法发平舌音，大舌头.. 大牙咬不住，吃饭只能靠下门牙和上颚带的平导 相互摩擦..我这样的这情况估计得持续3个月..医生说要带起码半年，如果我不好好带就更长了.重度深覆合好烦T.T 2017-04-26上了上颚的托槽和弓丝，由于我是深覆合所以今天又取了次模(应该是拔完牙后设计平导用的吧, 只取了上半部分的模). 陶瓷的托槽带上去看上去并不是很明显，也算是达到了之前对陶瓷托槽的预期~ 带上半天的牙套只能感受到些微的张力，但是牙齿还不至于网上说的那种疼痛难忍的地步..就是以后吃完饭都要刷牙，早起晚睡再刷一次差不多一天要刷3-5次..这两年是告别火锅这种辛辣食物了。坚硬的坚果倒是可以打豆浆喝掉，本身自己就不怎么喜欢大鱼大肉和碳酸饮料，所以对饮食的影响也不算太过严重，还不错~ 2017-04-19拔了右侧的两颗牙，下5号上4号，上网搜了搜发现原来上下是可以不对称的…左边的伤口恢复的挺不错的，现在已经基本上看不到血痂了, 着手买正畸牙刷和冲牙器。顺便去校医院口腔科开了甲硝唑片和头孢等消炎药以防万一..医生还吐槽”正畸拔牙还吃什么消炎药…” 2017-04-10决定好了后就拍片、取模、缴费(一次性付清)、拔左侧上下4号牙, 这下算是上了船想跑都跑不了了:), 而且发现我的两颗门牙内测是有一点龋齿的.. 副产品:医生建议我拔那4颗智齿，突然间我要拔的牙从4变成了8… 2017-04-08决定好整牙后就开始踩点，九院的人实在太多排不上专家，而且听说九院也不便宜…打听其他公立和私立的，主要是不想排队。先去了家美容机构的牙科, 但总感觉不靠谱..最后…好叭，我信任了大众点评:) 对你没看错，是大众点评！选了一个评价还可以性价比比较高的齿科，具体的避免广告嫌疑就不透露了。 接待我的护士大致介绍了下牙套的种类，我这种状况需要多少年以及回答了我的各种问题…]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xen Log 15-Connect to Xenbus]]></title>
    <url>%2Fblog%2F2017%2F03%2F21%2Fxen-log-15-xenbus%2F</url>
    <content type="text"><![CDATA[XenBus是通过XenStore协商的一套协议，前端和后端通过XenBus进行协商最终建立起通信， 前端和后端都是状态机，而状态转换的条件就是由XenBus来完成的，本篇将介绍XenBus. 源码可以从Github上得到。 Grant Table I/O Ring Structure Event Channel Implementation Event Channel Usage XenStore Usage Write a PV Driver Connect to XenBus(本篇) XenBus The XenBus, in the context of device drivers, is an informal protocol built on top of the XenStore, which provides a way of enumerating the (virtual) devices available to a given domain, and connecting to them. Implementing the XenBus interface is not required when porting a kernel to Xen. It is predominantly used in Linux to isolate the Xen-specific code behind a relatively abstract interface.(from chapter 6.4[1]) XenBus由于是一个通信协议，因此不是必须要实现的(e.g.XenStore &amp; Console). 使用XenBus能够和Dom0上的Backend进行协商，不过我们同样可以实现自己的协议。 XenStore与Console也属于设备的一种，而这两者就是直接从start_info获取的，其余的外设则是通过XenStore进行交流. State Machinexenbus.hlink12345678910111213141516171819enum xenbus_state&#123; XenbusStateUnknown = 0, XenbusStateInitialising = 1, XenbusStateInitWait = 2, /* Finished early initialisation, but waiting for information from the peer or hotplug scripts. */ XenbusStateInitialised = 3, /* Initialised and waiting for a connection from the peer. */ XenbusStateConnected = 4, XenbusStateClosing = 5, /* The device is being closed due to an error or an unplug event. */ XenbusStateClosed = 6, /* * Reconfiguring: The device is being reconfigured. */ XenbusStateReconfiguring = 7, XenbusStateReconfigured = 8&#125;; 使用XenBus协议的设备状态有以上这些，其中Reconfigure我们暂不讨论，一般设备不重新配置的话是不需要这个状态的，状态的转换一般如↓: xenbus_client.clink123456789101112131415161718192021222324252627183: static int __xenbus_switch_state(struct xenbus_device *dev, enum xenbus_state state, int depth)&#123; struct xenbus_transaction xbt; int current_state; int err, abort; if (state == dev-&gt;state) return 0; xenbus_transaction_start(&amp;xbt); xenbus_scanf(xbt, dev-&gt;nodename, "state", "%d", &amp;current_state); xenbus_printf(xbt, dev-&gt;nodename, "state", "%d", state); err = xenbus_transaction_end(xbt, abort); dev-&gt;state = state; return 0;&#125; * xenbus_watch_path - register a watch * @dev: xenbus device * @path: path to watch * @watch: watch to register * @callback: callback to register115: int xenbus_watch_path(struct xenbus_device *dev, const char *path, struct xenbus_watch *watch, void (*callback)(struct xenbus_watch *, const char **, unsigned int)) 在xenbus.h中有所有状态的声明, 由switch_state进行状态的迁移，switch_state会通过XenStore接口(Linux中即XenBus接口)向XenStore实时写入目前设备的状态 由此另一端就能通过状态来判断是否是否应该读取某些值，通过这个协议前后端就可以进行协商(告知对方shared page的grant reference等) 而两端也都会在对方Xenstore的key上注册watch来监控变动，这样当一方状态改变时另一方就能迅速做出相应。 一般来说我们会把尽可能多的工作交给back来完成, 这样Guest的driver就可以尽可能简化, 而共享页等分配则交由Guest来做, 当然自己的Driver也可以不这么做..而前后端的状态会互相影响: 一般Back初始化后front才开始初始化, (front可能会从xenstore读一些关于back的信息)，back的初始化会用到front的一些数据(grant ref等), 因此在front初始化完成前back会进入Initwait等待front向xenstore中写入信息。之后当guest连接到bus后back也会连接到bus上，此时driver就可以正常工作了。 当任何一方断开时另一方也会断开。 Add State to Driver我们现在给前一篇完成的Driver中加入XenBus的状态: alice_dom0.clink1234567891011121314151617181920212223242526/* We set up the callback functions */static struct xenbus_driver alice_back_driver = &#123; .ids = alice_back_ids, .probe = alice_back_probe, .otherend_changed = alice_back_otherend_changed,&#125;;/* The function is called on a state change of the frontend driver */static void alice_back_otherend_changed(struct xenbus_device *dev, enum xenbus_state frontend_state)&#123; switch (frontend_state) &#123; case XenbusStateInitialising: set_backend_state(dev, XenbusStateInitWait); break; case XenbusStateConnected: set_backend_state(dev, XenbusStateConnected); break; ... default: xenbus_dev_fatal(dev, -EINVAL, "saw state %s (%d) at frontend", xenbus_strstate(frontend_state), frontend_state); break; &#125;&#125; 主要内容就是加入otherend_changed函数并在里面根据另一端的状态切换本端的状态。顺便提一下activate.sh需要给domU和dom0的Key加入读写权限: Manual of config ---->link123# Make sure the domU can read the dom0 dataxenstore-chmod $DOM0_KEY b0 r$DOMU_IDxenstore-chmod $DOMU_KEY b$DOMU_ID r0 Demo123456789101112# DomU: @domU: sudo insmod alice_domU.ko; dmesg | tail -n 5[ 70.232619] DomU: Alice_front inited![ 205.066293] DomU: Probe called.[ 205.069744] DomU: Connecting the frontend now[ 205.071032] DomU: Other side says it is connected as well.# Dom0@dom0: sudo insmod alice_dom0.ko; dmesg | tail -n 3[ 367.269307] Dom0: Alice_back inited![ 414.873681] Dom0: Probe called.[ 414.875169] Dom0: Connect the backend Reference The Definitive Guide to the Xen Hypervisor (Prentice Hall Open Source Software Development Xen - split driver, initial communication]]></content>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xen Log 14-Write A PV Driver]]></title>
    <url>%2Fblog%2F2017%2F03%2F20%2Fxen-log-14-pv-driver%2F</url>
    <content type="text"><![CDATA[Xen的PV Driver使用的是Split Model, 到这里现在也比较清楚前后端的交互方式了，通过Grant Table来共享I/O ring, 在ring中放入所需数据的grant reference, 并通过Event Channel机制来告知对方，而初始的grant reference则通过XenStore来进行共享。 在上一篇中我们了解了XenStore的作用和交互方式，本篇将实现一个最简单的PV Split Driver, 并通过向XenStore中写入相应的配置信息来激活驱动。 而在下一篇中我将加入XenBus的状态信息。 Grant Table I/O Ring Structure Event Channel Implementation Event Channel Usage XenStore Usage Write a PV Driver(本篇) Connect to XenBus 代码非常简单，没什么要说的，所以直接上代码:) DomU (Front End)alice_domU.clink123456789101112131415161718192021222324static int alice_front_probe(struct xenbus_device *dev, const struct xenbus_device_id *id)&#123; pr_info("DomU: Probe called.\n"); return 0;&#125;/* This defines the name of the devices the driver reacts to * So, this should be consistent with backend */static const struct xenbus_device_id alice_front_ids[] = &#123; &#123; "alice_dev" &#125;, &#123; "" &#125;&#125;;static struct xenbus_driver alice_front_driver = &#123; .ids = alice_front_ids, .probe = alice_front_probe,&#125;;static int __init init_alice(void)&#123; pr_info("DomU: Alice_front inited!\n"); return xenbus_register_frontend(&amp;alice_front_driver);&#125; 非常简单，调用xenbus接口中的xenbus_register_frontend函数即可，这个函数的作用就是在linux注册一个驱动.其中驱动的声明如↓ xenbus.hlink12345678910111213141516171819202185: struct xenbus_device_id&#123; /* .../device/&lt;device_type&gt;/&lt;identifier&gt; */ char devicetype[32]; /* General class of device. */&#125;;92: struct xenbus_driver &#123; const char *name; /* defaults to ids[0].devicetype */ const struct xenbus_device_id *ids; int (*probe)(struct xenbus_device *dev, const struct xenbus_device_id *id); void (*otherend_changed)(struct xenbus_device *dev, enum xenbus_state backend_state); int (*remove)(struct xenbus_device *dev); int (*suspend)(struct xenbus_device *dev); int (*resume)(struct xenbus_device *dev); int (*uevent)(struct xenbus_device *, struct kobj_uevent_env *); struct device_driver driver; int (*read_otherend_details)(struct xenbus_device *dev); int (*is_ready)(struct xenbus_device *dev);&#125;; 我们的驱动非常简单，只有名字和检测时调用的函数，完整的驱动把相应的回调函数指针填上即可。其中xenbus_device_id是用来在xenstore中分类到对应设备key下用的。 后端的代码和上面几乎一样，就不贴出来了。之后只要仿照其他设备的xenstore配置信息配一下就好: activate.shlink123456789101112131415161718DEVICE=alice_devDOMU_KEY=/local/domain/$DOMU_ID/device/$DEVICE/0DOM0_KEY=/local/domain/0/backend/$DEVICE/$DOMU_ID/0# Tell the domU about the new device and its backendxenstore-write $DOMU_KEY/backend-id 0xenstore-write $DOMU_KEY/backend "/local/domain/0/backend/$DEVICE/$DOMU_ID/0"# Tell the dom0 about the new device and its frontendxenstore-write $DOM0_KEY/frontend-id $DOMU_IDxenstore-write $DOM0_KEY/frontend "/local/domain/$DOMU_ID/device/$DEVICE/0"# Make sure the domU can read the dom0 dataxenstore-chmod $DOM0_KEY r# Activate the device, dom0 needs to be activated lastxenstore-write $DOMU_KEY/state 1xenstore-write $DOM0_KEY/state 1 写的时候可以xenstore-ls参考一下其他设备的写法就可以了。 Run Demo123456789101112131415alice@domU: sudo insmod alice_domU.koalice@dom0: sudo insmod alice_dom0.koalice@dom0: sudo ./activate.shalice@domU: dmesg | tail -n 2alice@dom0: dmesg | tail -n 2# Domain U[ 374.365006] DomU: Alice_front inited![ 432.006567] DomU: Probe called.# Domain 0[ 719.585539] Dom0: Alice_back inited![ 771.465989] Dom0: Probe called. 如果没有activate的话，probe相关的第二条log不会输出。 Reference Xen - a backend/frontend driver example]]></content>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xen Log 13-Xenstore Usage]]></title>
    <url>%2Fblog%2F2017%2F03%2F02%2Fxen-log-13-xenstore%2F</url>
    <content type="text"><![CDATA[XenStore是由Dom0维护的分层的存储系统(像一个小文件系统目录一样), 用于在Guest之间共享信息，通过Shared Memory来进行 数据共享。利用XenStore, Guest之间可以交流外设信息、Dom0可以读取到其他Guest的配置信息。 Hypervisor自身不会意识到XenStore的存在，XenStore的地址也是通过Shared_info page在Guest启动时进行map. 也因此Hypervisor中没有任何关于XenStore的Hypercall. 但是XenStore却是Xen中非常重要的一部分. 本篇将简单介绍XenStore和其使用。(用的是Linux 4.10.2) Grant Table I/O Ring Structure Event Channel Implementation Event Channel Usage XenStore Usage(本篇) Write a PV Driver Connect to XenBus What is XenStoreXenStore本质上是个软件实现的小数据库，使用&lt;key, value&gt;来存储信息，同时是个层级存储，Key之间可以类似目录一样拥有子Key. 一般习惯上一个Key只存value或children一种。 XenStore储存在一个树状数据库(Tree Database), 保存在/var/lib/xenstore/tdb文件中，由Dom0上的一个Daemon来维护，Daemon则由xencommons service进行管理。 Dom0会负责对数据库进行读写，并将接口通过Shared Page共享给所有的Domain. 所以在Dom之间共享的只有接口，并不是XenStore本身. 所有的DomU最终都是通过dom0 来对实际的XenStore进行操作的。↓ 共享的接口↓ Shared Interface (xs_wire.h)link12345684: struct xenstore_domain_interface &#123; char req[XENSTORE_RING_SIZE]; /* Requests to xenstore daemon. */ char rsp[XENSTORE_RING_SIZE]; /* Replies and async watch events. */ XENSTORE_RING_IDX req_cons, req_prod; XENSTORE_RING_IDX rsp_cons, rsp_prod;&#125;; Difference between XenBus这里需要注意下，在Linux中，XenBus是与XenStore进行交互的接口，因此关于Xenstore的代码在Linux源码中都是与Xenbus相关的部分，而在Xen中XenBus仅仅是一套交互协议， 用于连接到XenStore的设备协商时使用。所以在Linux中XenBus已经融合了XenStore. XenStore/XenBus in linux在Linux的XenBus初始化的时候会判断XenStore是不是在本地，如果是本地(dom0)就会对访问Xenstore的接口所占用的内存进行初始化。如果是DomU则会直接从start_info或hvm_get_parameter 来找到接口的地址并进行映射。 xenbus_probe.clink12345678910111213761: static int __init xenbus_init(void) &#123;...case XS_LOCAL: err = xenstored_local_init(); ...&#125;703: static int __init xenstored_local_init(void) &#123;.../* Allocate Xenstore page */ page = get_zeroed_page(GFP_KERNEL);&#125; 这个Page里面存放的就是两个ring, 一个用于请求，一个用于回复，xenbus backend 收到请求后会将数据写入对应的文件。 Message in ring通过前面接口的定义，可以发现与I/O使用ring传递gref不同，与XenStore的通信消息会直接放在ring中，而与Console还不同的是，XenStore的消息一次就要处理一个完整的请求，而非stream, 因此传递消息使用的就类似网络包的形式，每次都会发一个个msg过去，如果需要处理的内容太多，就会把多个消息放在一个transaction中。消息包的声明如↓ xs_wire.hlink12345678964: struct xsd_sockmsg&#123; uint32_t type; /* XS_??? */ uint32_t req_id;/* Request identifier, echoed in daemon's response. */ uint32_t tx_id; /* Transaction id (0 if not related to a transaction). */ uint32_t len; /* Length of data following this. */ /* Generally followed by nul-terminated string(s). */&#125;; type是request的类型，req_id是请求者自己维护的id号，用于判断response回复的是哪个request, tx_id用于多个消息放入一个transaction中时使用，len则是消息的长度。 Userspace usage在$XENDIR/tools/xenstore/目录下，实现了常用的用户态的工具，用法如下: 12345678910111213141516171819alice@amd-a10 : ~/VMConfig[0] % sudo xenstore-write /alice ""alice@amd-a10 : ~/VMConfig[0] % sudo xenstore-write /alice/foo baralice@amd-a10 : ~/VMConfig[0] % sudo xenstore-list /alicefooalice@amd-a10 : ~/VMConfig[0] % sudo xenstore-read /alice/foobaralice@amd-a10 : ~/VMConfig[0] % sudo xenstore-rm /alice/fooalice@amd-a10 : ~/VMConfig[0] % sudo xenstore-ls /alice 这些可以直接通过xenstore_daemon与xenstore进行交互, Kernelspace Usage但是对于DomU并没有这样的tool, 因此我们需要自己去找到xenstore inteface的位置并自己利用ring来进行通信。 我是在PVDom中使用Kernel Module, 利用同步的方法来与XenStore交互的，即是说发起1个请求后就立即通知BackEnd, 然后再轮询response. alice_pvdom.clink123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* Click link↗ to see full source code */int init_alice(void)&#123; /* xen_start_info is exported by linux, and inited when pvdom start up */ xenstore_gfn = xen_start_info-&gt;store_mfn; xenstore = gfn_to_virt(xenstore_gfn); /* get evtchn number, used to notify backend */ xenstore_evtchn = xen_start_info-&gt;store_evtchn; pr_info("Alice: Begin xenstore test\n"); alice_xs_read("name", buffer, 1023); pr_info("Alice: Name: %s\n", buffer); alice_xs_write("alice", "test"); alice_xs_read("alice", buffer, 1023); pr_info("Alice: read alice:%s\n", buffer);&#125;/* Read is similar */int alice_xs_write(char *key, char *value)&#123; int key_length = strlen(key); int value_length = strlen(value); struct xsd_sockmsg msg; /* Fill Message */ msg.type = XS_WRITE; msg.req_id = req_id; msg.tx_id = 0; msg.len = 2 + key_length + value_length; /* Write the message */ fill_request((char*)&amp;msg, sizeof(msg)); fill_request(key, key_length + 1); fill_request(value, value_length + 1); /* Notify the back end */ NOTIFY(); ... return 0;&#125;/* Fill request: (read_response is similar) */static int fill_request(char *msg, int len)&#123; int i; int ring_index; /* Wait for back end to clear enough space in buffer */ /* Message may be long, we will clean byte by byte */ for ( i = xenstore-&gt;req_prod; len &gt; 0; i++, len-- ) &#123; /* Copy bytes */ ring_index = MASK_XENSTORE_IDX(i); xenstore-&gt;req[ring_index] = *msg; msg ++; &#125; /* Ensure data is into ring */ wmb(); xenstore-&gt;req_prod = i; return 0;&#125; fill_request用于将请求拷贝到ring中, alice_xs_write则是构造一个消息包，(消息头、类型、req_id、长度为key和value的和), 字符串中间用’\0’进行分割。 填写完后通过Evtchn通知dom0, 由Daemon完成response的填写，read_response(没有贴出来代码) 会一直polling response, 发现response则读出来并输出。 我使用的是PV Domain上的Kernel module, 如果是HVM的话则要调用Hypercall来获取一开始的各种参数。 Running Demo123456789(ssh) alice@ryzen : ~/XenStore[0] % sudo insmod alice_pvdom.ko; dmesg | tail -n 3[140237.068340] Alice: Begin xenstore test[140237.068433] Alice: Name: Domain-0[140237.068544] Alice: read alice:test(ssh) alice@ryzen : ~/XenStore[0] % sudo xenstore-ls | grep alice alice = "test\000" 可见我们成功读出了写入的&lt;alice, test&gt;键值，通过xenstore-ls也可以查到。 Reference: XenStore: Configuration Database Shared between Domains The Definitive Guide to the Xen Hypervisor-Chapter8]]></content>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xen Log 12-Event Channel Usage]]></title>
    <url>%2Fblog%2F2017%2F03%2F01%2Fxen-log-12-using-event-channel%2F</url>
    <content type="text"><![CDATA[前一篇我们已经了解了Event Channel是如何被注册和被Hypervisor实现的，本篇将利用kernel module，使用Event Channel进行Guest间的通信。 Grant Table I/O Ring Structure Event Channel Implementation Event Channel Usage(本篇) XenStore Usage Write a PV Driver Connect to XenBus Event Channel OPs$XENDIR/xen/include/public/event_channel.hlink123456789101112131415/* ` enum event_channel_op &#123; // EVTCHNOP_* =&gt; struct evtchn_* */#define EVTCHNOP_bind_interdomain 0#define EVTCHNOP_bind_virq 1#define EVTCHNOP_bind_pirq 2#define EVTCHNOP_close 3#define EVTCHNOP_send 4#define EVTCHNOP_status 5#define EVTCHNOP_alloc_unbound 6#define EVTCHNOP_bind_ipi 7#define EVTCHNOP_bind_vcpu 8#define EVTCHNOP_unmask 9#define EVTCHNOP_reset 10#define EVTCHNOP_init_control 11#define EVTCHNOP_expand_array 12#define EVTCHNOP_set_priority 13 0-2 分别是绑定到不同类型的Evtchn上 3用来关闭Evtchn 4用来发送一个Event 5用来查询当前Evtchn的状态 6用于申请一个空闲的未被绑定的evtchn用于Interdomain的通信 7用于不同cpu间的通信 8用于evt到来时通知哪一个vcpu, ipi通知相关vcpu, per-vcpu virq通知相关vcpu, 但是其他的默认都是通知vcpu0的。 9用于启动某个evtchn (unmask用于启用) 10用于关闭和一个domid相关的所有evtchn 11-13 FIFO实现的Evtchn的相关操作 如果想要完成不同dom间通信，需要dom1申请一个未绑定的evtchn, 接受者绑定这个evtchn，而后将本地的中断绑定到这个evtchn，之后就和普通的中断处理一样了。 我的demo中会由domU申请，dom0绑定并通知domU, domU收到通知后在handler中再通知dom0, 而后dom0退出。 DomU ModuleAlloc Event channelalice_domU.clink12345678struct evtchn_alloc_unbound alloc_unbound;int err;alloc_unbound.dom = DOMID_SELF;alloc_unbound.remote_dom = DOM0_ID;/* Get a unbound evtchn */err = HYPERVISOR_event_channel_op(EVTCHNOP_alloc_unbound, &amp;alloc_unbound); 通过Hypercall来申请一个evtchn, Hypervisor会将值填入evtchn_alloc_unbound中 Alloc IRQ and Bind to Evtchnalice_domU.clink1irq = bind_evtchn_to_irq(global_info.evtchn); bind_evtchn_to_irq是linux封装的函数，其实现如↓ $DIR/drivers/xen/events/events_base.clink123456789101112131415161718int bind_evtchn_to_irq(unsigned int evtchn)&#123; ... irq = get_evtchn_to_irq(evtchn); if (irq == -1) &#123; irq = xen_allocate_irq_dynamic(); irq_set_chip_and_handler_name(irq, &amp;xen_dynamic_chip, handle_edge_irq, "event"); ret = xen_irq_info_evtchn_setup(irq, evtchn); /* New interdomain events are bound to VCPU 0. */ bind_evtchn_to_cpu(evtchn, 0); &#125; return irq;&#125; 在首次绑定的时候，linux会动态申请一个中断号，并配置好相应的描述符，并默认绑到vcpu0上 Bound IRQ Handler to IRQalice_domU.clink123static irqreturn_t domU_handler(int irq, void *dev_id) &#123; ... &#125;err = request_irq(global_info.irq, domU_handler, 0, "alice_dev", &amp;global_info); 这里定义好Handler函数后调用request_irq将Handler进行注册; request_irq实现如↓ $DIR/kernel/irq/manage.clink1234567891011121314151617181634: int request_threaded_irq(unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned long irqflags, const char *devname, void *dev_id)&#123; ... desc = irq_to_desc(irq); action = kzalloc(sizeof(struct irqaction), GFP_KERNEL); action-&gt;handler = handler; action-&gt;thread_fn = thread_fn; action-&gt;flags = irqflags; action-&gt;name = devname; action-&gt;dev_id = dev_id; retval = irq_chip_pm_get(&amp;desc-&gt;irq_data); retval = __setup_irq(irq, desc, action); return retval;&#125; 可以发现， 函数将handler填入中断的描述符中后调用__setup_irq完成对中断的配置，这样Handler就与IRQ绑定了起来。 Notify via IRQalice_domU.clink1234567static irqreturn_t domU_handler(int irq, void *dev_id)&#123; ... pr_info("DomU: Handled! irq: %d, evtchn:%d\n", irq, info-&gt;evtchn); notify_remote_via_irq(irq); return IRQ_HANDLED;&#125; 这样domU就可以通过irq来通知远端，notify_remote_via_irq则是直接调用HYPERVISOR_event_channel_op(EVTCHNOP_send, &amp;send) 让Hypervisor帮忙去set相应的pending bit. Dom0 Moduledom0的Module原理上和domU类似，不同的是dom0不需要自己申请空闲的evtchn, 只需要直接绑定到domU的evtchn即可，并且linux中已经把上述过程都封装好了.. alice_dom0.clink12err = bind_interdomain_evtchn_to_irqhandler(global_info.remoteDomID, global_info.evtchn, dom0_handler, 0, "alice_dev", &amp;global_info); 这个函数的执行过程和上面的过程类似，就不展开了。 Running Demo12345678910/* In domU, sudo insmod alice_domU.ko; dmesg */[ 81.340632] DomU: Get new evtchn: 32[ 81.340670] DomU: Bound local irq: 69 to evtchn:32[ 114.224679] DomU: Handled! irq: 69, evtchn:32/* IN dom0, sudo insmod alice_dom0.ko domid=id port=port; dmesg */[79383.358635] Dom0: init info with remoteDomID:6, port:32[79383.363885] Dom0: Handled, domid: 6, port: 32, local_irq:95[79383.363902] Dom0: bound local irq:95 to evtchn:32[79383.374352] Dom0: Handled, domid: 6, port: 32, local_irq:95 刚启动dom0的module后，dom0会立即处理一次中断，可能是之前的bit没有清掉导致的… 第二次的Handle则是domU通知的。]]></content>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xen Log 11-What Color Is Your Guest]]></title>
    <url>%2Fblog%2F2017%2F02%2F28%2Fxen-log-11-what-color-is-your-guest%2F</url>
    <content type="text"><![CDATA[PV, HVM, PV-on-HVM, PVHVM, PVH… Xen在刚提出的时候针对的是二进制模拟下的虚拟化低效问题, 而随着Intel与AMD不断推出支持虚拟化的硬件后，使用PV已经不再是一个最恰当的选择。而如今，Xen 已经有了眼花缭乱的各种模式，本文将介绍他们之间的区别。 本文参考了Brendan Gregg’s Blog Xen Modes: What Color Is Your Xen The Virtualization Spectrum Full Virtualization虚拟化最开始的提出是因为硬件资源的不均衡，大企业拥有大量硬件但是没有那么大的需求，而小企业架一个网页就需要购买昂贵的服务器。因此，虚拟化的目的在于如何让硬件资源被多个客户使用，而客户在虚拟化场景下应该和跑在正常硬件上一样。 于是大家想用软件模拟各种硬件，从OS的启动到各种外设，所使用的“二进制重写”就是理解二进制码的语义，再用 软件进行模拟执行。这种模式就是Full Virtualization. 由于每次执行都要经过一轮软件的模拟，因此这种效率非常低，难以被接受。 Para VirtualizationXen为了解决低效这一问题，提出让OS知道自己运行在虚拟化场景下，这样就意味着可以对OS进行代码的少量修改， 具体的可以参考Xen and the Art of Virtualization(SOSP 2003). 简单来说，vcpu直接运行在CPU上，所有的特权指令(syscall等)全部改为调用hypercall, hypercall是另一个中断 作用于syscall类似，此时控制流会从ring3降到ring0, 经由hypervisor处理后再返回。 由于Guest要使用自己的页表(即自己的cr3)将gva(Guest Virtual Address)翻译为gpa(Guest Physical Address), Hypervisor也要使用扩展/嵌套页表(Extended/Nested Page Table)将gpa翻译为map/hpa(Machine/Host Physical Address). 在只有一个CR3的情况下， 就需要引入影子页表(Shadow Page Table), shadow PT 会遍历Guest PT和EPT/NPT，并将gva直接翻译为mpa保存在Shadow PT中，CR3里面放到就是Shadow PT. I/O DomU与Dom0直接通过split driver, domU中运行frontend, dom0中运行backend, 通过内存共享来实现数据共享。 Kernel 和 initrd在使用存放在dom0中的disk直接进行加载。 PV or FV ?在Guest启动后通过查看lscpu即可非常简单的了解自己是在PV还是FV下: FV↓ alice@pvhvm:~$ lscpu ... Stepping: 1 CPU MHz: 4092.612 BogoMIPS: 8193.82 Hypervisor vendor: Xen Virtualization type: full L1d cache: 16K L1i cache: 64K L2 cache: 2048K NUMA node0 CPU(s): 0,1 PV Guest↓ % lscpu ... CPU MHz: 4092.612 BogoMIPS: 8185.22 Hypervisor vendor: Xen Virtualization type: none L1d cache: 16K L1i cache: 64K L2 cache: 2048K NUMA node0 CPU(s): 0-3 PV的Virtualization Type是None. 或者查看 dmesg : dmesg | grep -i xen alice@pvhvm:~$ dmesg | grep -i xen [ 0.000000] DMI: Xen HVM domU, BIOS 4.5.1 12/22/2016 [ 0.000000] Hypervisor detected: Xen [ 0.000000] Xen version 4.5. alice@pv:~$ dmesg | grep -i xen [ 0.000000] bootconsole [xenboot0] enabled [ 0.000000] Booting paravirtualized kernel on Xen [ 0.000000] Xen version: 4.5.1 (preserve-AD) [ 0.000000] xen:events: Using FIFO-based ABI Hardware Virtualization Support随着软硬件技术的发展，安全问题变得日益重要，这时业界发现虚拟化是一个完美的沙箱，可以极大提高安全性。 因此在安全日益重要的如今，虚拟化再次得到了极大发展。Intel和AMD也针对传统虚拟化中的各种问题提供了硬件的虚拟化支持VT-x 与 SMV 硬件的虚拟化支持主要针对的是CPU和Memory, CPU拥有了VMRUN / VMENTER指令，Non-root与root模式，这就避免了以往特权指令在ring0与ring3行为不一致，部分特权指令在ring3不下陷使得下层Hypervisor无法捕获的问题。 Memory则提出了EPT / NPT, 使得Guest和Hypervisor可以分别使用一个寄存器来完整两轮的翻译，Shadow Page Table也不再被使用，因此硬件虚拟化后的CPU与Memory变成了主流。 I/O则需要由各个厂家来实现(Single Root I/O Virtualization), 使一个外设能够同时被多个Guest占用。 由于硬件对虚拟化的支持，HVM的性能已经不再是其缺点，I/O由于支持不如CPU, Memory普遍，因此目前的虚拟机都采用了混合(Hybrid)的模式. PV Drivers模拟的Driver需要通过软件来模拟所有中断过程，但是PV Drivers则通过Grant table 和 event channel, 借助 共享内存将数据交给dom0, 而dom0负责直接在物理设备上进行读写。 从dmesg中可以看出是否使用的是PV Driver. 在HVM上使用PV Drivers的话需要在配置文件加上 1xen_pci_platform = 1 alice@pvhvm:~$ dmesg | grep -i xen ... [ 0.000000] DMI: Xen HVM domU, BIOS 4.5.1 12/22/2016 [ 0.000000] Hypervisor detected: Xen [ 0.000000] Xen version 4.5. [ 0.000000] Xen Platform PCI: I/O protocol version 1 [ 0.000000] Netfront and the Xen platform PCI driver have been compiled for this kernel: unplug emulated NICs. [ 0.000000] Blkfront and the Xen platform PCI driver have been compiled for this kernel: unplug emulated disks. PV Driver会unplug 模拟设备。 PV Timer &amp; InterruptFull Virtualization模式下，中断要通过软件模拟的PIC、PIC bus, local APIC, IO APIC等等来实现，软件模拟的开销很大，而PV Interrupt则利用Callback 由Hypervisor直接转给目标Domain. [ 0.000000] Booting paravirtualized kernel on Xen HVM [ 0.000000] xen: PV spinlocks enabled [ 0.000000] xen:events: Using FIFO-based ABI [ 0.000000] xen:events: Xen HVM callback vector for event delivery is enabled [ 0.083041] clocksource: xen: mask: 0xffffffffffffffff max_cycles: 0x1cd42e4dffb, max_idle_ns: 881590591483 ns [ 0.083056] Xen: using vcpuop timer interface [ 0.083068] installing Xen timer for CPU 0 [ 0.084000] installing Xen timer for CPU 1 [ 0.216361] xen: --> pirq=16 -> irq=9 (gsi=9) vcpuop timer interface表明使用了PV Timer, HVM callback vector表明使用了PV Interrupt PVH在VT-x + EPT, SMV + NPT出现后，PV下的Memory(使用Shadow PT), 反而变成了性能的瓶颈，而VT-x 与 SMV则拥有更好的隔离性与安全性。因此PV在原来的基础上采用这套硬件虚拟化技术后就变成了PVH. 也是目前性能最高的混合模式PDF。 使用PVH的话需要在编译Kernel的时候配置CONFIG_XEN_PVH=y. 可以参考wiki. Setup Flow最后附上一张Xen启动的检查流↓ (Copied from Brendan’s Blog)]]></content>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xen Log 10-Event Channel Implementation]]></title>
    <url>%2Fblog%2F2017%2F02%2F20%2Fxen-log-10-event-channel%2F</url>
    <content type="text"><![CDATA[I/O Ring能够让我们通过共享内存传输数据，但是在准备好数据后又该如何告知远端的Dom呢？因此类似中断，这里就要用到Event_Channel来进行异步通知。Event Channel是Xen提供的一套 等价于硬件中断的通信机制，其融合了Physical Interrupt, Virtual Interrupt和Inter/Intradomain Communication. 本篇博文分为两部分，这篇介绍Event Channel的实现机制，另一篇介绍Event Channel如何在Guest中使用。 Grant Table I/O Ring Structure Event Channel Implementation(本篇) Event Channel Usage XenStore Usage Write a PV Driver Connect to XenBus Event Channel ModelEvent Channel是Xen提供的通信机制，Xen允许Guest将以下四种中断映射成为Event Channel。 利用Pass-through的方式将硬件直接交给某个Guest，或使用支持SR-IOV的硬件时是可以直接使用这个中断的。 但是Guest有的时候需要一些中断(e.g. 时钟中断)来完成某个功能，因此Xen提供了虚拟中断(VIRQ)，Hypervisor设置某个bit使得Guest以为有了中断。 Interdomain communication, Domain之间的通信需要依赖某个机制。 Intradomain communication, Domainn内部通信，属于Interdomain Communication的一种特殊情况, (DomID相同，cpuID不同) 在Event Channel部分, remote port往往与evtchn互换使用，而local port则与irq互换使用。 一个Guest会通过Event Channel绑定到一个时间源上，并设置对应的handler. Event Source可以是另一个dom的port(Case 3, 4), 真实的物理中断(Case 1)或者一个虚拟中断(Case 2)。当Event Channel建好后，事件源就可以通过这个Channel发通知给接收端。 Event Channel Model12domM irq_handler&lt;--- bound ---&gt;local_irq &lt;--- bound ---&gt;port/evtchn&lt;---(bound)---&gt;Event Source PV Guest (No CPU Hardware Virtualization)PV Guest由于可以对Kernel进行修改，因此Event是通过callback来完成的。Guest在初始化的时候会利用Hypercall注册好callback的handler, 每次Xen调用callback时直接跳转到handler中 PV Register CallbackBoot_Code1234567891011121314151617181920212223242526272829303132333435/* $DIR/arch/x86/kernel/setup.c: 851: */void __init setup_arch(char **cmdline_p) :-&gt; x86_init.oem.arch_setup(); /* ↑ This function pointer is initialized in $DIR/arch/x86/xen/enlignted.c: http://lxr.free-electrons.com/source/arch/x86/xen/enlighten.c 1576: x86_init.oem.arch_setup = xen_arch_setup;*//* $DIR/arch/x86/xen/setup.c */1032: void __init xen_arch_setup(void) :-&gt; if (!xen_feature(XENFEAT_auto_translated_physmap)) xen_pvmmu_arch_setup();1015: void __init xen_pvmmu_arch_setup(void)&#123; ... if (register_callback(CALLBACKTYPE_event, xen_hypervisor_callback) || register_callback(CALLBACKTYPE_failsafe, xen_failsafe_callback)) BUG(); xen_enable_sysenter(); xen_enable_syscall();&#125;964: static int register_callback(unsigned type, const void *func)&#123; struct callback_register callback = &#123; .type = type, .address = XEN_CALLBACK(__KERNEL_CS, func), .flags = CALLBACKF_mask_events, &#125;; return HYPERVISOR_callback_op(CALLBACKOP_register, &amp;callback);&#125; 可以发现，Linux最终通过调用HYPERVISOR_callback_op(callback_register, &amp;callback)将xen_hypervisor_callback()与xen_failsafe_callback()注册成为Upcall的Handler和失败处理。 每当有一个Event时，Xen会set shared_info中对应vcpu的event map的对应bit, 再通过这个upcall来通知Guest, 控制流会直接跳转到xen_hypervisor_callback()中， 这个函数定义在arch/x86/entry/entry_64.S or entry_32.S中, 处理逻辑与中断类似，保存当前状态并跳到实际的处理函数xen_evtchn_do_upcall。在实际的处理函数中会去查event map中的bit并调用相应的函数进行处理。 过程如下123Hypervisor --- Callback ---&gt; Guest Callback Handler---&gt; Save state ---&gt; Event Handler ---&gt; xen_evtchn_do_upcall HVM Guest (CPU Hardware Virtualization)在引入HVM后，根据不同程度虚拟化可以将Guest分为下述几类 关于上面这幅图的详细介绍以及如何确定自己的Guest运行在哪个模式下，在下一篇博文中我会详述。 这里为了提高性能，我之后主要使用的是PVHVM, 充分利用CPU和内存/MMU的硬件虚拟化，同时利用PV Driver (Split drivers in Xen)和Interrupt与Timer。与PV不同的是HVM使用了CPU的硬件虚拟化，拥有root和non-root模式 Hypervisor不可能单单使用Callback跳转到ring3, 必须使用VMENTER/VMRUN进入non-root。 HVM中CPU虚拟化提供了VMCS(Intel)/VMCB(AMD), 在VMENTER/VMRUN之前设置里面的对应bit，就可以在回到Non-root模式的时候引起Guest的中断处理。 因此，Hypervisor所需要做的就是设置引起中断的bit即可。 Guest Register CallbackBoot_Code 12345678910111213141516171819202122/* $DIR/arch/x86/xen/enlighten.c */1864: static void __init xen_hvm_guest_init(void) :-&gt; 1880: x86_init.irqs.intr_init = xen_init_IRQ;/* $DIR/drivers/xen/events/events_base.c */1678: void __init xen_init_IRQ(void):-&gt; 1703: xen_callback_vector();1649: void xen_callback_vector(void): -&gt; rc = xen_set_callback_via(callback_via);/* callback_via is HYPERVISOR_CALLBACK_VECTOR: 0xf3 */int xen_set_callback_via(uint64_t via)&#123; struct xen_hvm_param a; a.domid = DOMID_SELF; a.index = HVM_PARAM_CALLBACK_IRQ; a.value = via; return HYPERVISOR_hvm_op(HVMOP_set_param, &amp;a);&#125;-&gt; alloc_intr_gate(HYPERVISOR_CALLBACK_VECTOR, xen_hvm_callback_vector); 可以发现，Guest 通过调用HYPERVISOR_hvm_opHypercall 告诉Xen有一个HVM_PARAM_CALLBACK_IRQ, 在Xen Hypervisor中，会根据via传来的参数创建一个新的irq。via是callback的vector号。 而后Guest会为这个vector分配一个中断。 $DIR/arch/x86/entry/entry_64.Slink12914: apicinterrupt3 HYPERVISOR_CALLBACK_VECTOR \ xen_hvm_callback_vector xen_evtchn_do_upcall 最终xen_hvm_callback_vector会由xen_evtchn_do_upcall来处理， Hypervisor Set VMCB According to Pending Bit而在Hypervisor中，每次 VMRUN/VMENTER会查询之前注册的号，如果发现有被set的就会在VMCB/VMCS里面set中断位，在VMRUN/VMENTER后Guest就会去处理相应的逻辑。 Hypervisor_check1234567891011121314151617181920/* $XENDIR/xen/arch/x86/hvm/svm/intr.c */135: void svm_intr_assist(void) -&gt; 146: intack = hvm_vcpu_has_pending_irq(v); /* Check pending bit */-&gt; 197: if ( unlikely(vmcb-&gt;eventinj.fields.v) || intblk ) /* Set VMCB *//* $XENDIR/xen/arch/x86/vhm/irq.c */in hvm_vcpu_has_pending_irq(v) &#123;.../* Check evtchn_upcall_pending */ if ( (plat-&gt;irq.callback_via_type == HVMIRQ_callback_vector) &amp;&amp; vcpu_info(v, evtchn_upcall_pending) )...&#125;/* $XENDIR/xen/arch/x86/hvm/svm/entry.S */ENTRY(svm_asm_do_resume)-&gt; 37: call svm_intr_assist...VMRUN... 因此每次VMExit处理完后，Hypervisor都会检查pending的中断并设置VMCB中相应的bit，在VMRUN的时候Guest会进入中断处理来处理Event。 过程如下12345Hypervisor --- Check Pending bit ---&gt; Set VMCB/VMCS---&gt; VMRUN/VMENTER Guest --- Interrupt ---&gt; Callback---&gt; Callback handler ---&gt; xen_evtchn_do_upcall Real Handler: xen_evtchn_do_upcall无论是PV还是HVM, 最终Event都会交由xen_evtchn_do_upcall来处理: $DIR/drivers/xen/events/events_base.clink123451253: void xen_evtchn_do_upcall(struct pt_regs *regs)1263: -&gt; __xen_evtchn_do_upcall();1228: static void __xen_evtchn_do_upcall(void)1240: xen_evtchn_handle_events(cpu); 之后xen_evtchn_handle_events会根据event的实现采用2l/fifo的event_channel来处理，(以fifo为例), $DIR/drivers/xen/events/events_fifo.clink12345678327: static void __evtchn_fifo_handle_events(unsigned cpu, bool drop)339: -&gt; consume_one_event(cpu, control_block, q, &amp;ready, drop);282: static void consume_one_event(unsigned cpu, ...)321: -&gt; handle_irq_for_port(port);273: static void handle_irq_for_port(unsigned port)279: -&gt; generic_handle_irq(irq); 之后就和普通处理irq的逻辑一样了, 查找对应的描述符并调用相应的处理函数，Event Channel至此就再次被转换为上层的IPI、VIRQ或IRQ. 在2-level ABI(2l)的中是通过查找shared_info中的bitmap来处理event的，但是最终也会调用generic_handle_irq回到统一的处理逻辑上。 SummaryXen提供的Event Channel是Hypervisor中的一种机制，对于上层Guest来说其目的是将IRQ、VIRQ、IPI借助Event Channel这一统一形式进行传递。从而实现异步通信。 在发升IRQ的时候Guest都会进行下陷，由Hypervisor去set相应的bit, 不过一种新技术Post-Interrupt可以在不下陷的情况下完成这一要求, 有机会再详细介绍。]]></content>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016 追番总结]]></title>
    <url>%2Fblog%2F2017%2F01%2F09%2F2016-acg-summary%2F</url>
    <content type="text"><![CDATA[说到年终总结怎能没有ACG的总结，和工作睡觉一样占据我生活近三分之一的娱乐(除运动和社交)活动当然也要总结一下啦~ 去年的感觉过于冗长和啰嗦.. 今年就挑重点的来说吧，好看的说说个人感想，不好看的就当个排雷~ 17年的新番已蓄势待发，16年的动画也都全部完结…依旧是长文不过无图放心戳=v= 追番带有带有极强的个人主观意见，不喜轻喷~ 导航: 1月番, 4月番, 7月番, 10月番 满分5分 2016 1月番春＆夏推理事件簿/ハルチカ ～ハルタとチカは青春する～-P.A.WORKS 3打着推理番的口号，实际上是一部音乐、推理、恋爱校园番。女主典型元气少女，男主弱气文学少年，与其说是看推理不如说是看女主卖萌，剧情不出彩逊于冰菓。。 僕だけがいない町/只有我不在的街道-A-1 Pictures 4一个回到过去的男主拯救女主的故事，虽然最后救出来的女主不是自己的233。动画对于人物关系和剧情的把握非常到位，从曾经的事件到最后令人大跌眼镜的结局， 可以说完成了一个故事的全部过程而没有烂尾。对小孩之间的关系描写的非常到位，两人从疏远到熟识，让作为观众的我开心的同时也为男主捏了把汗。结局的出人意料还是给本作加分不少的。 Myriad Colors Phantom World/無彩限のファントム・ワールド/无限彩的怪灵世界-京都动画 3.2京阿尼的作品质量是毋庸置疑的，然而本作的剧情较为一般，女主卖萌可以看，校园生活可以看，作为怪物可以说是作者的奇思妙想。但是由于过于超脱常理而使得作品的剧情有些傻气， 有种看了降智商的感觉，快餐般的作品看过后也不会留下深刻的印象。 Dimension W~维度战记~/ディメンション W-Studio 3Hz, ORANGE 4.2男主是不合时代的武士，背景是机器人成熟的世界，围绕线圈这一机器人心脏般的物件，男主和女主闯过一个又一个事件。与人型电脑天使心的男主一样，捡到了一个非常厉害的机器人， 不过本作的男主本身实力强劲，女主则表现平平。但这样的好处是打斗看男主耍帅，日常看女主卖萌，使得作品的严肃与搞笑达到了相对的平衡。剧本还算可以接受，值得一看。 疾走王子/プリンス・オブ・ストライド オルタナティブ/Prince of Stride Alternative-MaDhouse 3.7一部女性向的番男主自然都帅的一比，各类男生任君挑选(误)。与以往的运动番不同的是疾走是作品虚构的类似跑酷的运动项目，而运动番的成功与否则在于能否营造出紧张的气氛。 这部番最大的特点在于虚构的疾走项目非常帅气，跑酷本身就很帅了，而现在跑酷还要进行竞技则给帅气的运动加上紧张的气氛，完全不逊于其他热血运动番。 だがしかし/粗点心战争-feel 4卖福利的番，但又不是纯卖肉的番。能够把粗点心这种平日不起眼的东西作为剧情的主线可以说这作者的脑洞也是突破天际，女主给福利，顺带普及日本粗点心豆知识，风格别具一格因此 值得一看。 石膏ボーイズ/石膏男孩-LIDENFILMS 4.1不得不说，这番简直有毒。我从来没想过我会看4个完全不会动的石膏，槽点满满番也是着重突出这些槽点使得该番成功达到了轻松愉快的搞笑番的目标。不得不说依旧是个脑洞神奇的番，强烈至少 看个几集感受一下~ Note苍之彼方的四重奏，神圣之门，少女们向荒野进发，机动强袭是第八组，最弱无败神装机龙，幸运逻辑，命运九重奏实在是无聊，直接略过。 历物语，为美好的世界献上祝福，妖精的尾巴Zero，高达，无头骑士异闻录，亚人，赤发白雪姬2，暗杀教室2都是粉丝向。个人都是很喜欢~ 1月番的质量整体不错，加上有寒假所以我追的也比较多，几乎全追了…惊奇的脑洞也给年假带来了不一样的乐趣。 2016 4月番Ｒｅ：ゼロから始める異世界生活/Re:从零开始的异世界生活/Re:Life in a different world from zero-White Fox 4.2哭瞎了一批人的番，个人由于不喜欢女一所以最后没有再追下去而是看了小说，但是不得不说虐人的番有，但是虐你千百回的番倒是不多。正如题目所示，如果是Bad End那么回档重来，平时玩游戏 感觉神一般便利的机能在动画里反而变成了一幕幕的悲剧，男主拼命去抵抗命运以求改变故事的结局。与命运石之门一气呵成，最终救出女主不同，本番一个个事件的去改变故事发展便不会向命运石之门那般严峻，同时感情线的描绘非常不错，不是后宫花心男主反而让观众为失恋的女儿哭的不要不要的。 文豪野犬-BONES 3.6剧情本身还不错，但是动画制作的质量不高，所以第二季的文豪野犬明显要好看很多。借用日本大文豪之名和著作为灵感构思主角们的能力这一点倒也不是非常新鲜，但是骨头社的良心还是为本作 创出了不错的口碑，除了动画制作有点水以外= = 剧情还是可以的。 坂本ですが/我叫坂本我最Dio-Studio DEEN 4.7没想到看人装逼的番是如此的爽，此番剧毒无比，如果电波对上了简直笑的停不下来，一边吐槽男主妈的智障，一边又看着男主各种装逼。 (自己小时候脑中YY的各种帅气姿势被这么画出来简直羞耻度MAX) 与OVERLOAD(不死者之王)一样，或许是因为看废柴男主看出了审美疲劳，这次看一个装逼男主反而新鲜无比，(装逼之风，常伴吾身)。强烈推荐！ 迷家-マヨイガ-/迷家-Diomedéa 3.8生存类的动画在描写野外生存的地方倒是很到位，但是最后对于幻想的解释实在过于扯淡，于是作品烂尾降分… 而且女主塑造的存在感过低，只感觉是个累赘，男主的身世设定倒还可以接受， 总体是部一般的番，可以用来消磨时间。 ジョーカー・ゲーム/Joker Game/代号D机关-Production I.G 4.9讲述间谍的番，画风非常棒，声优全是名优，男主各个帅气，剧情也非常缜密。一部非常完美的番，背景是二战时期的日本间谍，讲述的是间谍在执行任务期间的各种故事，以正直男主的视角来描写 军人与间谍之间的矛盾和联系，可以说能感受到新价值观的作品。强烈推荐！ 甲铁城的卡巴内利/甲鉄城のカバネリ-WIT STUDIO 4泽野大大配乐的番剧情再弱也不会差到哪去，女主无名的天真烂漫与不相称的强大力量是一个看点，男主虽然能力一般然而铁血铮骨。配合泽野弘之的宏大音乐，作品在战斗方面非常出色。僵尸系列的 动画，不看动画至少也把配乐听了~ 线上游戏的老婆不可能是女生？/ネトゲの嫁は女の子じゃないと思った？-Project No.9 2.8伪后宫番，两个玩男号的妹子和玩男号的汉子和一个玩女号的妹子的故事，作品就是在看福利，剧情则是平平，关键是人物也不萌…，加上制作成本也不是很高…所以整部番就那样。 双星之阴阳师/双星の陰陽師-Studio Pierrot 3惯例少年热血漫的套路，上来就配套妹子，两人一起打怪练级。背景设定是阴阳师，但是由于人设不合一些人的口味加上剧情比较单调，所以这番最多给个3分…女主偶尔萌一下，剩下时间…看他们打怪？ OtherUnhappy卖萌番；黑色残骸毫无亮点；羁绊者也没什么亮点；SuperLovers则是常见的女性向基番；BigOrder整个有点扯，类似于未来日记的感觉然而人设剧情都差太多；所以略过。 JoJo, 超时空要塞，魔笛MAGI，火星异种2，逆转裁判则是粉丝向，不做评论了。 2016 7月番斉木楠雄のΨ難/超能力者齐木楠雄的灾难-EGG FIRM/J.C.STAFF 4.8这番剧毒无比，官方吐槽最为致命，也是一部槽点满满的番，不一样的搞笑套路让人耳目一新。诉说着超能力者和出场自带BGM的中二少年，沾花惹草的领能力者，全家都是白痴的白痴哥们，以及爱上男主全程自带光环的被身眷顾的少女，一个个夸张设定的角色在一起过的日常生活非常的有趣，强烈推荐！ Rewrite/りらりと-8bit 3虽然是Key社作品改编，游戏有龙骑士执笔的剧情，即使是全年龄的GalGame也收获了极大的好评，不过作品不是十分的催泪，游戏里庞大的时间观想在12集的动画里表现出来几乎是不可能的，因此造成了动画的不明所以，日常节奏过慢，主线剧情又太赶，动画制作也不是很精良，所以只能差强人意。 NEW GAME!/ニューゲーム!-动画工房 4比白箱更加萌更加轻松的业内番，讲述制作一个游戏的过程，不过重点放在了建模和美工组那边(可怜辛苦的程序员、产品狗、市场和策划), 妹子都是萌萌哒。但是作品不会符合所有观众的口味，喜欢看声优日常(这就是声优)、动画制作日常(白箱)的应该也喜欢游戏制作日常的本作。作品本身有动画工房的甜甜画风保证，不会差到哪去，所以看个人喜好决定是否食用。 ツキウタ/月歌-Pierrot 3.2女性向偶像番，两队人马6###2个任君挑选，一个男生虽然看女性向偶像漫怪怪的，但是不得不说这番的歌还是不错的，虽然剧情依旧很无聊… この美術部には問題がある!/这个美术部有问题!-feel 4.5无论哪方面都没什么挑剔的番，轻松愉快，女主性格的塑造也非常到位，虽说是校园番，恋爱的酸臭味也没有那么浓(毕竟女主面对一个感情白痴)。男主又是一个宅+画画大触，女主又萌萌哒，一起的日常轻松搞笑，剧情又不会过于无聊，着实是本季度高质量的动画之一，强烈推荐。 东离剑游记/Thunderbolt Fantasy/東離劍遊紀-霹雳国际; Nitroplus; GOODSMILE COMPANY 4作为台湾霹雳社的拿手好戏，布袋戏的表现形式使得本番与其他番没有什么可比性，剧情虽由老虚执笔，但可能是中国武侠元素的影响，这部番和大多武侠番也类似，男主有龙傲天暗藏功与名之嫌，所以剧情上并不能说高能或精彩，但是作为一种独特的艺术表现形式本番还是值得一看的。 91 Days/ナインティワンデイズ-朱夏 4.9非常好看，但是又比较冷门的番。或许可能是因为没有被B站购买的原因？ 一部91天的复仇故事，情节紧凑，各部分比例适当。男主复仇过程中的心理表现的淋漓尽致，在黑手党的这样一个大背景下，有珍贵无比的友情，有冷酷可怖的仇杀，有小人物的借酒消愁，有黑帮间的枪林弹雨…… 人物的刻画与剧情的编排都无可挑剔，非常难得的佳作。 Other粉丝向: 食戟之灵S2, 亚尔斯兰战记S2, 驱魔少年S2, LoveLive!Sunshine!, 魔法少女伊莉雅S4, 弹丸论破3, 女神异闻录。都是不错的番，粉丝向就不做介绍了。 QEALIDEA CODE，禁忌咒纹， 魔装学园HxH, 屁屁吾郎 个人觉得不怎么好看就略过。 2016 10月番終末のイゼッタ/终末的伊泽塔-亚细亚堂 3.7百合向的魔女喜剧番，剧情虽然也比较紧凑不过已经是用过的套路了，讲述的是二战背景下虚构的国家公主与魔女的缠缠绵绵~~ 公主的气质倒是不错，偶尔也不忘在战争的紧张中给一些福利，不过也就这样吧~ ガーリッシュナンバー/girlish number/少女编号-diomedéa 4讲述的依旧是声优的故事，所以我也给了和New Game一样的评分。不过这次的女主倒是一个屎一般的性格，自大、傲慢、浮躁、虚荣，在声优的世界得过且过的混着日子。然而也正是这样的一个女主也却乐观而坚强，所以也显得更真实，不是那些励志故事中的完美努力主角，反倒是缺点突出而又饱受现实打击的可怜又可恨的孩子，所以带给观众的也是不一样的感受吧。 私がモテてどうすんだ/我太受欢迎了该怎么办-Brain’s Base 3.2一个肥死宅不过瘦下来缺是个美女的逆后宫故事，女主又是个腐女，女儿还是个喜欢女主的百合…… 后宫4个帅哥，只能说贵圈好乱。不过对于腐到这种程度的宅女也是没救了，而且结尾也是后宫漫一贯的套路，保持现状… 所以看下来也就那样。 舟を編む/编舟记-ZEXCS 4.5编舟记是现有的电影，后有的动画，电影已经拿了众多奖项了所以对于剧情是没有什么挑剔的。再加上这次制作的认真，动画细节的刻画非常精细，一部讲述枯燥的字典编撰工作的动画却能让人不时热血沸腾，一部讲述平凡的社会人士生活的动画却能让观众在字典完成时流下感动的泪水……主角们的工作是枯燥的，然而在监督的巧妙编排下，剧情不显乏味反倒有热血运动漫的感觉，足以见得这部动画的水准。 超自然九人组/Occultic;Nine/-オカルティック・ナイン–A-1 Pictures 4.2画风有点女神异闻录的感觉，加上人物的话唠属性很容易让观众在一开始看不下这部番，然而这部番不愧是有着科学系列三部曲(命运石之门、混沌之脑、机器人笔记)的经验，再次借由科学来讲述超自然故事，剧情紧凑且高能，但不知是不是苦于12集篇幅过短，本番并没有表现出像命运石之门的高水准，人物的刻画或许是因为涉及人物过多而不够细致，所以看完有一种比较赶的不适。 冰上的尤里/YURI!!! on ICE/ユーリ!!! on ICE-MAPPA 4.7不一样的运动番。花样滑冰表达的更像是一种艺术与舞蹈的结合，所以与球类运动的热血不太一样。平时看比赛的时候我们能看到的只有运动员的外表，而这部番则着重介绍运动员的内心活动，每一个动作其背后的感情，并且能够看出作者对于冰滑是有一定考究的，动画中人物的动作非常标准，与正式比赛的规则也一致，不但科普了冰滑这一运动，更让我对冰滑运动员产生了一种尊敬。看了这部番后我甚至相信自己喜爱的斯诺克运动也能被完美的动画化了。 Other粉丝向: 夏目友人帐S5, WWW.迷糊餐厅(猫组), 亚人S2, 排球少年S3, 高达, 歌之王子殿下S4, 我老婆是学生会长S2, 文豪野犬S2, 吹响吧！上低音号S2。这些都是经典，不然也不会有后续，不再赘述。 周一的丰饶，竞女不介绍了，老司机们都知道… ViVid Strike!, 灼热的乒乓球娘感觉都比较一般就略过了。 End2016年我一共完整看了64部番，其实看动漫的一个很重要的原因是许多动画的剧情深度已经堪比电视剧，不过正因为是动画，所以表现手法也可以更加夸张，人物的刻画也不会局限于一个演员的演技。而且日本声优真的已经达到了一种神秘的境地，让人不得不感慨声优是一个赋予人物灵魂的职业。所以我想我之后还是会看下去的吧~ 你好！2017！]]></content>
      <tags>
        <tag>ACG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016 Summary]]></title>
    <url>%2Fblog%2F2017%2F01%2F02%2F2016-summary%2F</url>
    <content type="text"><![CDATA[2016 是历史魔幻元年，历史的涡轮发动机推着人文社会这辆高铁飞驰— 2016一年就见证了太多的大事… 2016 是相对比较充实的一年，好好工作，为毕业而奋斗… 因为去年是刚建这个blog没多久进行的总结，所以非常仓促，今年的总结其实每个月都有在进行，现在写出来也方便自己以后来比较和反省。 ###流水账 Jan. 过年啦，过年啦~~ 实验室的寒假放的还是可以的，一个月的时间，临近寒假完成了各种考试和助教工作的我在实验室年终聚餐的欢声笑语中回家了。年终抽奖的时候抽到了Lamy的钢笔，也顺带了解了一下各种高逼格的钢笔墨水.. 各种高逼格墨水 百乐色彩雫系列还是非常喜欢的，不过低调的我只是买了Waterman… 每年的冬季天鹅都会从西比利亚南下过冬，三门峡也就在此刻化为天鹅之城，小时候想寻一只天鹅要像小心的猎人一样靠敏锐的嗅觉去找天鹅的踪迹，之后才能一瞥天鹅高贵的尊颜。如今在保护下，从桥上走过眼见一片片已然是天鹅群舞, 而我每年也借此机会和亲人们在天鹅的欢笑声中加深羁绊。 Feb. 寒假和亲戚们各种聚餐过年，在二姐夫的指导下学习喝白酒，敬白酒… 自己也是有一些做的不对的地方，今年争取弥补一下吧~ 在我的怂恿下，家里买了小米电视2S, 小米的电视性价比还是很高的，虽然一直有人黑..不过自己用小米的产品一直都挺满意的。 比较意外的是小学同学几个人聚了一次餐，果然小学同学到现在的变化是最大的，虽然还是能认出来，不过各自都已经走在逐渐远离的道路上了。小学被男生欺负的，欺负男生的妹子们现在也都散发着迷人的气质。 Mar. 工作上还是学习Nested Xen的代码，各种问，各种加printk .. 年级进行了一次大的聚会，虽然还是好多人不认识，不过大家暂时忘却工作学习上的烦恼，一起在食物的醇香、音乐的节奏中欢笑着。 自己也升级了装备，MI2S-&gt;MI5 的提升让我终于能在手机上搓炉石了 咔咔咔。 Apr. 贡献了自己的一丢丢代码，在建立Guest的时候应用一些Policy, 根据权限隐藏或者删除一些内存页的映射。。深刻体会到如果没有参与到系统的设计过程，在后续跟进是一件多么痛苦的事情，尤其是跟进的系统实现还没完成各种变来变去… 也同样认识到看一些优秀的代码是多么重要。。 在西交的此刻一定是樱花祭与校庆的狂欢吧，上交没有西交一样的樱花祭，对于我这种动漫爱好者来说着实不友好。不过恰逢120周年校庆，场面甚是壮观。我也在十年难得一见的熙熙攘攘中排队购得了校庆的纪念邮票。 花花在实验室给我们展现了一个有追求的博士的素质! 手制提拉米苏蛋糕！非常好吃。不过后来也知道这用来撩妹也是甚好… May. 上上课，写写lab，写写代码，准备考试，相对平淡的一个月。 和实验室的一些小伙伴去三清山玩了一圈。自己也准备好了签证照片为暑假的出游做准备。 最重要的是自己的MacBook买来了, 写代码都充满动力了呢！根据工作需要买了最轻便的一款，也不再像小时候一样死命追求配置了…果然便携现在才是重点么.. Jun. 考试O O… Robbert van Renesse和Lorenzo Alvisi来实验室进行了指导，也听了一把分布式组的报告。这里也不装了，意思上懂，不过细节上其实一头雾水… 花花买了鲱鱼罐头.. 终于体验了一把世界上最臭的食物。确实是大规模杀伤性武器…爽的一B 小一和她同学来学校玩，我也是借此机会转了一遍自己都没完整转完的校园😂.. Jul. 给Nexen (Nested Xen的名字)加一点点的容错，研究了一下vcpu的调度和Resouce counting, 不过后来没怎么用的上就那么过去了。 Aug. 调Nexen不能在物理机上跑的bug…最终是因为struct里面的变量声明顺序有问题，对齐后不是16byte对齐，导致我们后面的引用出错了… 没想到在ICS上学到的知识在这里用上了。再次意识到struct里面加padding的重要性。 月底放假了~ 和达哥和洪博去东京自由行，体验了一把日式生活，过的非常的爽.. 之前学的日语终于用上了，不过其实有了英语就不虚了，有日语加持后就更加浪的飞起。 Sept. 开学后研究一下MPK (Memory Protection Key), 不过发现自己这边没有什么idea, 协程里面可能能用一下。 工作之余在上海当代艺术博物馆看了一个现代艺术展:“零食/SNACK”，果然是不可归类的作品，看的我是云里雾里，只能感受到情感的共鸣?缺无法理清他们在表达什么。有的作品介绍就是: 作者也不知道他们在表达什么，因此将问题抛给了观众← ←..当天一并观看了星际迷航。虽然回来就大病一场，不过玩的那天还是非常happy的。 Oct. 着手进行Nexen的后续工作，中间也弄一弄sosp的网站，帮助改一些Nexen的补充资料。有兴趣的可以看一下已经上线的IPADS-XSA~ Nov. 着手Fidelius的工作，写相关的代码。完成内存管理部分。 趁着双十一入了索尼的MDR-100ABN的蓝牙主动降噪耳机，也是一次性从两位数耳机飞跃到四位数的耳机..得到了《君の名は》的Bilibili电影票..在日本的时候没有时间去看，国内居然引入了。 和实验室的小伙伴秋游去了周庄~ Dec. 研究Xen的I/O部分…忙一丢丢的Nexen的Final version。听了Zhong Shao带来的OSDI CertiKOS详细版。 四姨和另一位阿姨来上海出差也是专程跑到老远的校区来看望我, 我也再一次证明了工科男并不都是闷骚。年终参加了难得一次的班级跨年聚餐~~ ###Note 研究生的生活步入正轨之后就正常前进着，上课考试写代码，课余时间聚聚餐，看看电影和动漫。 没有找工作或者上课考试的下半年也让我能够切实体会到花时间做科研是一种怎样的体验。 每个人都有自己的目标并在努力向之奋斗，稍有不慎自己可能就会错失大把的时间， 慢慢又会想起高中时期眼前只有高考这一目标时自己的马力全开，与之不同的是这次是idea的实现。 写代码是辛苦的，调bug是枯燥的，但是如果让自己的生活也变得枯燥和辛苦的话那反而得不偿失。所以生活还是有一些插曲的~ (说白了就是浪) 2016年过的还是相对平淡的，可能这才是一个学生该有的生活？在世界震荡的背景下自己作为一个吃瓜群众也是从来不会感到寂寞就是了~ 2017年一个首先先养成总结每天的习惯，总感觉写这篇总结的时候都是翻出相册和work report一路翻到底才写出来的，确实应该三两句记录下一天的所做作为， 这样才能帮助自己自省~ 希望在我的本命年内能够发出Paper、安心毕业、找到心仪的工作吧~ 没有什么感慨，项目都没做完哪有闲心寻愁来叙…就祝大家鸡年大吉吧~]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xen Log 9-I/O Ring Structure]]></title>
    <url>%2Fblog%2F2016%2F12%2F28%2Fxen-log-9-io-ring%2F</url>
    <content type="text"><![CDATA[在上一篇中我们通过Grant Table让DomU和Dom0能够通过内存共享进行通信，众所周知在Xen里domU的I/O都是交由dom0来完成的。而I/O driver也有两种实现方式: paravirtualized和qemu-emulated。本篇主要讨论Xen上PV Driver所使用的数据结构: I/O Device Ring。 Grant Table I/O Ring Structure(本篇) Event Channel Implementation Event Channel Usage XenStore Usage Write a PV Driver Connect to XenBus Origin of Virtualization最早提出虚拟化的是Gerald J. Popek和Robert P. Goldberg在1974年发表的一篇Formal requirements for virtualizable third generation architectures中提出来的，在其中作者提到了几个对虚拟化的几个要求: Efficiency Innocuous instructions should execute directly on hardware Resource control Executed programs may not affect the system resources Equivalence The behavior of a program executing under the VMM should be the same as if the program were executed directly on the hardware (except possibly for timing and resource availability) 最后一点要求Guest是不能知道自己运行在虚拟化下的。然而这样一个要求使得当时不得不对许多情况进行二进制的模拟以致虚拟机的性能一直非常糟糕。其中I/O的模拟就是由Qemu完成的，通过Qemu来模拟一个设备，当Guest有请求的时候请求会被转发给Qemu来模拟执行。 ParavirtualizationXen的理念是对domU进行适当的修改，让domU意识到自己是在虚拟化环境下，这样可以大大简化hypervisor的设计和实现。 而I/O部分Xen就使用了PV driver, PV driver的详细部分我会在之后的文章中去讨论。 这里需要了解的是PV driver分为前端和后端，domU里跑的是frontend, dom0里跑的是backend, 这时I/O的操作实际上通过frontend直接交由dom0在硬件上直接执行, 免去了qemu模拟带来的性能开销。 既然有front和back, 那么它们之间就需要通信, 两端通信所使用的是一个生产者消费者模型的ring, 由一方填入数据，另一方处理数据。 RingRing的好处在于异步通信，domU的front可以把数据丢到ring里立刻执行接下来的任务，不用等dom0的back进行回应。而ring的建立和数据传递则要以来Grant Table机制。由于front的request和back的response是相同频率(每次backend都消费一个request并填回一个response), 所以一个ring刚好服务一对driver。 response的开头永远紧接着request的结尾，因此只要比较request start和response end就能知道ring是不是已经用完了，用完的话就扩充整个buffer。 xen/interface/io/ring.h1234567891011121314151617181920212223242526272829/* To make a new ring datatype, you need to have two message structures, * let's say struct request, and struct response already defined. * * In a header where you want the ring datatype declared, you then do: * * DEFINE_RING_TYPES(mytag, struct request, struct response); * * These expand out to give you a set of types, as you can see below. * The most important of these are: * * struct mytag_sring - The shared ring. * struct mytag_front_ring - The 'front' half of the ring. * struct mytag_back_ring - The 'back' half of the ring. * * To initialize a ring in your code you need to know the location and size * of the shared memory area (PAGE_SIZE, for instance). To initialise * the front half: * * struct mytag_front_ring front_ring; * SHARED_RING_INIT((struct mytag_sring *)shared_page); * FRONT_RING_INIT(&amp;front_ring, (struct mytag_sring *)shared_page, * PAGE_SIZE); * * Initializing the back follows similarly (note that only the front * initializes the shared ring): * * struct mytag_back_ring back_ring; * BACK_RING_INIT(&amp;back_ring, (struct mytag_sring *)shared_page, * PAGE_SIZE); */ 在ring.h中定义了DEFINE_RING_TYPES宏，使用它当我们传入request和response的类型时，它就会据此类型为我们建立一个shared ring和其front end与back end。两者共同操纵shared ring, 在各自的内部又会记录consume的数目。front需要调用SHARED_RING_INIT来初始化真正共享的页, 它会初始化start, end指针的起始位置。而后front与back分别使用FRONT_RING_INIT与BACK_RING_INIT初始化各自操作ring时使用的数据结构。 mytag_sring中记录了req_prod, rsp_prod, req_event, rsp_event4个变量， 其中req/rsp_prod记录的是最新的info的地址, 分别由front和back来更新。 而struct front/back_ring 中则记录了req/rsp_prod_pvt和rsp/req_cons, 每次push新的req/rsp时，都先更新pvt(pivot)变量，调用宏后宏会更新req/rsp_prod。 在consume时就更新自己本地的rsp/req_cons变量；在更新完后进行check， FINAL_CHECK宏会检查有没有pending的req/rsp并更新sring中的rsp/req_event。 因此只要判断(pvt - event) &lt; (pvt - prod)就能知道是不是应该通知远端ring中还存在未处理的内容。 Demo: Ring BufferRing本身就是依靠Grant Table进行共享的(共享一个ring buffer), 而本身通过ring我们可以异步的传数据。在I/O传输中ring中传的就是grant refernece. front将一个个gref放入ring作为request, back就不断地处理这些request并返回response。以此来完成大量数据的传递。因此我们这次对之前的内存共享进行修改，在Grant Table基础上建立ring并用ring来进行通信。 目前的demo没有调用FINAL_CHECK。 DomU首先定义类型: alice_domU.csource123456789101112131415161718/* Ring request &amp; respond, used by DEFINE_RING_TYPES macro */struct as_request &#123; int hello;&#125;;struct as_response &#123; int hi;&#125;;/* this macro will create as_sring, as_back_ring, as_front_ring */DEFINE_RING_TYPES(as, struct as_request, struct as_response);typedef struct front_end_t &#123; struct as_front_ring ring; /* Record real ring */ grant_ref_t gref; /* gref of shared page */&#125; front_end_t;front_end_t front_end; 按照说明初始化, 并发送一个request给dom0 alice_domU.csource12345678910111213/* Step 2: Put shared ring on this page to be shared */sring = (struct as_sring *)vpage;SHARED_RING_INIT(sring);/* Step 3: Front init */FRONT_RING_INIT(&amp;(front_end.ring), sring, PAGE_SIZE);/* Write a request and update the req-prod pointer */ring_req = RING_GET_REQUEST(&amp;(front_end.ring), front_end.ring.req_prod_pvt);ring_req-&gt;hello = hello;front_end.ring.req_prod_pvt += 1;RING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&amp;(front_end.ring), notify); dom0后端的代码和前端类似，取出一个request并填回一个response。注意，这里我没有使用FINAL_CHECK，正常使用中是要加上的。 alice_dom0.csource123456789101112131415161718rc = back_end.ring.req_cons;rp = back_end.ring.sring-&gt;req_prod;/* Copy this info local */memcpy(&amp;req, RING_GET_REQUEST(&amp;back_end.ring, rc), sizeof(req));pr_info("Alice: Receive hello=%d\n", req.hello);/* Fill response hi = hello + 1 */rsp.hi = req.hello + 1;/* update req-consumer */back_end.ring.req_cons = ++rc;barrier();memcpy(RING_GET_RESPONSE(&amp;back_end.ring, back_end.ring.rsp_prod_pvt), &amp;rsp, sizeof(rsp));back_end.ring.rsp_prod_pvt++;RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&amp;back_end.ring, notify); 处理的时候拷贝到本地再处理。 Summary可以发现，其实I/O ring只不过就是一些操作共享内存的数据结构和宏定义，而对于Xen来说它只提供了Grant Table这一内存共享机制，在上面进行什么样的操作Xen并不关心。在I/O driver中就是利用ring来传递真正存放内容的内存页的grant refernece的。如果要做batch的话把FINAL_CHECK中event的更新改为+N (N为每次batch的数目), 前端在push request的时候也要按照N个N个来push。 运行示例运行的时候忘记了，先退出了domU的kernel module。 所以这里刚好也看一下错误退出的错误提示… 123456789101112131415161718192021222324alice@domU: $ sudo insmod alice_domU.ko; dmesg[ 577.380602] Alice: Hello, This is Alice[ 577.380608] Alice: Get free pages from kernel, virt of page: 0xffff880074d26000[ 577.380612] Alice: Grant_Ref is 315, input this as param of alice_dom0.koalice@dom0: $ sudo insmod alice_dom0.ko gref=315 domid=1; dmesg[ 1079.748454] Alice: init_module with gref = 315, domid = 1[ 1079.748469] Alice: shared_ring = ffffc90010e8e000, handle = 264, status = 0[ 1079.748472] req_comsumer: 0, req_producer: 1[ 1079.748474] Alice: Receive hello=233[ 1079.748477] Alice: Need to send notify to dom1# 0x13b is 315 in decimalalice@domU: $ sudo rmmod alice_domU; dmesg[ 742.819814] Alice: Get response, hi = 234[ 742.819818] Alice: Cleanup grant ref...[ 742.819821] Alice: Someone is mapping this ref now[ 742.819824] xen:grant_table: WARNING: g.e. 0x13b still in use![ 742.819828] deferring g.e. 0x13b (pfn 0x74d26)[ 742.819830] Alice: Exit Successfullyalice@dom0: $ sudo rmmod alice_dom0; dmesg[ 1173.124539] Alice: cleanup_module[ 1173.124559] Alice: unmap shared page successfully]]></content>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kernel Module Using&Blacklisting]]></title>
    <url>%2Fblog%2F2016%2F12%2F28%2Fkernel-module%2F</url>
    <content type="text"><![CDATA[本来觉得这个挺简单，不过发现每次写都会忘，这次就把常用的关于Kernel Module的操作和命令放一起做个小的总结吧~ Why Kernel ModuleKernel Module的存在能使得对于操作系统的扩展更为灵活，将非kernel的功能放到module里，当kernel起来后再对它们进行加载。Linux自带的Module的源码在linux的源代码里面就有。通过查看/lib/modules/linux-source-dir/modules.buildin就能知道系统启动时会加载哪些modules。 Write a Modulealice_module.csource12345678910111213141516171819#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/types.h&gt;static int init_alice(void)&#123; pr_info("---------&gt;Hello, This is Alice\n"); return 0;&#125;static void exit_alice(void)&#123; pr_info("================================&gt;Exit Successfully\n");&#125;module_init(init_alice);module_exit(exit_alice);MODULE_LICENSE("GPL"); 一个Kernel Module写起来是十分简单的，这里MODULE_LICENSE(&quot;GPL&quot;)是声明该Module使用GPL License, 这样的话这个module就可以调用其他module中通过EXPORT_SYMBOL_GPL(funname);暴露出来的接口了。 如果不用module_init/exit来指定函数的话，就需要使用init/exit_module来写。 Compile &amp; Run1234567$make -C /lib/modules/3.16.0-4-amd64/build M=/home/alice/kernel_module modulesmake[1]: Entering directory '/usr/src/linux-headers-3.16.0-4-amd64'make[1]: Entering directory `/usr/src/linux-headers-3.16.0-4-amd64' Building modules, stage 2. MODPOST 1 modules make[1]: Leaving directory '/usr/src/linux-headers-3.16.0-4-amd64' 编译的之前需要先安装linux的头文件,之后正常编译就行。最终会生成一个*.ko文件。 插入/删除Module: 12$ sudo insmod alice_module.ko$ sudo rmmod alice_module 查看dmesg: 123$ dmesg[84980.087670] ---------&gt;Hello, This is Alice[85059.455243] ================================&gt;Exit Successfully 如果要给module传入参数的话，引用相关的头文件并声明就好: 1234567#include &lt;linux/moduleparam.h&gt;static int arg1;static int arg2;module_param(arg1, int, 0644);module_param(arg2, int, 0644); 123456sudo insmod arg1=233 arg2=245dmesg | tail[885090.422275] ================================&gt;Exit Successfully[885103.935079] ---------&gt;Hello, This is Alice[885103.935081] param arg1:233, arg2:245 Commands其他的常用命令: 安装Linux自带的module: modprobe12$ sudo modprobe -v i8kinsmod /lib/modules/3.16.0-4-amd64/kernel/drivers/char/i8k.ko modprobe 与 insmod的不同在于，modprobe会查找module依赖的其他module, 并先加载被依赖的module. 但是相对的，modprobe只能加载内核里的标准module, 我们自己写的还是要用insmod 查看module信息: modinfo 12345$ sudo modinfo alice_module.kofilename: /home/alice/kernel_module/alice_module.kolicense: GPLdepends:vermagic: 3.16.0-4-amd64 SMP mod_unload modversions 列出所有modules: lsmod 1234567$ lsmodModule Size Used byalice_module 12385 0binfmt_misc 16949 1cfg80211 413730 0rfkill 18867 1 cfg80211... 删除Linux自带module: modprobe -r / rmmod 1$ sudo modprobe -v i8k 或者 1$ sudo rmmod i8k BlacklistingLinux 启动的时候会自动加载一些Module，如果我们不想让它加载某些module的话就要用黑名单了:) Blacklist在/etc/modprobe.d/fbdev-blacklist.conf中添加要屏蔽的module名字即可 FakeInstall创建文件/etc/modprobe.d/&lt;modulename&gt;.conf 并写入install &lt;modulename&gt; /bin/true. ChangeLog 2017-09-22 Add module_param]]></content>
      <tags>
        <tag>tutorial</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xen Log 8-Grant Table]]></title>
    <url>%2Fblog%2F2016%2F12%2F26%2Fxen-log-8-grant-table%2F</url>
    <content type="text"><![CDATA[本篇是为了解Grant Table这一共享内存机制。之前的项目中心在Memory上，不过关于内存的部分带我的大哥在Xen的启动之内存相关实现和Xen的内存布局中已经比较详细的说明了。在之后的工作中由于要用到I/O的相关部分，所以先探究一下Grant Table，为之后的I/O的章节做个基础准备。 I/O部分暂定为以下部分: Grant Table (本篇) I/O Ring Structure Event Channel Implementation Event Channel Usage XenStore Usage Write a PV Driver Connect to XenBus 在虚拟化环境中，Hypervisor往往要提供内存共享机制以便Dom之间进行交流，而Grant table就是为此而创作的。 Grant TableXen的内存共享基于页粒度，一次共享的就是一个页，一个DomU可以把自己的一部分内存分享给别人，而其他人则通过Grant Reference来获取到这个页，GrantRef可以视为一个整数或者Key来获取到其他Dom共享的页 Xen通过提供grant_table_op一系列hypercall以供DomU使用来实现内存共享。 不同的操作可能需要用到不同的结构体，都定义在$XENDIR/xen/include/public/grant_table.h 每一个Dom都有自己的Grant Table, 这个Table是在Xen Tools 建立(build)dom的时候为Guest创建的，并且和Xen共享以提供给Xen”Granted Page”被赋予了什么样的权限等信息。而Table中的各项就是使用Grant Reference来进行索引。目前Xen只支持一个Dom有最多一个Grant Table。 Guest在启动的时候通过调Hypercall 使用setup op让xen把初始化后的Grant Table映射给Guest使用。 Linux里面在$DIR/drivers/xen/grant_table.c让Xen进行映射。 grant_table.h12345678910111213141516171819/* [XEN]: Filled by Xen, [GST]: Filled by Guest */typedef uint32_t grant_ref_t;struct grant_entry_v1 &#123; /* GTF_xxx: various type and flag information. [XEN,GST] */ uint16_t flags; /* The domain being granted foreign privileges. [GST] */ domid_t domid; /* GTF_permit_access: Frame that @domid is allowed to map and access. [GST] * GTF_accept_transfer: Frame whose ownership transferred by @domid. [XEN] */ uint32_t frame;&#125;;/* Flag: 16bit |----- 7bit -----| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 2 | |---------------- Sub Flags -----------------| Types | |----Reserved----|SUB|PAT|PCD|PWT| W | R |RO |PERMITS| |--------------Reserved- ------------|CMT|CPT| TRANS |*/ 我们可以发现，grant_ref类型就是个无符号整型。Grant_Table中的entry就如上，flags里面是定义这个grant frame的各种类型、权限等，domid是接受者的ID, frame则根据flag中的信息不同，有不同含义，不过都是这个grantRef对应的页。 而根据Type的不同，sub_flags中的bit也表达不同的含义: 0-Invalid: 这个entry不给予任何权限 1-Permit Access(PERMITS): 允许@domid访问或映射这个@frame 2-Accept Transfer(TRANS) : 允许@domid将页的拥有者转移给当前dom, 此时frame由Xen填写 3-Transitive : 允许@domid访问给予的部分页，但不允许映射 (v2) Sub_flags在Type为Permit Access时: W/R/RO 分别定义写、读和只读权限，PAT/PCD/PWT则是定义cache类型的(和控制页表的entry里的语义一样, Page Attribute Table Index, Page Cache Disable, Page Write Through, 这里不赘述…), Sub_page (SUB)则是限制@domid的访问范围(v2) 当Type为Accept Transfer时transfer_commited(CMT)表示当前的Frame正在转移拥有者，这时Guest不能对这个Frame进行任何修改，只有当状态变为transfer_completed(CPT)表示frame已经的拥有者已经转移完毕时Guest才能开始正式使用这个frame。 因此通过查这张表，Xen就能知道当前的DomU能对这些Grant Ref做什么样的操作了。 Grant Table OPsGrant Table上可以进行两种操作：Mapping 和 Transfer。Mapping 会将Grant Ref这一Page映射到自己的地址空间内，接收方收到后也将这个Page映射到自己的地址空间，则建立了一个共享页；而Transfer则是将自己的一个Page交给别人，用于传输数据给其他的Dom或者用于Dom0分发空闲页给DomU(balloon driver) grant_table.h123456789101112131415/* enum neg_errnoval * HYPERVISOR_grant_table_op(enum grant_table_op cmd, void *args, unsigned int count) * * @args points to an array of a per-command data structure. * The array has @count members (struct gnttab_*) */#define GNTTABOP_map_grant_ref 0 /* 映射一个ref */#define GNTTABOP_unmap_grant_ref 1 /* 取消ref的映射 */#define GNTTABOP_setup_table 2 /* 建立grant table */#define GNTTABOP_dump_table 3 /* 导出grant table到console, 仅用于debug */#define GNTTABOP_transfer 4 /* 移交一个页 */#define GNTTABOP_copy 5 /* 拷贝一些页/gref对应的页 */#define GNTTABOP_query_size 6 /* 查询grant table的当前/最大大小 */#define GNTTABOP_unmap_and_replace 7 /* 撤销对gref的映射，并替换为其他的映射 */ 传给Hypercall的操作有上面这些，其中在map操作执行后，会返回一个handle(一个记录当前映射的整型), 在unmap的时候需要传入对应的handle以及HPA(Host Physical Address)并将原来的映射替换为映射到新的Machine Address (可以是Null)。 Grant Table VersionXen在3.0之后加入了Grant Table Version 2 (v2), 对1进行了一些扩展，在Version 2中有更多的操作和更细粒度的控制(比如transitive access, 让接受者只能访问部分页而非全部页，并且要求接受者不能映射到这个页，只能通过拷贝数据的方式读取其中的数据)等等。也相应的增加了一些其他的操作和种类。不过v2是向后兼容的，所以做的事情都是一样的。 一个dom在启动的时候会设置好自己使用的是哪个版本的grant table，一旦设置后在运行期间该dom中的所有grant table都必须为这一版本。上面介绍的也是以比较简单的v1版本为准。 Map &amp; Transfer a Page Frame很显然我们最关心的是如何共享或移交一个page给另一个dom。这里就着重看一下Mapping 和 Transfer。 Mapping1234567891011struct gnttab_map_grant_ref &#123; /* IN parameters. */ uint64_t host_addr; uint32_t flags; /* GNTMAP_* */ grant_ref_t ref; domid_t dom; /* OUT parameters. */ int16_t status; /* =&gt; enum grant_status */ grant_handle_t handle; uint64_t dev_bus_addr;&#125;; 在前面已经介绍了，每个操作都对应有自己相应的结构体类型作为参数，map_grant_ref的结构体如上，dom:ref的来源；flags会描述如何map这个页: GNTMAP_device_map: page会被I/O设备使用，如果系统使用了IOMMU，那么就会在IO地址空间中加入新的映射。相应的，dev_bus_addr就会被填上对应的IO地址作为返回值。 GNTMAP_host_map: page会被映射到调用者的地址空间中 GNTMAP_application_map: 在host_map被set的情况下，如果这个flag也被set，那么就可以ring3级访问，否则只能被ring0级访问。 GNTMAP_readonly: 映射为只读，比如单向传数据的时候，给予方写数据，接收方读数据 GNTMAP_contains_pte: 指明host_addr的类型，默认情况下，host_addr是要更新的PTE的paddr。 Transferring如果是移交一个页(用于dom间传数据), 这时接收方需要首先声明它愿意接受页..(不能你想给我就给我，要先经过我同意，或者…我求求你给我一个页吧..)，通过在自己的Grant Table建一个entry(设置flag为accept transfer), 这个entry会告诉Xen当前的Dom允许domid给它页, 也能表示为请求domid给它页。Xen发现后会通知相关的dom，由dom通过gnttab_transfer来移交一个页过来。 12345678struct gnttab_transfer &#123; /* IN parameters. */ xen_pfn_t mfn; domid_t domid; grant_ref_t ref; /* OUT parameters. */ int16_t status;&#125;; 将mfn所指的frame交给, @domid在之前已经通过它grant_table中的ref请求了页。无论操作成功与否，mfn所指的页都将不再属于当前的Guest。 Demo: Sharing Memory between Domains现在我们就来尝试使用Grant Table在DomU和Dom0之间共享数据。由于Grant Table没有提供用户接口，所以我们就使用Kernel Module来写吧..这篇《Kernel Module》介绍如何写一个Kernel Module. DomainU想要Map一块共享内存，首先需要给予方(domU)在自己的Grant Table中添加一条entry: ；因此我们先来看DomU的代码: alice_domU.csource123456789101112131415161718192021222324static int init_alice(void)&#123; pr_info("---------&gt;Hello, This is Alice\n"); vpage = __get_free_pages(GFP_KERNEL, 1); pr_info("Alice: Get free page from kernel, virt: 0x%lx\n", vpage); mfn = virt_to_mfn(vpage); gref = gnttab_grant_foreign_access(DOM0_ID, mfn, 0); pr_info("Alice: Grant_Ref is %d, input this as alice_dom0.ko param\n", gref); /* Step 2: Write some contents */ strcpy((char *)vpage, "Hello, by Alice in domU\n"); return 0;&#125;static void exit_alice(void)&#123; if ( gnttab_query_foreign_access(gref) == 0 ) &#123; pr_info("Alice: No one is mapping this ref\n"); gnttab_end_foreign_access(gref, 0, vpage); &#125; pr_info("Alice: Exit Successfully\n"); return ;&#125; 首先使用__get_free_pages从kernel里拿一个物理页，获取到machine frame number。在Xen提供给的linux的头文件中已经对grant table的相关操作进行了封装，具体的可以查看linux源码，其中gnttab_grant_foreign_access(DOM0ID, mfn, 0);的声明是: 1int gnttab_grant_foreign_access(domid_t domid, unsigned long frame, int readonly); 这个函数会调用gnttab_interface-&gt;update_entry去更新自己的grant table并加入一个entry, 表示同意别人进行映射。 之后向里面写入”Hello, by Alice in domU”。在domU中插入这个Module: 123456alice@domU $ sudo insmod alice_domU.koalice@domU $ dmesg[ 210.410379] ---------&gt;Hello, This is Alice[ 210.410385] Alice: Get free page from kernel, virt: 0xffff880034372000[ 210.410389] Alice: Grant_Ref is 399, input this as alice_dom0.ko param 记下gref是399, 以及domUID Domain0Dom0则要用我们上面提到的map_grant_ref, 部分代码如下: (完整代码请点source) alice_dom0.cfull source12345678910111213141516171819202122232425int init_alice(void)&#123; struct vm_struct *v_start; info.gref = gref; info.domid = domid; pr_info("Alice: init_module with gref = %d, domid = %d\n", info.gref, info.domid); /* Reserve a range of kernel address space, fill page table to map this range * This PAGE_SIZE is used for map granted page */ v_start = alloc_vm_area(PAGE_SIZE, NULL); /* Init map ops */ gnttab_set_map_op(&amp;ops, (unsigned long)v_start-&gt;addr, GNTMAP_host_map, info.gref, info.domid); HYPERVISOR_grant_table_op(GNTTABOP_map_grant_ref, &amp;ops, 1); pr_info("Alice: shared_page = %lx, handle = %x, status = %x\n", (unsigned long)v_start-&gt;addr, ops.handle, ops.status); pr_info("Alice: info from domU: %s\n", (char *)(v_start-&gt;addr)); /* Prepare for unmap */ unmap_ops.host_addr = (unsigned long)(v_start-&gt;addr); unmap_ops.handle = ops.handle; return 0;&#125; 首先我们要在地址空间中划出来4K大小用来映射共享的页, alloc_vm_area就是为此而存在的。由于每个domain只有一个grant table, 所以为了拿到grant table的实例，这里需要使用gnttab_set_map_op，它会通过Xen实现映射给自己的grant table来初始化接下来要做的map操作。 map就比较简单了，通过gref(399)和domid就能找到domU共享的页并映射到刚才申请的虚拟地址空间中。 运行dom0 module: 123456alice@dom0: $sudo insmod alice_dom0.ko gref=399 domid=1alice@dom0: $dmesg[98367.531038] Alice: init_module with gref = 399, domid = 1[98367.531053] Alice: shared_page = ffffc90000cf6000, handle = 30c, status = 0[98367.531055] Alice: info from domU: Hello, by Alice in domU 成功读到了domU共享过来的值, 由于我们这里内存是共享的，所以其实dom0也可以改这些数据的。 dom0 插入Module: dom0先删除module: 最后domU删除module:]]></content>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The funny page table terminology]]></title>
    <url>%2Fblog%2F2016%2F11%2F30%2Ffunny-page-table-terminology%2F</url>
    <content type="text"><![CDATA[What’s the next word in this sequence: PT, PD, PDP, …? If you have seen linux code, these page table terms may make you confused. So today I will simply introduce the history and difference between these terms in a hope that this can help you understant them. I refered [The funny page table terminology on AMD64] and add some new dishes. Also, this questions may help you as well: What does the ‘R’ in x64 register names stand for? ###Register Name I still remembered that when I learned x86 assembly, it took me long time to figure out what eax, ebx, ecx… and SF, OF, etc mean. As EAX means Extend AX. With the 64 bit extensions of the 8080 architecture, AMD chose “RAX”, not adding another “extended”… Here, the ‘R‘ means register. Wondering what is the next one :) The history reason is that Intel got itself into the habit of enumerating registers with letters with the 8008 (A through E plus H and L). That scheme was more than adequate at the time because microprocessors had very few registers and weren’t likely to get more, and most designs did it. The prevailing sentiment then was that software would be rewritten for new CPUs as they appeared, so changing the register naming scheme between models wouldn’t have been a big deal. Nobody foresaw the 8088 evolving into a “family” after being incorporated into the IBM PC, and the yoke of backward compatibility pretty much forced Intel into having to adopt schemes like the “E” on 32-bit registers to maintain it. The non-historical part is all practical. Using letters for general-purpose registers limits you to 26, fewer if you weed out those that might cause confusion with the names of special-purpose registers like the program counter, flags or the stack pointer. I don’t have a source to confirm it, but I suspect the choice of R as a prefix and the introduction of R8 through R15 on 64-bit CPUs signals a transition to numbered registers, which have been the norm among 32-bit-and-larger architectures not derived from the 8008 for almost half a century. IBM did it in the 1960s with the 360 and has been followed by the PowerPC, DEC Alpha, MIPS, SPARC, ARM, Intel’s i860 and i960 and a bunch of others that are long-forgotten. You’ll note that the existing registers would fit nicely into R0 through R7 if they existed, and it wouldn’t surprise me a bit if they’re treated that way internally. The existing long registers (RAX/EAX/AX/AL, RBX/EBX/BX/BL, etc.) will probably stay around until the sun burns out. These answer is from Blrfl. When using number instead of letters, we can mark them as we want and using letter to indicate some special meaning. ###Page Table Terminology 2-Level Something similar happened with PT terms. The i386 (1985) can only map 4GB memory and 2-level page tables will fulfill the need. It is easy to understand that higher level act like the directory which has 32bit * 1024 entries. So we call high level table as Page Directory Table (PD) and entries as Page Directroy Entries (PDE), pointing to 4KB * 1024 “Page Tables (PT)”. The entries of PT is called Page Table Entries (PTE). PAE and 3-Level But 4GB is no longer enough and Pentium Pro (1995) borned with a trick called “Physical Address Extension (PAE)” that allow up to 64GB of RAM without chaning the 4GB limit per address space. And in this implementation, PT have to be 64bits wide. Every PTE will be extended to 64bit and number of entries per page will be reduced to 512 to fit 4KB page limitation. It is the same with Page Directory. You will find that 2-level page table is not enough any more. So we need another level page table: Page Directroy Pointer Table (PDP) that pointing to Page Directories. But PDP just has 4 entries (64bit) indicating 4 PD, so totally address space is still 4GB: 4 * 512 * 512 * 4KB = 22 * 29 * 29 * 212= 22+9+9+12 = 232 = 4GB. Without PAE With PAE But opearing system can leverage Page tables to map 4GB virtual address to physical 64GB memory. That’s why Intel bring PAE in. And CR3 which originally pointing to PD now pointing to PDP got the alternate name: PDPTR (Page Directory Pointer Table Register). 4-Level In 2003, AMD introduced AMD64, the 64-bit extensions to i386 architecture, page tables have to be extended again: current CPUs will map 48-bit virtual addresses to 52-bit physical addresses. Even making full use of 512 entries of PDP can only allows 39-bit (12+9+9+9) virtual address (512 GB). So, the new level was introduced to support at most 48-bit (256 TB) virtual memory (They will introduce more level if 256 TB virtual memory is not enough, and this just need changing of OS leaving application-level intact. The questions is what is its name… “Page Direcotry Indirect Pointer (PDIP)”? “Page Directory Pointer Directroy (PDPD)”? Sounds like PPAP (Pen Pienapple Apple Pen). No, they finally found how stupid it is to use this kind scheme and number will be a smart idea (like registers). The new level is called “Page Map Level 4 (PML4)” and other levels are unchanged for consistency. The AMD specification requires that bits 48 through 63 of any virtual address must be copies of bit 47 (in a manner akin to sign extension) ###Linux Terminology As you know, programmers are all unruly and always have their own regulations. In linux, may be easier to programming I guess, they use other terms. For level1 (The least level), the terms are same: PT &amp; PTE (Page Table &amp; Page Table Entry). Other levels have their own name in Linux: Level 2: Page Middle Directroy (PMD) Level 3: Page Upper Directroy (PUD) Level 4: Page Global Directroy (PGD) And an ‘E’ suffix means corresponding entry. Because every time OS will be changed, so this may not a big deal for kernel developers. ###Xen In Xen you will find that they are more straight: Use Level 4-1 to indicating the 4 level page table. And here we have to mention another term: Machine address. You may have known that with segment mechanism, we use linear address to indicate address translated by segment mechanism. So Virtual Address (VA) -&gt; Linear Address and we use Linear Address to walk page table to get Physical Address (PA). But in virtualization environment, we have to distinguish Guest Physical Address (GPA) and Host Physical Address (HPA), so we introduce Machine Address (MA) to indicate the real physical address. Leave physical address unchanged so that guest kernel doesn’t need any knowledge from host. And another page table: Extend Page Table (EPT) in Intel / Nested Page Table (NPT) in AMD is introduced to translate GPA to HPA(MA). PT is used to translate Host Virtual Address (HVA) to HPA or GVA to GPA in virtualization environment. ###End It’s clear that L4PTE/L3PTE is better than PGDE/PUDE or PML4E/PDPTE… When you are using EPT/NPT, L4EPTE/L4NPTE is easier to understand as well. Misc2017-03-09 The GFP in linux means “Get Free Page”.]]></content>
      <tags>
        <tag>linux</tag>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xen Log 7-Linear Page Table]]></title>
    <url>%2Fblog%2F2016%2F11%2F30%2Fxen-log-7-guest-linear-page-table%2F</url>
    <content type="text"><![CDATA[When you see memory layout of Xen, you may found that there is a range named :Guest Linear Page Table. You can find this in $XEN_DIR/xen/include/include/asm-x86/config.h. So what is the purpose of this range? Before we dig into the page table, you may need to read previous post [The Funny Page Table Terminology] to learn about some page table terms used in Xen. This question may help you as well: What’s the purpose of linear page table (PML4 entry 258) In config.h, we can find memory layout of Xen: config.h12345678910111213141516171819202122...# HYPERVISOR_VIRT_START# RO_MPT_VIRT_START * 0xffff800000000000 - 0xffff803fffffffff [256GB, 2^38 bytes, PML4:256] * Read-only machine-to-phys translation table (GUEST ACCESSIBLE). # RO_MPT_VIRT_END* 0xffff804000000000 - 0xffff807fffffffff [256GB, 2^38 bytes, PML4:256] * Reserved for future shared info with the guest OS (GUEST ACCESSIBLE). * 0xffff808000000000 - 0xffff80ffffffffff [512GB, 2^39 bytes, PML4:257] * ioremap for PCI mmconfig space * 0xffff810000000000 - 0xffff817fffffffff [512GB, 2^39 bytes, PML4:258] * Guest linear page table. * 0xffff818000000000 - 0xffff81ffffffffff [512GB, 2^39 bytes, PML4:259] * Shadow linear page table. * 0xffff820000000000 - 0xffff827fffffffff [512GB, 2^39 bytes, PML4:260] * Per-domain mappings (e.g., GDT, LDT). ... The PML4[258] is used as Guest Linear Page Table. What the hell is it??? After printing the PT of Xen after initialization: 12345678910111213141516171819202122232425262728293031323334353637383940(XEN) |=========PT Info========|(XEN) |-------L4: 000000008ce4b000(XEN) |------id: 0, L3: 000000008d40d000(XEN) |-----id: 0, L2: 000000008d40c000(XEN) |----id: 0, L1: 000000008ce4c000(XEN) |------id: 256, L3: 00000002393b9000(XEN) |-----id: 0, L2: 00000002393b7000(XEN) |------id: 258, L3: 000000008ce4b000(XEN) |-----id: 0, L2: 000000008d40d000(XEN) |----id: 0, L1: 000000008d40c000(XEN) |-----id: 256, L2: 00000002393b9000(XEN) |----id: 0, L1: 00000002393b7000(XEN) |-----id: 258, L2: 000000008ce4b000(XEN) |----id: 0, L1: 000000008d40d000(XEN) |----id: 256, L1: 00000002393b9000(XEN) |----id: 258, L1: 000000008ce4b000(XEN) |----id: 261, L1: 000000008ce4a000(XEN) |----id: 262, L1: 000000008ce49000(XEN) |-----id: 261, L2: 000000008ce4a000(XEN) |----id: 0, L1: 00000002393b8000(XEN) |----id: 256, L1: 00000002393bb000(XEN) |----id: 319, L1: 000000008ce48000(XEN) |----id: 320, L1: 00000002393b5000(XEN) |----id: 321, L1: 00000002393b6000(XEN) |----id: 322, L1: 000000008ce47000(XEN) |----id: 384, L1: 000000023cd9e000(XEN) |-----id: 262, L2: 000000008ce49000(XEN) |----id: 0, L1: 000000008ce43000(XEN) |----id: 2, L1: 000000008ce45000(XEN) |----id: 3, L1: 000000008ce46000(XEN) |----id: 4, L1: 000000008f7fd000(XEN) |----id: 8, L1: 000000008f7fb000(XEN) |------id: 261, L3: 000000008ce4a000(XEN) |-----id: 0, L2: 00000002393b8000(XEN) |-----id: 256, L2: 00000002393bb000(XEN) |----id: 0, L1: 00000002393ba000(XEN) |-----id: 319, L2: 000000008ce48000(XEN) |----id: 510, L1: 000000008f7fe000(XEN) |----id: 511, L1: 000000008d408000... Wait, see what we found. The contents of PML4[258] has the same physical address of PML4 itself! (See line: 2, 8, 13, 16) They all have same physical address: 8ce4b000. So when we walk this page table, we will always find PML4 and if we use a recursive function withoud limitation, this will cause stack overflow. From the question, it seems that this can faciliate the locating of a PTE from VA but how and why? (In this post I will use l4pt-l1pt instead of pgd, pud, pmd and pt) Page Table WalkingIn development, we may want to change a data page to be readonly. Traditionally, you will get a 48-bit VA (The high 16-bit will always be 1 or 0 according to AMD specification). We will devide 48-bit VA in this way: 12345678|---------------------- 48-bit Virtual Address ------------------------||--- 9 bit ---|--- 9 bit ---|--- 9 bit ---|--- 9 bit ---|--- 12 bit ---||--L4 offset--|--L3 offset--|--L2 offset--|--L1 offset--|--- offset ---||------------ offset is used in corresponding PT/Data Page ------------||--- L4 PT ---|--- L3 PT ---|--- L2 PT ---|--- L1 PT ---|- Data Page --||64-bit * 512 |64-bit * 512 |64-bit * 512 |64-bit * 512 |-- 4KB Page --| After walking 4 levels page table, using each 9-bit seg as offset in corresponding level of PT and plusing its 12-bit offset in VA, we can finally locate accurate physical address of this virtual address. The translation is done. Each level PT is a 4K page saving 64-bit info * 512 entries. 1234/* Info stored in each level PTE */|------------ 64-bit info stored in PTE -----------||--- 16 bit ---|------ 40 bit ------|--- 12 bit ---||-- reserved --|- PA of next level -|---- flag ----| While current OS supporting max 52-bit physical address, the higher/most 16 bits of 64-bit info is reserved for future hardware/software using (63-bit is used as NX, non-executable on some hardware). And lower 52-bit will store the physical address of next level PT. As physical memory is also devided into 4K page, the least 12 bits will always be zero for one page. That’s why we can use least 12bits to store flags. Linear Page TableNow we want to set one data page as readonly (We can only control them in page granularity), meaning that we need to change R/W flag of L1PTE that pointing to this data page. Then, the address of this L1PT is needed. The intuitive way is using VA of data page to walk PT and stop at L1PTE. And change the flag of L1PTE. So, you need to: L4PT->L3PT Read PA of L4PT from CR3 (noted as PA4), Add L4 offset(note as offset4) to this PA and make it into a VA4 Using VA4 to walk 4-level PT and get its 64-bit info which means you get PA of L3PT (noted as PA3). L3PT->L2PT Add offset3 to PA3 and make this into a VA3 Using VA3 to walk 4-level PT and get its 64-bit info. Get PA2 L2PT->L1PT Add offset2 to PA2 and make this into a VA2 Using VA2 to walk 4-level PT and get its 64-bit info. Get PA1 Change flag of L1PT Add offset1 to PA1 and make this into a VA1 so that you can derefer it. *VA1 &amp;= ~R/W flag. (*VA1 will aslo using VA1 to walk 4-level PT) We can find that, to change the flag of this data page, we need to walk 4-level PT 4 times! It’s inefficient. And make every PA to VA, we have to prepare a Direct Mapping of all physical memory. Now it is the job of Linear Page Table. Linear Page Table is actually one L4PTE, and its 64-bit info saves the PA4. (Not PA3! but PA4 which is exactly same with PA stored in CR3). So walk this PTE will give you infinite loop of it self. Take the example in Xen (PML[258]). If we have a VA that offset4 is 258, you will find this: 123456789|---------------------- 48-bit Virtual Address ------------------------||- 258/0x102 -|--- 9 bit ---|--- 9 bit ---|--- 9 bit ---|--- 12 bit ---||--L4 offset--|--L3 offset--|--L2 offset--|--L1 offset--|--- offset ---|/* L4 offset (PML4[258]) will give you L4PT! ===&gt;|---------------------- 48-bit Virtual Address ------------------------||- 258/0x102 -|--- 9 bit ---|--- 9 bit ---|--- 9 bit ---|--- 12 bit ---||--L4 offset--|--L4 offset--|--L3 offset--|--L2 offset--|--L1 offset:000--| Because offset4 258 will bring you into L4PT again instead of L3PT, you will use next 9-bit seg as L4 offset to walk L4PT again. Eventually, you will have no extra 9-bit to walk L1PT and stop at L2PTE which saves PA of L1PT(PA1). !!! The PA1 is gotten ?! We made so much effort and walk the 4-level so many times… And, you get a bonus. Don’t forget the least 12-bit, the 12-bit is final offset, we can use this to locate the L1PTE we want! And this strange new VA is just the VA of this L1PTE (VA1). Just with a special L4PTE, we have saved us from 3-times 4-level PT walking and don’t need to prepare the Direct Mapping as well. So, let’s constuct the new VA: I will use 49-19 to note each 9-bit seg in VA. 1234567891011121314151617/* Original VA: */|------------------------ 48-bit Virtual Address --------------------------||-- 9 bits ---|--- 9 bits ---|--- 9 bits ---|--- 9 bits ---|--- 12 bits --||--- 47:39 ---|--- 38:30 ---|--- 29:21 ---|--- 20: 12 ---|---- 11:0 ----||-- L4 offset--|-- L3 offset--|-- L2 offset--|-- L1 offset--|-- PA offset--|/* Constructed new VA of L1PTE: */|- 258/0x102 --|--L4 offset --|--L3 offset --|--L2 offset --|L1 offset 000 |/* Similarly, VA of L2PTE: */|- 258/0x102 --|- 258/0x102 --|--L4 offset --|--L3 offset --|L2 offset 000 |/* VA of L3PTE: */|- 258/0x102 --|- 258/0x102 --|- 258/0x102 --|--L4 offset --|L3 offset 000 |/* VA of L4PTE: */|- 258/0x102 --|- 258/0x102 --|- 258/0x102 --|- 258/0x102 --|L4 offset 000 | The least 12-bit, we can append 9-bit three zero. Because each 64-bit info entry is 8 bytes (so we need 3 zero) and with such sugar, we can locate each level of PTE and any VA as we want. An Implementation123456789101112131415161718192021#define LINEAR_PT_OFFSET 258#define L4_PAGETABLE_SHIFT 39 /* 12 + 9 * 3 */#typedef unsigned long vaddr_tpte_t * fun(vaddr_t vaddr, unsigned lv)&#123; vaddr_t ret = 0; uintptr_t offset = LINEAR_PT_OFFSET &lt;&lt; L4_PAGETABLE_SHIFT; uintptr_t vmask = (1UL &lt;&lt; 48) - 1; /* Most 16 bits are reserved */ int i; if ( lv &lt; 1 || lv &gt; 4 ) return 0; ret |= vaddr &amp; (~vmask); /* Clear VA, put reserved 16 bits */ vaddr &amp;= vmask; /* Just keep VA */ for ( i = 0; i &lt; lv; i++ ) ret |= offset &gt;&gt; (i * 9); /* Construct our new vaddr as above */ ret |= (vaddr &gt;&gt; (9 * lv) &gt;&gt; 3 &lt;&lt; 3); /* Append 3 zero */ return (pte_t *)ret;&#125; EndThis is better to be used in full 4-level page walking. Be careful when use this trick for PSE page (which will not go througn full 4-level page walking). ChangeLog 2018-06-27: Refine the desciption of constructed virtual address]]></content>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Forward]Relocation Truncated to Fit]]></title>
    <url>%2Fblog%2F2016%2F11%2F29%2Frelocation-truncated-to-fit%2F</url>
    <content type="text"><![CDATA[Interesting linker errorWhen you are programing a x64 program, it’s high likely that you encounter such a error: “relocation truncated to fit: R_X86_64_32S against symbol“. What happened? especially when you can run this program successfully on an old machine with same / old version. It may appears when you write inline assembly or after you changed your linker script. This article may also help you: relocation truncated to fit - WTF? Although forward is not recommended, this article is pretty useful for me and this can be treated as a replication just in case. Following is forwarded from above article; 1(.text+0x3): relocation truncated to fit: R_X86_64_32S against symbol 'array' defined in foo section in ./pcrel8.o Consider following code snippet: 12345678910111213$ cat foo.s.globl foovar .section foo, &quot;aw&quot;,@progbits .type foovar, @object .size foovar, 4foovar: .long 0.text.globl _start .type function, @function_start: movq $foovar, %rax The C program may be like this: 12345int foovar = 0;void function(void) &#123; int *bar = &amp;foovar;&#125; And when you disassembly the code: 123456789101112$ gcc -c foo.s$ objdump --disassemble-all ./foo.o./foo.o: file format elf64-x86-64#Disassembly of section .text:0000000000000000 &lt;_start&gt;: 0: 48 c7 c0 00 00 00 00 mov $0x0,%rax#Disassembly of section foo:0000000000000000 &lt;foovar&gt;: 0: 00 00 add %al,(%rax) ... You may have found that mov only has 4 byted allocated for linked to put in the address of foovar. If you check the relocation: 12345$ readelf --relocs ./foo.oRelocation section '.rela.text' at offset 0x3a0 contains 1 entries: Offset Info Type Sym. Value Sym. Name + Addend000000000003 00050000000b R_X86_64_32S 0000000000000000 foovar + 0 Type R_X86_64_32S is only a 32-bit relocation. So you have figurred the problem. 12345678$ cat test.ldsSECTIONS&#123; . = 10000; .text : &#123; *(.text) &#125; . = 5368709120; .data : &#123; *(.foo) &#125;&#125; This now means that we can not fit the address of foovar inside the space allocated by the relocation. When we try it: 123$ ld -Ttest.lds ./foo.o./foo.o: In function `_start':(.text+0x3): relocation truncated to fit: R_X86_64_32S against symbol `foovar' defined in What this means is that the full 64-bit address of foovar, which now lives somewhere above 5 gigabytes, can’t be represented within the 32-bit space allocated for it. For code optimisation purposes, the default immediate size to the mov instructions is a 32-bit value. This makes sense because, for the most part, programs can happily live within a 32-bit address space, and people don’t do things like keep their data so far away from their code it requires more than a 32-bit address to represent it. Defaulting to using 32-bit immediates therefore cuts the code size considerably, because you don’t have to make room for a possible 64-bit immediate for every mov. So, if you want to really move a full 64-bit immediate into a register, you want the movabs instruction. Try it out with the code above - with movabs you should get a R_X86_64_64 relocation and 64-bits worth of room to patch up the address, too. If you’re seeing this and you’re not hand-coding, you probably want to check out the -mmodel argument to gcc. So, you may need to change the origin address in your linker script or use movabs instead to avoid this problem.]]></content>
      <tags>
        <tag>programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xen Log 6-Xentrace]]></title>
    <url>%2Fblog%2F2016%2F09%2F21%2Fxen-log-6-xentrace%2F</url>
    <content type="text"><![CDATA[Xentrace 能够帮助你知道在Hypervisor中发生了什么，作为一个统计工具，可以记录所有的VMEnter/Exit、Schedule、Dom0ops等信息，并能够指定统计哪个cpu、记录哪些事件的信息。在进行一些验证、测试或Resource counting的时候有比较大的作用。 Debug 系列: Add New Hypercall to Xen Debug Xen on Physical Machine Xentrace(本篇) Debug Key 使用Xentrace非常简单，在安装Xen tools的时候就已经安装好了xentrace, 直接调用即可: 1xentrace -D -e all -T 10 trace.raw -D 删掉之前的buffer, -e 是设置trace的事件类型: $XENDIR/xen/include/public/trace.h 12345678910111213ID Description0x0001f001 TRC_LOST_RECORDS0x0002f001 TRC_SCHED_DOM_ADD0x0002f002 TRC_SCHED_DOM_REM0x0002f003 TRC_SCHED_SLEEP0x0002f004 TRC_SCHED_WAKE0x0002f005 TRC_SCHED_YIELD0x0002f006 TRC_SCHED_BLOCK0x0002f007 TRC_SCHED_SHUTDOWN0x0002f008 TRC_SCHED_CTL0x0002f009 TRC_SCHED_ADJDOM…… -T 是设置trace的时间 生成的内容是二进制，我们没有办法直接读取，这时就要借助xenformat: $XENDIR/tools/xentrace/xentrace_format $XENDIR/tools/xentrace/1cat trace.raw | xentrace_format ~/$XENDIR/tools/xentrace/formats &gt; trace.txt 在xentrace/formats 可以看到所有的事件类型和对应的输出格式，根据需要我们可以自行修改。 在Xen中，如果我们想要自己记录一些信息，除了在需要的地方加printk，还可以借助trace: $XENDIR/xen/include/xen/trace.h1234567891011121314#define TRACE_0D(_e) \ do &#123; \ trace_var(_e, 1, 0, NULL); \ &#125; while ( 0 ) #define TRACE_1D(_e,d1) \ do &#123; \ if ( unlikely(tb_init_done) ) \ &#123; \ u32 _d[1]; \ _d[0] = d1; \ __trace_var(_e, 1, sizeof(_d), _d); \ &#125; \ &#125; while ( 0 ) 文件中的0D-5D就是记录的数据的多少，如果我们要记录3个数据，就选用3D即可。 如果想要增加自定义的事件类型，在$XENDIR/xen/include/public/trace.h中添加自己的事件类型: $XENDIR/xen/include/public/trace.h1234567#define TRC_HVM_TRAP_DEBUG (TRC_HVM_HANDLER + 0x24)#define TRC_HVM_VLAPIC (TRC_HVM_HANDLER + 0x25)/* Add customized event */#define TRC_HVM_ALICE (TRC_HVM_HANDLER + 0x26)/* Record our own event somewhere */TRACE_0D(TRC_HVM_ALICE); 之后再trace.raw中就会出现我们自己定义的Trace. Example我们想捕捉所有关于HVM的信息: 12# 0x8f000 is TRC_HVM, check in trace.hsudo xentrace -D -e 0x8f000 -T 10 trace.raw 经过10s后: 1cat trace.raw | xentrace_format $XENDIR/tools/xentrace/formats &gt; trace.log Log 中的结果如下: 12345678CPU2 1712035142503524 (+ 22501) VMEXIT [ exitcode = 0x00000010, rIP = 0xffffffff8102d73f ]CPU2 0 (+ 0) CR_READ [ CR# = 0, value = 0x000000008005003b ]CPU2 0 (+ 0) CR_WRITE [ CR# = 0, value = 0x0000000080050033 ]CPU2 1712035142544733 (+ 41209) vlapic_accept_pic_intr [ i8259_target = 1, accept_pic_int = 0 ]CPU2 1712035142546137 (+ 1404) VMENTRYCPU2 1712035142872709 (+ 326572) VMEXIT [ exitcode = 0x00000000, rIP = 0xffffffff810644f4 ]CPU2 0 (+ 0) CR_READ [ CR# = 0, value = 0x0000000080050033 ]CPU2 1712035142878262 (+ 5553) vlapic_accept_pic_intr [ i8259_target = 1, accept_pic_int = 0 ] 可以看到Trace记录了期间发生的所有关于HVM的相关事件，VMExit的原因等等，通过修改formats，我们可以使得输出符合我们自己的要求(比如去掉里面的+， 增加空格等)以方便后续进行处理。 Note使用Trace的一大好处是我们可以记录一些频繁发生的事件，使用printk时会导致console有大量输出而无法响应，trace就可以很好解决我们的这一问题，同时trace可以用来统计一段时间内某个事件发生的频率等等。在debug或者测试的时候非常好用。 Change Log 2017-05-11: Add Debug series]]></content>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xen Log 5-Debug Xen on Physical Machine]]></title>
    <url>%2Fblog%2F2016%2F09%2F18%2Fxen-log-5-debug-xen%2F</url>
    <content type="text"><![CDATA[一开始的时候我们是在虚拟机里面调试Xen的，但是因为Qemu是不能模拟EPT的，所以在虚拟机里面起一个Xen，这个Xen的功能非常受限(不能使用EPT)。而且当时项目在虚拟机里面能跑，一到真机上就跑不了，所以不得不用真机来调，这里记录一下调试Xen的环境搭建。 Debug 系列: Add New Hypercall to Xen Debug Xen on Physical Machine(本篇) Xentrace Debug Key LogXen的Log是记录在内存中的，所以不能再崩了之后回到Linux里面去翻log, 而且如果Hypervisor在初始化Xen之前就崩掉的话，我们是获取不到任何信息的，所以还是老老实实按老方法用串口来吧.. rs232串口使用rs232串口来进行调试，需要注意一点，Xen是不能使用USB来进行调试的！For serial console you CAN’T use USB-serial dongles on the computer running Xen! (usb-serial dongles are not seen as real serial ports by the hardware or Xen, so usb-serial ports are NOT available in the beginning of boot process).(1) 还有一点需要注意的是串口线是有延长线和交叉线的，交叉线的2/3号口是交叉的，一个输入一个输出，可以用根铜线来测试.. 两个电脑相连一般是交叉线。 USB转rs232用来读串口的机子可以使用USB转rs232串口线来读数据(毕竟笔记本和比较新的台式机一般是没有串口卡的) 测试机minicomLinux上读写串口可以用非常好用的minicom 123sudo minicom -s [-C filename]#-s is setup#-C is capturefile used for log 基本上打开minicom -s后 根据里面的提示就可以进行设置，在Linux中USB-rs232的设备文件是/dev/ttyUSB0, 波特率这些根据需要设定: ` 设置完后Exit就会出现这样的画面： 这个时候有任何信息在串口的另一端发过来，这边都可以通过USB-rs232读进来，并且在这个页面我们也可以直接输入信息发送过去(默认自己输入的内容自己这边是带回显的，可以设置成不回显) 配置的时候请自行dmesg查自己串口的信息去配! 不是所有的都是ttyUSB0的好么. Restart Xen only ONCE(2)在之前安装Xen的时候我们设置了grub自动启动Xen, 这里由于Xen可能会崩溃，所以我们需要的是仅在下一次启动Xen, 这样崩溃后会自动重启到普通的Linux With GRUB v1在 /boot/grub/menu.list set “default” to “saved”. For example: 12345678910111213default saved ## important.timeout 5color cyan/blue white/bluetitle Debian GNU/Linux, kernel 2.6.18-4-k7root (hd0,2)kernel /boot/vmlinuz-2.6.18-4-k7 root=/dev/sda3 roinitrd /boot/initrd.img-2.6.18-4-k7title WinXProot (hd0,0)makeactivechainloader +1 之后运行grub-install来更改设置 With GRUB v2设置GRUB_DEFAULT 为saved, 如下: /etc/default/grub12345678910# If you change this file, run 'update-grub' afterward to update# /boot/grub/grub.cfg.# For full documentation of the options in this file, see:# info -f grub -n 'Simple configuration'GRUB_DEFAULT=saved ## important.GRUB_TIMEOUT=5GRUB_DISTRIBUTOR=`lsb_release -i -s 2&gt; /dev/null || echo Debian`GRUB_CMDLINE_LINUX_DEFAULT="quiet"GRUB_CMDLINE_LINUX="" 接下来运行update-grub 来更新配置。并运行grub-set-default 0来将默认启动设置为第一项 每次我们都可以通过以下命令来启动指定的系统 12345sudo grub-reboot 2 #Restart to xensudo reboot# orsudo grub-reboot 0 #Restart to Linuxsudo reboot 如果想启动到Submenu的话，使用Menu&gt;submenu即可, 有的系统可能需要转义符。 123sudo grub-reboot 3\&gt;0 # Restart to Xen options, first submenu#or sudo grub-reboot "3&gt;0" Config Xen硬件的准备完成后，我们需要配置Xen和Dom0将信息输出到串口: 配置的时候请自行dmesg查自己串口的信息去配! 配置的时候请自行dmesg查自己串口的信息去配! 配置的时候请自行dmesg查自己串口的信息去配! loglvl=all, guest_loglvl=all: 开启所有log, 可以根据需要选择level com1=115200, 8n1, 0xe020: Xen会将识别到的串口认为是com1, 而真实的串口需要我们在linux中通过dmesg查: (没启动前Xen时的linux, 启动Xen之后可能查不到) 12345sudo dmesg | grep tty[ 0.000000] console [tty0] enabled[ 3.494349] 00:05: ttyS0 at I/O 0x3f8 (irq = 4, base_baud = 115200) is a 16550A[ 7.807560] usb 1-1.3: pl2303 converter now attached to ttyUSB0 上面这种就属于启用的是ttyS0, 0x3f8是串口的地址, 中断为4, 波特率是115200, 因此com1在配置的时候就需要配置为com1=115200, 8n1, 0x3f8, 8n1指的是数据位为8，无校验位，停止位为1(一般默认这样就行). 因此这里就是告诉Xen com1真实对应的串口地址在哪里。(我用的是ttyS2, 地址是0xe020) sync_console: 保证输出是同步的，以防一些内容在xen crash之前打不出来 console_to_ring: 将Guest的log同步到dom0中打印输出. console=com1,vga: 将终端连到com1上，这样我们就可以通过串口输入用户名密码登陆 GRUB_CMDLINE_LINUX的配置主要是将dom0的信息通过Xen的串口输出. console=hvc0 earlyprintk=xen:是将dom0的log通过xen输出, xen对上层虚拟了一个hvc0, 所以dom0用这个就可以将输出打到Xen的串口中。 console=ttyS2, 115200n8: 这里ttyS2同样根据自己查出来的结果改，目的是在不启动Xen的情况下linux的log通过串口输出。 /etc/default/grub123456GRUB_CMDLINE_XEN="loglvl=all guest_loglvl=all com1=115200,8n1,0xe020 console=com1,vga com0_mem=4096"# This can guarantee sync output when using `printk`# GRUB_CMDLINE_XEN="loglvl=all guest_loglvl=all sync_console console_to_ring com1=115200,8n1,0xe020 console=com1,vga com0_mem=4096"GRUB_CMDLINE_LINUX_DEFAULT="console=tty0 console=ttyS2,115200n8"GRUB_CMDLINE_LINUX="console=hvc0 earlyprintk=xen" loglvl在Xen Log4中我已经提到过，能够决定哪些log被显示; CMDLINE_XEN 中Xen有一个build-in的串口COM1, 所以我们将Console连到com1即可获取到Xen的输出。 当LINUX作为dom0运行在Xen上的时候，需要使用hvc0(Hypervisor Virtual Console)进行输出。为了保证dom0不至于因为console没有初始化好而使得crash过早没有输出，我们可以打开earlyprintk, 这样console会提前进行初始化，并将输出交给xen, xen会将dom0的输出一并输出到com1。 1sudo update-grub 现在就可以在测试机上调试被测试机的Xen了。 Config Guest如果想要让Guest能够通过 xl console domid来进行交互的话，需要在Guest的启动参数中将Console连到ttyS0: 1GRUB_CMDLINE_LINUX="console=ttyS0" 这样就可以在被测试上通过串口来调试Guest了。 Tips想关掉X11也有很多方法，ubuntu上只要在LINUX_CMDLINE制定成text就行了，Debian的话把/etc/X11/default-display-manager里面设置成/bin/true就可以了，不过比较暴力.. 不过如果Hypervisor因为死循环而挂那了…除非有watchdog(我现在还没有启动起来过), 要不然就只能用一个板子连个跳线过来物理重启了… MiscRemote Force Restart有的时候在家，调Bug的时候可能实验室的测试机会死循环，这种情况下我们根本发不过去指令，目前我们用的方法比较笨。 在BIOS里面， Power management中设置AC BACK (接通电源时) 里面设置后面的选项为”Always ON“，这个每次有电源接通时电脑就会自动启动。 用能远程断电的电源(小米智能插座等，其他的继电器等)，远程关掉电源再接上，电脑就会自动接电。 这样电脑会重启到正常的Linux中，然后再用上面的方法就可以继续调试了。 Changelog: 2017-05-11: Add debug series 2017-03-28: Although I addressed to grep to find tty config…But it seems readers will ignore it… Address it three times:) 2017-03-21: Add detailed description of cmdline config 2017-01-08: Add remote Force Restart]]></content>
      <tags>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[岛国之行]]></title>
    <url>%2Fblog%2F2016%2F09%2F01%2Fjapan-trip%2F</url>
    <content type="text"><![CDATA[满血复活！从日本玩回来后各种精疲力尽，感觉身体被掏空，睡了两天后终于复活啦！！这次玩的还是非常开心而且充足的的，之前发的也只是非常简略的记录，这里记录一下行程有需要的小伙伴可以参考~ 不注明的话价钱全都是日元~ 住宿在D的强烈要求下，我们选择的是全日式的旅店，这里不得不安利一下江戸さくら, 简直是超乎预想的满意。店员的英语还是很不错的，所以即使不会日语也完全没有任何问题. 一间房的价格大约在18k(CNY1000+), 有wifi，早餐提供500的西式/800西式/800日式。日式早餐的量非常大… 洗衣+烘干衣服500/次，泡澡(温泉?)500/次。位置在鶯谷(上野附近，最后一天才知道原来鶯谷也是个小红灯区), 走路到地铁站要10min左右，晚上还是非常安静的。晚上还能看看东京TV的深夜动画:) 旅馆 日式早餐 宾馆500￥的西式早餐，800￥的还有一个煎蛋和两根烤肠。 另外如果是7月-8月去的，可以注意一下花火大会的时间，说不定能看一次呢，今年由于东京花火大会开的比较早我们没能看上也是一个遗憾。 行程第一天去的时候由于赶上了台风，本来下午4点到的飞机最后被迫18:00多降到了大阪机场，ANA给赔偿了2W(Take my money and shut up)，我们就赶了倒数第二班的新干线跑到了东京。日本新干线的好处就是和JR是同一家公司，所以机场到东京市区一路都是站内换乘，一次性买票直达。英语在机场是没问题的，不过东京市区的话如果会一些日语会更好。当地的中国人也很多，所以找他们帮忙问问路也完全OK. 晚上吃的就是拉面 800一碗800日元的拉面 第二天上午去了浅草寺、新东京塔, 还看到了朝日的大便一样的标志建筑= =。中午吃的鳗鱼饭，鳗鱼饭果然好贵，一份至少3000+，而且由于我不是很习惯日料，也没有觉得非常好。不过同学的小伙伴倒是赞不绝口… 下午坐水上bus(就是船..)去台场。船里面有一种是可以上到船顶上吹海风观光的，这也是多亏D同学的攻略.. 台场海滩就是众多动漫里面合宿放烟花的地方~ 浅草寺的大门~ 朝日啤酒和新东京塔 3800的鳗鱼饭.. 傍晚的台场 就是这个可以上到船顶排景的船！ 台场沙滩，甜品+冷饮 只差烟花了 台场沙滩，动漫里放烟花的地方 1:1的高达 日本的自由女神像 东京塔，目前好像是世界第一高 第三天去的是涩谷(去的时候没带多少衣服，在这里补给一下)。这里不得不感谢一下D和Y同学，这次我基本上没怎么查攻略，所以在准备充足的D同学带领下还是找到了非常不错的店买了一些衣服。因为涩谷的店一般开业普遍偏晚，所以我们早上就逛了明治神宫消遣一下。日本吃的还是好贵的，感觉饭价是上海5倍的样子，交通是国内2倍的样子，其他的开销倒是还好。 第四天去的伊豆修缮寺的温泉乡，其实本来想去箱根那边的，但是因为我们去的这段时间富士山封山所以那边不能愉快地玩耍就换了一个地方。温泉乡地处深山，店铺晚上17：00之后就基本上都关了，我们就是因为先前不知道而导致走了好远的路去吃晚饭.. 当然也有一个原因是我们选的旅店不提供晚餐.. 日本的环境要好很多，这种windows xp桌面一般的景色在我们玩的这几天经常能见到。 第五天，在温泉宾馆住了一晚之后就回来去了新宿，看了一下言叶之庭的取景地。逛了好多地方之后还是觉得虽然东京虽然就这么几个地方，但是动漫里却总是能一遍遍用..国内明明有这么多美丽的景色什么时候能用到动画里吖= = 晚上去看了最有名的红灯区，歌舞伎町。这里听说都是黑帮经营的，我们也看到了一个3层楼占地超级大的街机店，里面一堆的人玩パチンコ这种弹珠游戏..实在是不懂啊。不过也是我第一次见这么大的街机店。。红灯区真正灰色的店一般是不对外国人服务的，除非能装的别人根本看不出来而且还需要老司机带，主要原因是外国游客对于这里的规矩不是很懂所以…但是街道的繁华和夜生活的热闹和在山里的景色形成鲜明的对比，也让我不禁觉得国内夜生活丰富真是好啊~ 歌舞伎町，红灯一条街。 第六天：作为ACG圈内的我们自然是要去秋叶原逛一圈的，那边刚好也是电器街顺道买些电子产品也是不错的选择。作为宅的圣地，基本上已进入秋叶原整个画风就变了，目前是被LoveLive血洗的景色..us搞完继续捧Aqours了，不得不说Sunrise是个会赚钱的公司。不过秋叶原其实逛一天也就差不多了，除非是要买好多本子的或者要淘手办的才需要花费大量时间去挑。虽然手办基本上哪个店都有卖，但是有的非常坑，所以淘手办的话还是事先查一下攻略比较好。中古店里面会有一些意外的惊喜(一个1/7的翠星石手办竟然只要1200￥)。这边服务业的人员都非常敬业而且热情，所以有什么不懂得问他们就好啦，我一路就用蹩脚的日语各种问，在地铁站的时候还有一个本地的阿姨/大姐非常热情的过来帮忙，以为我们看不懂日语… (大姐您也不会说英语，哪来的自信过来帮忙呃= =)。本子店的话看到好多带口罩的..果然这种店还是不要被人认出来比较好么？…而且本子种类繁杂，所以比较快的方式还是问店员比较好..在找伊莉雅的时候分类就不在魔法少女伊莉雅的分类，还是店员帮我找的，具体的日文名字已经忘了.. B站在秋叶原的店，里面现在还没什么东西，卖的都是小电视，而且竟然是RMB/CNY标价。。你确定日本的小伙伴们不会理解错么= = 由于我爱的还不够深沉，在那也只是感受感受气氛没有大刀阔斧一掷千金，草草拍了些照就撤了。在手办店的时候没有看到拍摄禁止的提示，还被店员训斥了= = 这边原画、手办等为了保护知识产权都是不让拍照的…之后便去了市政厅。 与国内不同的事，这边的景点收费都不怎么贵，市政厅这种能俯瞰东京的地方对外也是免费开放，(东京塔还是要收费，不过之前逛过广州的小蛮腰和上海的东方明珠了，已经没什么兴趣了)。东京的建筑可能出于防震的考虑都不是特别高，与上海动辄上百层的建筑不同，在45楼也可以鸟瞰东京都。 市政厅45楼，我还是专门找了个有一些高楼的地方，不知怎么的总让我有一种末日片里旧东京和新东京的感觉，比如核爆默示录这种。远处那么矮的一片就好像灾后… 在中间建一圈高墙，就可以说”那一天人类又一次想起了…”这种台词了。 最后一天：早上去了築地的海鲜市场，築地的内场是周内才开，周末只有外场开。所以如果想看内场的需要在周内去，而且今年11月之后就要拆了哦…海鲜的品质是没得说的，即使只有外场也可以让吃货一饱口福。价格普遍都在1000￥左右。築地这里还有一个神奇的本愿寺，貌似是个吸收佛教后的神奇宗教。。 之后逛了东京大学，正好有东大的同学带我们转，百年的名校也确实给人以古朴、庄重的印象，而且同学说日本的学生和国内是很像的..也参观了剑道部，老实说剑道部并不是动画中那种你来我往互相过招的场景，更像是一击必杀..和乒乓球很像，能来回几个回合的情况是非常少的，一般2回合就结束了，不是先发制胜就是后发制胜，所以..完全不罗曼蒂克啊！！ 什么馆我已经忘了，反正电视剧里经常出现.. 神奇的本愿寺，看建筑风格就能看出来是个与众不同的宗教。 第二天一早就坐飞机回国了.. ## 饮食 在这几天，在吃货的带领下我也是把各种日本平价料理吃了一遍了。喜欢日料的小伙伴当然是如鱼得水，不过我这种更喜欢熟食和蔬菜的确实有点不适应，而且这边都是冰水简直要命。最便宜的基本上是麦当劳肯德基这种，里面各种中学生.. 普通的日料そば面(呃..和酸汤面有点像，不过不酸)300-500￥，拉面800-1000￥，定食1000￥(像盖饭吧)左右，中餐馆有饺子(都是煎饺)，而且店员基本上都会日语..一顿1000￥左右，咖喱800-1000￥，这边的咖喱饭要好吃很多，感觉回国不能再吃国内咖喱了.. 鳗鱼饭4000+，寿司一顿2000+，这边也有米其林餐厅自己量力而行吧。另外对于比较正式的店，一般中饭和晚饭的价格是不一样的，晚饭会高20%，所以如果想尝试高级料理的话推荐中午去吃，晚上就吃土吧。烧烤的价格不是很贵，比一顿鳗鱼饭便宜，吃的话强烈推荐カルビ(应该是烤牛隔膜肉)非常好吃，而且肉也很嫩不难咬。寿喜锅的话也是不错的，和广东的火锅比较像。还有关东铁板烧，这个是在东京的同学的推荐下吃的，我们之前不知道这个东东，可以自己动手烧，其乐无穷。天麩羅请一定吃一份正宗的，之前吃了一份天麩羅そば就是面里泡了个虾饼，在学校虾饼都吃伤了，完全是对天麸罗的侮辱。烧蟹黄也很好吃。 购物我推荐还是在亚马逊上买吧，关东地区和江浙沪一样基本上都是包邮1天到货，东西寄到宾馆白天该怎么玩怎么玩，而且电子产品网上便宜，书本和店里面一模一样的价钱！真的是一模一样，我在书店买一本书1300+104的税，亚马逊上就是1404包邮。化妆品的话和免税店里面的价格也差不多，所以如果想要玩的好的话..还是在网上买比较好一些。当然专程来购物逛街的当我没说，涩谷买买买就好啦。 End总的来说玩的非常开心，不含购物总共的开销CNY 9000元多一点，汇率是CNY1=JPY15.2左右。除了空气、环境好这一点令我印象深刻以外，其他的也没有觉得比国内好很多。 公共交通相较于国内，没有国内的网布的深布的广，但是因为日本人少所以乘车体验非常不错。新干线的座位要比HSR高铁的位置更宽敞一些，而且新干线还有自由席，(我看到了不止一个在新干线上拖鞋的日本妹子，乘坐这个还是比较享受的)但是贵的要死..新干线和JR以及机场快线由于都是JR运营，所以之间的换乘非常方便。我看到知乎和贴吧有好多喷中国这点的，其实我觉得国内做的也不错了，最起码在西安的时候高铁北站、地铁一路坐过来站内换乘还是非常舒服的，而且坐新干线更像坐地铁(买了票在站台等一班来坐上就好)，而国内更像坐火车(有候车室，卡班次，提前买票等等)。 吃和行的消费要贵，但是用、穿要便宜，而且听说房价也比国内低很多。最低工资的话计算机软件这行：时薪是1000￥，年薪是2000k￥(所以这边年薪十几万RMB是最低工资,不用交税..)，但是看到找人广告上程序员的年薪给的也是240万￥，这个价格比国内高的也不是特别多，所以日本缺程序员还是比较好理解的，之前看动画公司原画师的工资也是低的可怜.. 国家确实还是小，所以旅游的话国内感觉景色更美，种类也更多。动漫文化已经深入到方方面，工地施工标示、警方提醒表示、各地的宣传等很多都是用二次元的人物形象。比国内某些页游还要请三次元明星来代言要能接受多了，(我不断地寻找，油腻的师姐在哪里这种梗已经..) 工薪族们的穿着非常统一，白衬衫黑裤子，回国后看到地铁上穿得花花绿绿的社会人士，其实觉得日本这边还是有点压抑的，加之地铁上相对比较安静这种感觉也更加突出。 日本的动画在电视上播一遍后想要再看就需要自己买碟了，这一点还是国内好些，网络视频要更宽松一些，即使采取会员收费的形式也是可以接受的。而动漫产业链可以发现国内的非常不足，国内的动画最多出几个T-shirt就了不起了，更多都是和游戏合作进行宣传，日本的动画其周边可以说只有你想不到的没有他们做不出来的。(这个美术部有问题里面那个小学生的挂饰都已经有同款在卖了)可以说日本出周边的能力和某宝的能力有的一拼。 一圈下来也见到了同学，果然是南方的少年，过去一年后整个人气色都好了很多，当时在西安简直就是病弱..也发现自己的日语其实还是够生活用的，听力也没有自己想象中的那么查，倒是激起了自己继续学习画画的欲望，不知道成为画师大触的梦想能在何时实现= =]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言预处理]]></title>
    <url>%2Fblog%2F2016%2F02%2F03%2Fprecompile%2F</url>
    <content type="text"><![CDATA[C语言预处理有三种：宏定义，文件包含，条件编译 文件包含很常见，条件编译则可以通过是#ifdef, #if 使得编译时的源码包含(不包含)某些内容。宏定义则主要是进行替换，本文主要记录宏定义的相关内容。 部分内容参考了贴吧：http://tieba.baidu.com/f?kz=1044315227 ##语法 1#define identifier string 需要注意的是： 名称一般全部大写 宏定义是预编译使用的，不是语句，末尾没有分号 宏定义可以嵌套 可以使用#undef来终止宏定义的作用域 不替换””中的字符串内容 ##带参宏定义 宏定义可以带参数，用小括号表示参数： 12345#define S(a,b) a*barea = S(3,2);=&gt; area = a*b;=&gt; area = 3*2; 不过这样容易出现一些问题： 123456#define S(r) r*rarea = S(a + b);=&gt; area = a + b * a + b;#define S(r) ((r)*(r))=&gt; area = ((a + b) * (a + b)); 预编译只对宏进行简单的替换 ###常见用法 防止头文件被重复包含 1234#ifndef COMDEF_H#define COMDEF_H/* Contents of header*/#endif 得到指定地址上的一个字节/字 12#define MEM_B(x) (*( (byte *)(x) ))#define MEM_W(x) (*( (word *)(x) )) 求最大值or最小值 1#define MAX(x,y) ( ((x) &gt; (y)) ? (x) : (y) ) 得到一个变量的地址 1#define B_PTR(var) ( (byte *)(void *) &amp;(var) ) ROUNDUP or ROUNDDOWN 12#define ROUNDUP(var, base) (((var) + (base) - 1) / (base) * (base))#define ROUNDDOWN(var, base) ((var) / (base) * (base)) HIGH/LOW Byte 12#define WORD_LOW(var) ((byte) ((word)(var) &amp; 255))#define WORD_HIGH(var) ((byte) ((word)(var) &gt;&gt; 8)) UPCASE 1#define UPCASE (c) ( ((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'z') ? ((c) - 0x20) : (c) ) 防止溢出 1#define INC_SAT(var) (var = ((var) + 1 &gt; (var)) ? (var) + 1 : (var)) 防止出错 123456789101112131415161718192021222324#define ADD(a, b) (a + b);\ a++#define ADDv2(a, b) do &#123;\ a + b;\ a++;\ &#125; while(0)if (condition) ADD(a, b);=&gt; if (condition) (a + b);a++; /* Wrong!! */if (condition) ADDv2(a, b);=&gt;if (condition) do &#123; a + b; a++; &#125; while(0);/* Right */ struct相关用法为了得到一个field在结构体中的偏移，可以使用这样宏 12#define FPOS(type, field) \ ( (dword) &amp;((type *)0)-&gt;field ) 由于取地址会将field的偏移加上struct的首地址后返回，而我们如果将0转换为当前struct的首地址的话，那么返回的值刚好就是field在此struct中的偏移了。 为了得到field所占用的字节数： 1#define FSIZ(type, field) sizeof( ((type *)0)-&gt;field ) ##GCC Standard Predefined Macros GCC预定义了一些宏能帮助我们进行调试和输出，常见的有：__FILE__, __LINE__, __DATE__, __TIME__, __attributes__, __DEBUG__等等， 具体可以参考: GCC Standard Predefined Macros GCC Extensions to the C Language Family ##和#的用法使用#可以将宏参数变成一个字符串，而##则可以把宏参数单纯地拼接起来 12345678#define STR(s) #s#define CONS(a, b) int(a##e##b)printf(STR(alice));=&gt; printf("alice");printf("%d", CONS(2,3));=&gt; printf("%d", 2e3); /* printf 2000 */ ##宏的嵌套 当宏里面含有#或##的时候，这一部分的宏不会再被展开 12345678910111213#define TOW (2)#define MUL(a, b) (a * b)printf("%d", MUL(TOW, TOW));=&gt;printf("%d", ((2) * (2)));#define NUM (2)#define STR(s) #s#define CONS(a, b) int(a##e##b)STR(NUM) =&gt; "NUM"CONS(NUM, NUM) =&gt; int(NUMeNUM) 为了解决这种情况，需要加一层中间转换宏： 123456789101112#define _STR(s) #s#define STR(s) _STR(s)#define CONS1(a, b) axxxxxb#define CONS2(a, b) a##xxxxx##bprintf(STR(CONS2(1, 2)));=&gt; printf(_STR(1xxxxx2));=&gt; printf("1xxxxx2");printf(STR(CONS1(1, 2)));=&gt; printf(_STR(axxxxxb));=&gt; printf("axxxxxb"); ###相关用法 合并匿名变量 12345678#define __ANONYMOUS1(type, var, line) type var##line#define _ANONYMOUS0(type, line) __ANONYMOUS1(type, _anonymous, line)#define ANONYMOUS(type) _ANONYMOUS0(type,__LINE__)ANONNYMOUS(static int);=&gt; _ANONYMOUS0(static int, __LINE__); /* Suppose line number is 33 */=&gt; __ANONYMOUS1(static int, _anonymous, 33);=&gt; static int _anonymous33; 填充结构 12345678910#define FILL(a) &#123;a, #a&#125;enum IDD&#123;OPEN, CLOSE&#125;;struct MSG &#123; IDD id; const char * msg;&#125;struct MSG _msg[] = &#123; FILL(OPEN), FILL(CLOSE) &#125;;=&gt; struct MSG _MSG[] = &#123; &#123; OPEN, "OPEN" &#125;, &#123; CLOSE, "CLOSE" &#125; &#125;; 得到数值类型所对应的字符串的大小 12#define _TYPE_STR_SIZE(type) sizeof #type#define TYPE_STR_SIZE(type) _TYPE_STR_SIZE(type) ##typedef 许多人会把typedef也作为预处理的一部分，包括我参考的这个贴吧的原文。但是typedef与define本质是不同的，typedef是语句。 语句意味着： 1. 末尾有分号 2. 在编译时才进行处理 3. 在函数内部不能使用typedef 4. 编译器会对typedef后变量的使用进行编译时检查 123456789101112#define PINT int *#typedef int * pint; /* Has semicolon ; */const pint p1; /* Declare a const pointer */=&gt; int * const p1;p1 = NULL; /* Wrong */*p1 = 0; /* Right */const PINT p2; /* Declare a pointer pointing a const value */=&gt; const int *p2; &lt;=&gt; int const *p2;p2 = NULL; /* Right */*p2 = 0; /* Wrong */]]></content>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加速工作的小工具]]></title>
    <url>%2Fblog%2F2016%2F01%2F30%2Ftools-and-plugins%2F</url>
    <content type="text"><![CDATA[我个人在工作之前总是喜欢先详细了解一下涉及到的工具，以致于都被实验室的小伙伴吐槽我每日的工作内容就是研究各种工具、插件..说来也惭愧，确实没有干什么活，倒是花了不少时间在配工具上..本文记录一下自己在接触Linux后遇到的非常赞的一些工具以及使用了这么多年Windows后用起来比较顺手的一些小软件。 #Z-shell、tmux &amp; Vim 这三个文本三巨头网上介绍的文章数不胜数，也确实是因为它们非常好用。 ##Z-shell Zsh推荐使用oh-my-zsh, 相比较原本的zsh其插件更全。不过有很多小伙伴下载了oh-my-zsh也就只是使用默认的配置了。默认配置中开启了git插件，可以让我们的git目录产生一些比较不错的效果： 不过还是推荐一下开启一下 z 和 d 插件： ~/.zshrc12345# Add wisely, as too many plugins slow down shell startup.plugins=(git z d zsh-autosuggestions)#User configuration... zsh对于命令和文件名的自动补全要比bash强大太多，这也是为什么我选择它的原因。 ###z plugin z类似于模糊跳转 前面的数字代表文件夹的优先级，优先级高的会优先被匹配。比如如果我们使用 z e，根据优先级，发现CVE的优先级最高并且含e，所以就会跳到CVE目录下。 平常使用的时候，在任何目录，只要我输入z notes就会跳到PaperNotes目录下，是个非常好用的跳转插件。 ###d plugin d可以显示最近跳转过的目录，然后再输入数字就可以回到最近的目录： 对于在多个目录下工作的情况非常好用。 ##tmux tmux全称是Terminal Multiplexer，作为一个终端复用器可以避免我们开N多个terminal，打开一个tmux就是开了一个session, 关闭session后，下次可以再attach到这个session继续上一次的工作。最大的好处在于ssh时能够继续上次的工作。 tmux里面每一个tag就是一个线程，所以可以开一个tag后开一些阻塞的服务或者虚拟机。tmux本身的分屏也非常方便，滚屏和复制的操作与Vim也十分相似。 ##VIM 最后就是文本编辑器vim啦，在安装的时候推荐直接安装vim-gnome的，或者自己从源码编译，打开+寄存器。vim本身的强大和说明网上已经有很多了，这里分享一下我自己非常喜欢的一些小众的插件。 ###cscope cscope的功能是包含ctags的，它可以建立反向索引，来查找一个函数在哪些地方被调用了，这点对于我的帮助还是很大的:) ###OmniCppComplete 对于进行C和C++开发的程序员来说，这个自动补全要比vim本身的自动补全强大的多，它可以根据tags来补全一个struct的成员。 ###nerdtree or lookupfile 使用nerdtree的小伙伴非常多，毕竟有一个目录树能方便的打开想要打开的文件。不过个人非常推荐lookupfile，这是一个文件模糊查找+自动补全的插件。我想在寻找某个文件的时候更多是：进入mm.c或者进入那个xxxentry.S的情况: 这样寻找的效率个人感觉远高于nerdtree，不过lookupfile也是根据tags进行索引，为了避免太多无关选项需要单独为其建立一个文件名的tags ###FuzzyFinder 模糊查找当前目录文件、tags的插件。 与lookupfile的侧重点不太一样，FuzzyFinder对于搜索的关键词数目没有要求，而且不需要为其单独建立tags，个人感觉比较适合用于一个目录下的多个文件的处理： ###Grep.vim grep的强大是众所周知的，Grep则将这强大与vim进行了结合，使得我们可以直接跳转到相应的文件中。不适用cscope的同学也是用Grep来搜索函数在哪里被调用… Linux中最基本的几个工具就是这些了..一般shell本来就带的ssh这些就不介绍了.. Windows中的小工具更是多到数不清，不过用了这么多目前感觉最好用的其实也就那几个.. ##TreeSize 平常使用TreeSizeFree就够用了，一款查看文件占用情况的小工具，方便我们进行文件的管理。类似于Linux中的df、du 平常自己清理文件的时候经常会用这个小工具。 ##LastActivityView 类似于Linux的日志中的图形版，能够非常清晰而且详细的记录装机到现在的所有动作…其实就是读了系统日志啦.. ##Listary Windows中的搜索神器，不用再嫉妒Bash，不用再忍受Windows本身龟速的搜索啦~ 最最关键的是，平时这东东是隐藏的，在空白处搜索就会自动弹出来，非常好用。而且在Dialog对话窗中，使用Ctrl+G自带的快捷键可以直接让对话框中的目录变成刚才最后一次打开的目录。上传文件再也不用一点点找了.. ##Synctoy 微软自家的同步软件，可以看做是Linux中rsync的图形界面版，增量同步、有Synchronize、Echo、Contribute三种模式。 Synchronize两个文件夹会完全镜像，互为生产者。 Echo类似于备份，生产者的改动会影响备份，但是反过来不会。 Contribute类似于Merge, 将生产者的改动merge到拷贝中。 非常好用的备份同步软件。 每个人都有自己喜欢的一套工具包，本文仅作为记录和推荐。]]></content>
      <tags>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015 回顾]]></title>
    <url>%2Fblog%2F2016%2F01%2F09%2F2015-summary%2F</url>
    <content type="text"><![CDATA[之前就说过要学习大哥经常总结的习惯，然而看到了大哥的总结文后才蓦然想起，自己还没有总结过..于是趁着依旧还算得上16年伊始之际，将过去的2015进行一个小小的总结~ 2015年是我本科毕业的一年，是我从老交大迈入新交大的一年，是我成为研究生的一年。 ###流水账 Jan. 在忐忑不安中等待日语N1的成绩，再继续学没有学完的日语。和导师商量好了软件毕设的题目和日语论文的选题方向。 Feb. 各种聚餐，过年。 Mar. 和好知己去看了大唐芙蓉园的灯盏，确定了日语论文的题目是「弾幕–新たなコミュニケーション形式」并搜集相关的中日参考文献，写框架。 Apr. 日语毕设论文答辩，收集嵌入式操作系统的资料，写Xilinx Zedboard的裸程序代码。母上大人莅临指导，和母上大人游玩西安。 Mar. 移植uCOSIII，一个核用来跑uCOSIII，另一个用来跑测试程序并研究通信机制，最后部署到两个核上 Jun. 毕设答辩，毕业典礼，毕业合影，毕业聚餐 Jul. 在家浪，在家自学新编日语5。不得不说新编日语的阅读文比走遍日本要好的多，走遍日本真不知道是从哪拉的文章，跟自闭症患者写的一样。准备开学的东东。 Aug. 来到IPADS，做JOS Lab, 读一些经典的Paper，熟悉Linux、Vim、Git等之后的大利器。 Sept. 在家浪，继续学新编日语5的课本，回实验室并从Multi-Core转到Security组，开始抱聪聪大哥的大腿。月底去北京听了2015 Internet Security Conference，并转了奥运村、故宫、天坛.. Oct. 装机装了有快半个月，AMD的那台机子的CPU不支持HVM的虚拟化，而一开始并没有想到这个点，以为是Ubuntu的锅，以为是Debian7的锅，Debian装的时候还各种少装grub，少装stand utilities等等。装完Linux装Xen，并写第一个Hypercall。月底去听了GeekPwn的会。还要补学ICS的课，10月就这么一晃就过去了。 Nov. 第一个Hypercall有一些问题，进行修改和完善, 了解Xen大致的启动过程，不过也只停留在表面上，更细节的代码看不懂，搜相关的资料补基础。真是以前欠的早晚都要补回来.. 对XSA进行Survey，期间看了CVE-2015-3636，搭Octopress的这个博客，弄CloudFlare的CND服务，各种测试。 Dec. 筛选要进行复现的XSA, 复现XSA-134, XSA-136, 研究了好久的XSA-152关于Log without rate limiting. 最后只知道防御的机理，但是还是不知道在何种情况下可以进行复现。对应的文章 由于这一块也是最近才开始想要去记录的，所以也没有详细的记录… ###动画 没有非常详细的统计自己看过漫画和动画的时间，追番的总结在这篇。现在的我依旧充满对动漫的热爱。 ###漫画 一个比较大的变化就是15年年初动画漫画的版权正版化，虽然以往收藏的大批漫画都不能再用相应的APP看了，但是正版总是好的。布卡也正式成为了百合漫APP… 火影终于完结，可喜可贺可喜可贺，海贼活力依旧，我又入了妖尾的坑。一直追的信蜂和驱魔少年也完结了，新的一年不知道又有什么好看的漫画╮(╯▽╰)╭ ###游戏 正式弃掉了Clash of Clans，十本满黑墙，送给同学玩了。 玩了几个月的乖离性百万亚瑟王，深感手游坑钱之深，已弃。 体验了天涯明月刀，又是练级，有些无聊。 和4、5个同学在自己搭的MC最高难度生存中玩建造..搭了自己的小村、建了自己的城堡(起初想建7层塔，一层喷泉大厅；二层壁画回廊(和一楼大厅没有天花板)；三层魔法图书馆(中心是附魔台，地面是砖和雪铺的太极)；四层元素神殿，想用金块、木材、玻璃、红石块、土块来代表5元素，金块上方放炼药器)；五层没有围墙，建两座小的塔；六层将双塔之间用桥连起来作为观景台用；七层为金钟(灵感来自海贼空岛的那个金做的钟))，丛然我们有地狱刷怪塔、有刷铁厂和刷石场，但是生存模式原料还是获取非常慢，JJ怪还各种捣乱，最终建到3层结束就停了。地下室有史莱姆养殖场和三个满阶信标，村内有各色动物，也有村民圈养所，还有村内铁路…MC是我非常愉快的一段回忆。 体验了RoboCraft，被各种脑洞所折服。 正式入了炉石的坑，最爱盗贼爆牌贼、环牧和术士。 正式入Steam的坑，买了RWBY的游戏、文明5和饥荒Together。 ###轻小说 作为一个不怎么爱看小说的我一般也不会主动去搜什么小说，接着OVERLOAD的动画化，顺带补完了相关的小说。也在室友的安利下看完了无限恐怖系列.. ###电影 电影是之后要慢慢补的一个项目吧，说实话没有看多少电影，补了生化危机系列、和同学一起去了几次电影院，看来之后要再丰富一些~ 这一年无疑是人生中重要的一年，与高三那一年同样重要。虽然没有了高三的紧张拼搏，没有了高考的形式，但都是我与曾经的自己说再见并进入新环境的一年。 为什么选择了上研？对于一个就业热门的专业来说，就业和上研无孰优孰劣之分。上研不是一种战略的慵懒，不是为了晚一点进入社会的拖延。本科的课程结束后，我只深感自己只是的匮乏，专业能力的不足，我无法想象这样的我能够加入到真正的产品开发中，我想要再学一些。 现在反过来看，似乎也与课程之间的断层有关，每门课程之间没有很好地串起来让我自己感觉欠缺很多，无法将学过的东西进行联系和使用，所以选择了上研。 为什么选择了IPADS？老实说，对于一个不了解科研的学生来说，我没有评价一个实验室或导师实力的尺度。虽然现在看来我幸运地选择了一个极其Nice的实验室；但对于当时的我来说，和抽奖撞运气没什么区别。 老大曾经问过我，在来实验室之前是否知道实验室的氛围和形式。当时连老大都不了解的我又怎可能了解实验室的氛围..加上本校导师给出的充分理由，如果不是因为我这种硬要往外跑的心理作祟，说不定现在依旧是在本校上研。 在保研面试时，面试官看到只做过人机交互、写写网页的简历后推荐的是数媒方向；不过就像我选择上研的原因一样，我最大的动力是对于自己无知的焦虑。所以我毅然选择了系统方向，因为我最不了解系统，也最想了解系统。 夏令营时，志愿者学姐学长说过实验室非常的难进，门槛很高。我还寻思，如果大家都这么想，那报系统的人不就少了…压力反而小，而且其他的方向我又不喜欢…事实也确实如此，我幸运地变成了温馨的实验室的一员。 新的一年应该不会有巨大的变化，希望自己能继续保持活力~]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本科四年]]></title>
    <url>%2Fblog%2F2016%2F01%2F08%2Fgraduation-from-xjtu-text-version%2F</url>
    <content type="text"><![CDATA[昨晚就在思考起个什么酷炫的题目才能够让我这平平静静的四年变得不平静，然而想来想去，也无法从自己以往写过的代码中寻觅出什么像样的灵感，倒是蹦出了动漫里後で考える部(之后再想部)的名字。想想起个这题目也不合适，所以就暂定本科四年好了。写此文以测量一个工科毕业生词汇之匮乏，记录下还残留在我大脑颞叶中的记忆片段。（中二长文慎入) (2015-07-01写的，今天才想起来挪过来) =========================我是分割线============================ 回忆 大学四年印象最深的是什么。毕业典礼上的留学生说起了淘宝和家一般的中国，对于一个住在西安附近的我人文地理的印象仿佛如拂面吹风，吹来的时候还稍觉惊奇，吹走的时候也就那么走了。在一个专业70人左右、女生不到10人、入校时就自带家属的大环境下，又没有什么花前月下池塘边的偎依细语、没有夜黑风高旧校舍的试胆大会、没有秒速五厘樱树旁的前世今缘。这里我不得不说一下，落瓣秒速五厘米、先开花后长叶、小风一吹飘得人醉的那是染井吉野(そめいよしの)，吾校的樱花树是花朵硕大逼牡丹、先长叶后开花、花离枝头做自由落体运动血染樱花道的八重之樱(やえざくら)。而且染井吉野是在三月底四月初盛开，八重樱是在4月中旬才开…所以吾校樱花季在四月中旬orz。——为何我会首先想起这个。 母上大人在大四我即将离校的那年终于做出了一个艰难的决定！花80块买个1小时的高铁，跋山涉水历经九九八十一难终于来到了西安。作为一个孝敬的孩子我自然告诉了我母上如何自己坐地铁导车去宾馆，如何找到城墙入口自己爬。天下哪有我这样信任自己母上能力的！当然我肯定还是要带着母上大人去转转，在玩了一天的兵马俑和华清池，最后晚上我们准备去看大雁塔广场的喷泉。我想我是不会忘了那个特别的夜晚了！那天是2015年的3月28日，是个星期六，号称亚洲最大的音乐喷泉大雁塔广场喷泉在20:30就会给我们来一场震撼人心的表演。天气微微凉，空中飘来的水气给两具疲倦的身体重新注入了灵魂。对了，给你们讲个笑话，每年三月的最后一个星期六是世界节电日，地球熄灯一小时。哈哈哈哈哈哈——出门玩请计划好时间，看夜景不要忘了世界节电日:) 大一的时候，我们的陈院长不停给我们打鸡血、安抚我们这群进入软件学院感觉自己被世界抛弃的小鸟们。作为学校的小学院，录取人数年年不够计划，分数线奇低无比，开学还能立即转进来并且来者不拒，在理学院和人文学院盛享负名的我们都失尽了自信。开心也只有在全校工科都要学习工程制图、三门电路的时候，我们只用看着他们画图、学两门电路的时候开心一下了。但是在毕业的时候，书院20个招生电话19个找我们、连续几年一次就业率直逼100%长期位居第一位时我才明白其实自己的专业还是有那么些优势的。这时我才发现自己喜欢的专业能够有这么好的就业前景实在是幸运之至。——学了软件挺好。 介绍起软件许多人能立即想起来基本上就是修电脑和程序猿，仿佛修电脑、修手机、P图、做视频、做动画、写代码等等都是我们应该会的内容。仿佛软件工程是集自动化、计算科学与技术、电子信息工程、计算机、通信工程、网络工程、微电子、数字媒体艺术之大成的专业。小的我实在不才，再给我10年我再修几个学位后回报社会可好？大学被问过的两个问题是“那电脑坏了你们是不是可以修？” (请先重启下，然后复现错误 :) 软件有问题那是开发公司的锅，找维护人员；硬件有问题那是硬件公司的锅，你给我钱我给你买=v=)；”你们和计算机有什么区别” (你说土木和建筑有什么区别？不过我们的区别更小就是了，毕竟软件工程注重的是工程，计算机科学与技术注重的是科技，理论和实践的关系)。——我不是修电脑刷系统、做动画视频、修图美颜的 :) 在上这个专业的时候，我以为自己是艺术家，大一的话还屁颠屁颠跑到现视研的漫画部研修一年准备培养自己的艺术细胞，亡羊补牢般挽救一下自己那近乎不能挽救的创造力。然而当我学完后我才发现，自己的专业其实是搭积木、和搬砖盖楼房一样，用已有的东西摆出客户自己都不知道那时什么的那海市蜃楼。曾经我以为我是设计狮，外人看来是程序猿，说不定以后还要当个产品狗或者市场销兽，最后结果是个搬砖的码农。对，我要为所有程序员申请农村户口！理想和现实总是有差距，毕业后及时能从事IT行业，又不能保证进研发部分；即使能进研发，真正需要创造力的设计部分依旧不是我们的。不过经过经验的积累，我们或许可能爬到那需要创造力的软件设计师、架构师的位置，那时我们又是否能保持自己当初的热情和创造力呢。——我原来不是艺术家，只是个搬砖的。 大一怀揣理想进了漫画部，后来发现多动症的我静下心来去画画简直是摧残自己的身心，加入了棋牌协会在第一次积分赛连输3把0分送队友超神后黯然退出，进入校十甲社团微软技术俱乐部(Microsoft Student Technological Club MSTC)却在宣传部挂了一年的横幅、彩喷、摆了一年的摊、发了一年的海报(母上大人放心，孩儿已经可以一个人挂起彩喷和横幅了！你看那些技术部门了5、6个人连个小彩喷都挂不起来！又一无用技能get√)，简直是催人泪下的大一生活有没有QAQ，大二又被实验压榨到死，大三说好的课不多却有了实训。大四浑浑噩噩度过了两个学期… 要说在碌碌无为和昏昏沉沉中又做了什么有点价值的事，那就是学了自己喜欢的日语，完成了被同学、亲戚、朋友唾沫淹死的驾照。每个暑假都有实训或者乱七八糟的事情，弄得四年下来暑假没有比寒假长过，看起来忙忙碌碌的四年里却也考过了N1、拿到了驾照、实现了保送、获得了另一个文学学士，也算是没有一直荒废下去，虽说缺少了出国交流的酷炫和爱恨情仇的跌宕╮(╯▽╰)╭。——我还是文学学士，是不是多了一份骚气？ =======================我是分割线=================== 意义 大学到底学了什么，这是所有毕业生都会思考的问题。进入社会投出一份份的简历依旧屡屡被拒，能力达不到单位的要求，本科生一抓一大把，仿佛这四年只是将失业延迟了四年。再回头看看各种心灵鸡汤、各种创业事例，顿时觉得感觉自己的大学上的更没有价值了。高考前的我们都怀揣着进入XXX大学的梦想，考完之后却鲜有实现梦想者，仿佛从进入大学、经历大学、离开大学这整个过程都是不尽人意。——我的本科学了什么？ 妹妹在问我高数和线代的时候，我能记起来的也只有怎么用个L’Hospital法则求个导了，求特征值的时候还要不停翻书去查行列式的性质，多重积分、傅里叶变换已然不知道是什么次元的东西了。大物也是不知道当时怎么就求出了太阳的表面温度(用黑体辐射啥的)，怎么就算出来了热机的效率吖的连50%都到不了，下雨天怎么走淋雨最少etc。学过的大部分东西都离家出走了，不过那些思想现在依然牢牢地成为了我的一部分。我对自己的学习能力又有了更加充分的自信，遇到一门新的编程语言也不会像当初那样打个中文的分号都查半天查不出来错误，看动漫也不再是欧尼酱、雅蠛蝶、奥哈腰(求不要拿中文来音译日文了= =)。高考已然放弃了英语，然而大学对此要求却依旧甚高。入学的我也是Are you ok? Do you like me for 爱，然而当厚厚几本七八百页的专业英文书摆到面前，当考试要求纯英文闭卷答题，当答辩要求日语论述和回答问题的时候，挖不了老本的我们只能尽力去拼去上，这些拼搏过的痕迹已经印刻到了身体里。纵然这么长时间过去了，口语和写作又回到了原点，但是无论什么时候我都知道自己的高度远不止这一点，这些的的确确是四年来的所得——自信。 自己看书是一个很艰辛的过程，有老师讲是如此的舒适，什么都不用想往椅子上一靠，必要的时候动两下笔，不懂的地方随便问。尤其是上日语的时候，满篇不认识的单词语法，老师带着一点点啃过来，顿时觉得自己仿佛也能看懂这么晦涩难懂的文章，整个人都bling bling飘飘欲仙了。然而在写毕业论文做毕业设计的时候，1w字的日语论文，不会的表达自己去查，各种翻译也是极其不靠谱，磕磕绊绊一个月编出来论文后又要赶着做毕业设计，没接触过嵌入式的我照着教程弄完全是Error和Warning，最后快结束的时候板子还十分不争气的坏了，弄完毕业设计后还要编那冗长的2w字毕业论文，都不知道我是怎么用各种扩写完成了这再也不想写第二遍的论文。——解决问题的能力。 很多朋友会说写代码好烦，一个个符号各种乱七八糟的函数云云。其实写代码的时间在软件开发的过程中只占不到10%的时间。在软件遍地的今天，想出一个创意是多么的艰难，想出一个可行性高的创意更是难上加难，每次开会头脑风暴就能疯爆好多人。在获得创意后才是正式进入项目开发，1/3的时间会被用来进行设计，概要设计与详细设计，这期间大部分的时间是在用各种画图软件和纸币中度过的，而且一旦设计有问题之后的返工将是可怕的。1/6的时间是开发时间，开发时间里面如果调试能占一半以下的时间…我只能说大神我跟你学做饭吧！当遇到一个你不知道要花多长时间才能解决掉的bug时，那种对于不可知的恐惧、那种截止时间迫在眉睫的焦虑，调试时却总是一遍遍崩的沮丧……然而噩梦没有结束，接下来的1/3的时间是测试阶段。由于这部分总被我们简化，也使得我们写的软件如陈院长所说“一堆垃圾”一样。最后的1/6则是文档，对，写文档！写谁都不想写，在一个个下一步下一步中被用户看都不屑看一眼然而依旧不得不写的文档。这就是软件开发，也是我大学四年来学到的最重要的东西——专业知识。 院长说过，如果在工作中发生了问题，经过了你却没有解决那么要你何用？对我们的定位是摆一个我们，就应当解决遇到的所有遇到的专业问题，虽然这有点夸张不过寄托了院长对于我们的厚望。为了获得应对各种问题的能力，我们才需要上这四年学，获得自我学习的能力、获得自信、获得面对问题的勇气、获得解决专业领域问题的专业知识、获得在你遇到困难时能帮助你的挚友以及获得乐观的心态。能够多用积极的眼光去看他人、看社会的态度；能够在遇到挫折也敢于挤出无奈微笑的勇气。 ======================我是分割线====================== 经验 到了大学你就可以xxx的话只是高中老师哄我们开心用的，我们也傻傻得信以为真了，因为在那个压得人快喘不过气的时刻如果再看不到什么希望的曙光或许真的会崩溃。(虽然我的高三过的挺轻松) 到了大学依旧会有高数线代、英语大物，各种实验和作业。前两年的早上我们周一早起要升旗，每周要跑两次操盖章，高数为了在200人的教室里获得不错的座位要占座。不要说什么隔夜占座，因为书会被像我这样早起占座的全收起来放到墙角:) 没错，高数课那几次占座书被收起来的不是阿姨，是我:) 。考试前图书馆会坐满人，自习室里充满汗臭却也不得不挤(这里还要感谢我亲爱的舍友们都极其有素质，宿舍一直非常安静适于学习也使我免受复习找教室之苦)。体育跑不过800、1000就会挂科，挂科就会失去转专业、出国、保研、奖学金等一切看起来美好的东西。没有老师催你交作业，可以随便翘课，没有自制能力再没有一个好的环境就会失去很多。——大学不是天堂 大学你可以染发、可以随意穿(图书馆穿拖鞋不能进哦)，你可以通宵畅饮、可以组团开黑、可以来一场说走就走的旅行。这里的理解力和包容力远超社会，你是不是LGBT都无所谓，不会有扰人的上司、做不完的工作，但有物美价廉的住宿、有免费的图书馆资源。你可以遇到各种各样的人，可以参加各种各样的社团活动，最后再来一次纯洁的友情或爱情等等。——大学是自由而幸福的。 不要觉得自己高考是没考好才进来的，因为身边都是一样没考好的。大学中优秀的人才不是凤毛麟角，而是如山一般多，他们的才华和学识又如水一般深。班里成绩最好的同学大一到大二从0基础到日语N2满分N1 165/180，并且一直学习手绘和数码绘、大四还不忘学习钢琴；我的好知己完成了学习完自己的专业外还考到了ACCA的证(28本书14门考试)，大二还组建了一个社团，参加过礼仪、接待过国际友人；有比我小两岁但高我一届的“学姐”，有同样比我小两岁上知天文地理，下拿八门满分，课余组建书院了学业辅导中心帮助他人同届少年……这四年有许多的同学可以过得非凡而精彩，不要止步于CET4、计算机二级、毕业证和学位证，因为完成了这些也只是起点。-—无论什么时候都不要忘了去向往更高更远的那颗追求的心。 说那么多我自己也想有那样的经历啊，完美的大学生活是可遇而不可求的，不走弯路的人生也未免太无味了一些。看到别人的光辉也不能妄自菲薄，毕竟自己肯定有自己能做而别人做不到的事嘛。我个子不高需要自卑嘛？并不需要，因为找对象时因为你个子高可能就会失去我这价值连城幽默风趣积极乐观帅气扑面色气撩人(待我再去搜点褒义词)……的人才=v=。这道题做不出来需要担忧嘛？并不需要，我都不会做的题还有谁能做出来？我5min没做出来那么那些做出来的也肯定花了不少的时间，这些时间我能多赚一些其他的分。阿Q精神虽然不能解决问题但是能带给我们直面问题的勇气，所以未尝不是好事。我自己也一直信奉一句话——自恋总比自卑好。 =========================我是分割线======================== 展望 似乎文章结尾都应该有个总结或者展望啥的，不过软件工程告诉我：变更是常态。需求变更是常态，环境的变化也是常态，如果计划能顺利执行那是异常。如果人生能按计划执行，那是扭曲。所以还是以一个清醒的头脑，怀着乐观的心情，不断学习去解决遇到的各种问题就好啦。能学到自己喜欢的东西那便是好的，能发现所学能派上用场那便是极好的。 纪念度过的四年本科生活。]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本科四年·图片版]]></title>
    <url>%2Fblog%2F2016%2F01%2F08%2Fgraduation-from-xjtu-image-version%2F</url>
    <content type="text"><![CDATA[毕业时写的总结文，今天终于想起来把它给搬过来了..本文是图片版，多图哦 陈院长=v=, 离散数学老师 当时计算机的输入纸带 校园一隅，秋天落叶 MSTC超级大空运来的月饼，一起Happy过中秋 夏末秋初梧桐道，树叶开始掉掉掉 216巴克球组成的小飞碟，娱乐玩具 现役黑岩手办以及没什么卵用的考试专用表 退役的达尔优机械师 一直不知道在说什么的曾老大曾院长，地点是在宿舍楼里的品阁咖啡厅 软院养的喵喵一号，上蹿下跳。喵喵二号是黑色的比较怕生，一般不出来 樱花季的樱花西道 这是基因突变后的变种八重樱！不是染井吉野！八重(やえ)是先长叶子后开花，花朵其大，艳而不雅 这吖的才是染井吉野！！from Baike。染井吉野(そめいよしの)是日剧、动画里面经常见的那种，开花时不长叶子，秒速五厘米的归属者。温柔而雅致。 樱花西道的正常八重樱 不知道哪天抽风举办的真人CS大赛，简直不能直视 毕业生礼物，饮水思源印 现役Filco 圣手二代87键茶轴 大一那晚上断电的年代，小灯就是我们光我们的希望 高数老师张芳老师，纪念高数QAQ 那年那月的高数笔记本 以及线代笔记本 百年难遇的腾飞塔喷泉，而且是没有在养鱼的喷泉。平时一直都有鱼，那鱼腥= = 大一在努力挽救自己艺术细胞的时期 不知是东花园还是西花园附近的牡丹 不知是东花园还是西花园附近的牡丹No.2 运动会加油助威！二级扩音器 某节可怜的思修课 挽救艺术细胞时期的手工作。退役的雪初音纸手办]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015 追番总结]]></title>
    <url>%2Fblog%2F2016%2F01%2F08%2F2015-acg-summary%2F</url>
    <content type="text"><![CDATA[16年的一月新番已然开始更新，于是就想回顾一下2015年自己看过的动漫, 要不然总感觉看过后什么都没有留下有点白看的感觉.. 顺便作为推荐给朋友的参考~(长文) 介绍的动画都是基本上看完的(动画弃的小说或漫画是看过的)，并且是以追番的形式看的。带有极强的个人主观意见，不喜轻喷 1月番, 4月番, 7月番, 10月番 ##2015 1月番 艦隊Collection-Diomedéa 作为游戏改的舰队Collection赢得一片叫好，然而BD的销量却是惨淡。一方面想要还原历史，强行送葬如月引得一片游戏粉的不满，发现销量暴跌后立即修改剧本带来的突兀最终也得罪了历史党们。这番看看舰娘妹子们就可以了，并没有什么印象深刻的地方╮(╯▽╰)╭ Death Parade-MADHOUSE 这部由13年“动画未来计划”《死亡台球》改编的动画还是挺让我喜欢的，Nano(诺娜)这一智慧而理性的妹子也是深得我的喜爱。不过，最后留在我印象中最深的还是它的片头曲《Flyers》，听了两遍后根本停不下来的魔性，让我之后一直忘不了这部动漫。内容是一个半死不活的妹子带给“仲裁者”们变革最终心满意足死去的故事（大雾)，对于物语系有偏爱的小伙伴可以尝试~ 东京喰种√A-Studio Pierrot 漫画的剧情还是很不错的，不过第二季动画制作实在是过于拙劣，对于赫子的描画实在是过于粗糙，而漫画里根本看不懂的打斗动作场面在动画里不是幻灯片就是过家家质量，喜欢漫画的就别看了.. 看完倒是再一次被香菜配的铃木小天使给折服，病态的声音果然棒棒哒。 暗杀教室-Lerche 说真的，暗杀教室属于非常正能量的作品，通过将血腥暴力温和化，剧情也十分的鼓舞人心和充满温情，只是因为主角定位涉及到恐怖主义(猜测)就被封了╮(╯▽╰)╭。第二季是今年1月新番，人气依旧非常高。剧情主要讲述一堆小朋友想吃章鱼丸子最终变成章鱼儿子的故事=v=，日常笑点还算可以，不过我不太喜欢这类的，所以后面也就不追了。 新妹魔王契约者-Production IMS 卖肉后宫番，强行兄妹，强行青梅竹马，并没有什么价值，弃即可。 路人女主的养成方法/冴えない彼女の育て方-A-1 Pictures A-1的动画我一般都还挺喜欢的，虽然有后宫倾向，不过对于角色的塑造还是有可取之处的。冴えない这个词也是看完这部动漫后才记住。讲述的是 高级本子画师青梅竹马+高级编剧黑长直学姐+音乐达人表姐+非常萌的普通妹子和废柴男主一起做Galgame的故事。看点在于学姐的卖萌以及真·女主的日常吐槽。剧情比较温馨，喜欢日常的可以看~ 无头骑士异闻录-Brain’s Base, 7月也有 剧情依旧是绝赞，原小说作者成田良悟之前就有一部类似风格的作品《永生之酒》就夺得了我的喜爱，作为群像剧，每个人和每个人之间都有着复杂的关系，非常佩服作者对于人物关系和剧情发展的控制把握能力。赛姐也是更萌了，强烈推荐这一系列的~~ 元气少女结缘神-TMS Entertainment 作为一部逆后宫的番，帅气的男主巴卫和围绕平凡女主的不平凡日常正好符合了花季少女的幻想~ (不要吐槽我为什么看逆后宫，我是杂食动物:) )。相信每一个女生都会期待着那个心目中的白马王子(狐狸)在危险之时降临身边保护自己。标准的王子形象也确实可以获得少女们的喜爱╮(╯▽╰)╭ Aldnoah Zero-A-1 Picture 强调一下，这部的编剧已然不是老虚了！不过梶浦由记和泽野弘之的配乐就足以成为看这部动漫的理由！虽然核爆神曲的演唱者不是小林让我有点小小的心塞意外，其他各方面都属于制作良心的动漫。剧情公主和赞成派的贵族在一起的结局也更加合理，没有强行让男女主在一起或者强行让男主Game Over。该漫讲述了成为一个学霸就可以开挂、撩妹最后可以获得和其他男人在一起目送心爱的女神和别人在一起的成就的故事:), 虽然对于资源扩张、好战派和和平派、歧视等进行描绘的同类作品不少，还是非常推荐这部~ 物语系列-SHAFT 最爱的短片系列没有之一，物语系列是我感觉人物关系最微妙的动漫了，每个人都有其存在的理由和意义，新房对于人物心理的描绘也极其到位，每次看物语都仿佛能看到人物的心理。全篇没有路人、新方式45°和幻灯片的描绘也着实让我非常喜爱。任务的角色定位和特点非常鲜明。 铳皇无尽的法夫纳-Diomedéa 没什么营养的后宫番.. ##2015 4月番 食戟之灵-J.C.STAFF 节操社的色情美食番，不过看起来确实还挺热血的，听听各种呻吟也是别有一番风味，属于杀时间的美食番，不适合晚上观看╮(╯▽╰)╭，和男主一路打Boss最后成为最强Boss的剧情别无二致，杀杀时间就好。 伪恋-SHAFT 伪恋已然不想追了，虽然是一部后宫番，不过也没有刻意的卖肉卖傻，加之男主黑帮的设定使得剧情在一开始的时候还是充满嚼劲的。不过后面新妹子的不断加入以及男主一到关键时刻就智商下线以及强行情商下线的设定让后面的剧情一直处于相似的循环之中。在日常描绘的不断加重下，仿佛一开始那寻找钥匙的主线已经变得不再那么重要，这也就使得剧情越往后越无味，中评一个吧。 山田君和7人的魔女-LIDENFILMS 剧情的亮点在于各种魔女能力带来的搞笑日常，推荐没看过的小伙伴们去看日剧而非动画，在真人的演绎能够扩大片子带给人的喜剧效果。而动画本身日常的设定和正义热血无脑的男主设定使得我不是非常喜欢这部片子，漫画的剧情在后面也有强行拖得嫌疑。(我受不了男主只靠满口的正义和满腔的热血就能抱得美人归这类过于理想化的设定，同样不喜那种不断将对手变为自己人的设定orz) 我的青春恋爱物语果然有问题-Brain’s Base 依旧是推荐的动画之一，推荐的原因在于其另类的人际关系与处事手段。虽然直到最后我都没搞懂男主追求的真物到底是什么，不过毕竟男主也不知道所以观众不知道也是理所当然╮(╯▽╰)╭，不过那苦苦探寻的姿态，和观念的冲突确实描绘的非常不错。校园生活类，剧情不落俗套，给个好评~ Fate/Stay Night Unlimited Blade Works-Unfotable 本年度制作最好的动画没有之一，不过由于是必定能够盈利的动画，所以这么大手笔的投入也是情理之中。虽然相比较老虚执笔的Fate/Zero，一开始作为Galgame剧情的FSN稍显逊色，不过这依旧无法抵挡其高质量良心作的光辉，无论是动画、画风、特效还是音乐，都可见工作室的用心。对于吾王的忠实粉丝们来说，不看是人？ 吹响吧！上低音号/響け!ユホフォニアム-京都动画 当看到小说的插画和动画的角色设定后，感动的都要哭了，小说的那个丑啊。。。对于女孩的心理描写一直都是京都的强项，以交响乐引领剧情向前，把两个女主之间的点滴故事描绘的细致入微。即使是对百合无感也可以爱上这部番，作画与配乐都非常良心。一直很佩服京都如何把日常能描绘的跌宕起伏，把平凡的少女描绘的如此光彩夺目… 终结的炽天使-WIT STUDIO 一部好好番，被玩过之后变成了年度崩坏最严重的番，追求漫画剧情的就不用看了，想要找乐子的就来看看这部崩坏搞笑番吧，完全没有战场的凄惨与悲壮，全程吐槽欢乐无比。看过吐槽就再也无法直视的动画…描绘的是一个人类和一个吸血鬼的爱恨情仇，两个都是男的:)。(动画改的非常的烂) 灰色的迷宫/乐园-8-bi Galgame的剧情还是不错的，不过动画就…游戏改，尤其是的Gal改的动画一向不看好，剧情节奏过快新观众不知所云，游戏党怨声载道。 关于完全听不懂老公在说什么的事-SEVEN 原作本来是作者基于现实生活在P站上的一系列图，后来就火了。。很多人一直会吐槽为什么名字这么别扭，由于日语的谓词在最后，前面旦那が何を言っているか作为宾语，后面加个听不懂：わからない最后再来个 件(相关事情)作为结束使得中文翻译不得不非常别扭。。非常推荐！尽管是泡面番，但是可以看到现实中的宅和日常生活还是非常治愈和开心的！(男主的伪娘弟弟也非常有趣) 之后干了个爽的出处:)(後滅茶苦茶セックスした) 血界战线-BONES 一向良心的骨头社又一次良心的制作？不过我并不能接受这个画风，所以没有很看好这部动画..然而它的粉丝就是那么多，其OP的销量甚至进入了日本动画音乐历史上的TOP50，作为一部15年才出的歌曲销量，能PK过众多经过长时间售卖的其他歌曲实属不易。剧情有点无厘头，钉宫配的绝望王也是比较赞，不过剧情..只能说热血，画风..我不敢说精美。。 灵感!RE-KAN!-Pierrot Plus 四格漫画改变而来，看漫画的时候还是觉得挺有意思的，不过看动画的时候怎么感觉就那么无聊呢= =一部描绘幽灵和女主的欢乐日常的动画，不过不知道是因为过于平淡还是过于日常，使得片子不能很好地Catch到观众..看不下去成了最大的问题。 可塑性记忆/PLASTIC MEMORIES-动画工房 动画工房的动画我一直都挺喜欢，不过不知道为什么销量一直都不高orz。一部讲述人机之恋的原创动画，萌点在于女主艾拉的Error(日语エラera)以及和男主的日常。其实就是部虐狗番，虽然最后男主也被虐了，不过看看温馨的剧情，看着最后女主幸福的微笑，傻笑的自己仿佛也会感觉幸福起来。有兴趣的小伙伴还是可以看看的~ 御神乐学园组曲-动画工房 由Vocaloid歌曲系列改变，动画由于崩坏过于严重，所以看得时候有点目不忍视。战斗热血类却欠缺欠缺足够的铺垫和描绘；百合类又夹杂太多其他不必要的成分，可以作为一个无脑欢乐番来看，Time Killer一枚。 ##2015 7月番 Charlotte-P.A.Works 我吖的到现在都不知道为什么Key社的作品那么火，Clannad确实不错，不过Little Buster、Angel Beats！我完全不觉得好看啊= =，剧情的不一致，强行托节奏的日常，以及莫名其妙的催泪弹让我有一种不知道发生了什么，他们都非常感动的样子。Charlotte作为麻枝准大魔王反驳说Angel Beats坏话(即我这类人)的作品，想要为其正名。然而我看完依旧觉得：魔王大人，咱回家好好作曲别出来用剧情侮辱智商了好么？ 女主的塑造是成功的，然而剧情无论内容或是节奏的安排上都无疑是失败的，相比较命运石之门这类科学番、未来日记这种悬疑番(就定为悬疑吧)的时空跳跃，Charlotte时空穿越却又漏洞百出，男主前期日常建立起来的人际关系后期半毛钱关系都没有，从铺垫来说智商200实战智商-200的表现来看，实在不能算作一部佳作。然而人家人气就是那么高，又有什么办法╮(╯▽╰)╭ 没有黄段子的无聊世界/下ネタという概念が存在しない退屈な世界-J.C.STAFF 节操社又一部无节操的动画，推荐给无节操的小伙伴们。看到没有黄段子时就能知道这片有多没节操了。。。除了SOX教与被水淹没不知所措的梗以外，剧情对于无节操梗的大把使用瞬间让我以外自己还听有节操的:) 监狱学院-J.C.STAFF 好叭，又是节操社。这番没被禁真是神奇，深圳某公司就是叼叼的← ←。剧情依旧非常没节操，在女校中尊严尽失的男生们的监狱生活…然而…看起来真TM热血！这就是这部番的魅力所在，用各种不忍直视的方法来维护那仅有的尊严！两学生会的勾心斗角、男女生之间的关系变化都是本作看点~ 干物妹小埋-动画工房 卖萌番,妹控福音。在动画出来之前我就在追漫画了，不过真心没想到动画会引起这么大的反响，看来动画工房能再活一阵了。萌点在于在外和在内极大反差的妹妹小埋，以及能让观众说出“国家欠我一个这样的哥哥”的温柔哥哥。喜欢萌妹妹的可以看，还是挺有意思的日常番。 OVERLOAD-MADHOUSE 看过男主笑着装B没看过男主哭着装B，自己要装的B跪着也要装完的番。男主为了面子不得不装B的游戏题材类动画。由于属下们的绝对忠诚和崇拜，各种强行找台阶下的男主也是够拼的。对喜欢将自己进行代入的男生们推荐该番，毕竟满级去刷新手村，不爽才怪:) 乱步奇谭-Lerche 剧情物语向，由于一开始带着推理的帽子使得喜欢推理的观众大跌眼镜，期望与实际的不符是这部的败笔之一。但是重新作为剧情或物语类来看的话，就会发现它的魅力。通过一个个故事来反应一些极端的心理和现象，画男硬说女的女主，对原作剧情的不成功修改使得本番只能算作一部失败的改编。 赤发白雪姬-BONES 虐狗番，有霸道总裁的影子，不过男主不霸道就是了；带有一些玛丽苏的成分，满足了少女们的幻想，也是传递正能量的动画吧..在双11自己一个人看口味更佳。 魔法少女伊莉雅-SILVER LINK 喜欢伊莉雅的一定会喜欢这部动画，Fate中一个个高冷的女主们在这部番里都成为了萌神一般的存在，剧情的百合战斗向也迎合了宅男的口味，加之Fate本身的高人气，本作的成功也在情理之中。萝莉控们的福音，各种福利(¯﹃¯)，我这种百合控也能赚到便宜实在不错~ 六花的勇者-Passione 冒险类动画，不过剧情略微无聊，毕竟在这部番中，冒险是次要，勾心斗角与撩妹才是主线:)，永远都会有一个多余的人来引起猜忌，剧情固定的模式使其后继无力，也不可能成为一部出彩的作品了。 那就是声优-GONZO 很想推荐这部，对于我个人来说，描绘日本动画业界的动画都能带给我许多我感兴趣的信息。14年的《白箱》也非常的成功，苦于程序猿们没有表达的方式，要不然真的好想能出一部描绘程序猿生活的动画，相信也能引起极大的共鸣。声优之于日本少年少女如偶像之于韩国少年少女，我们能看到的都是声优们赋予角色灵魂后的成果却难窥那其中的竞争与汗水。 越是对于一个领域的无知越是会激发我的求知，所以这部讲述声优生活的动画也自然进入了我的推荐列表之中。(每集ED都不同、每集都请一个大牌声优来客串也是不错) 青春x机关枪-Brain 说实话有点无聊，虽然漫画我追到最新了= =，亮点或许在于女扮男装的女主？加上(玩具)枪战这一衬托，人物心理的变化更加具体和细致，喜欢帅气的男孩子(雾)的可以看看..中评一个 GANGSTA/黑街/匪徒-Manglobe 本季度最推荐的动画，剧情和画风都太赞、不再是完美的男主或女主，更接近真实的人物性格，独特的故事背景使得该番立即就脱颖而出。由于一些过激镜头使得该番被禁播，不过依旧十分推荐。许久不见的硬派风格动画，黑手党枪战与黄昏人种的打斗使得这番能给麻木的我来带许久未体验到的惊喜与刺激。 ##2015 10月番 《终物语》在物语系列里说过了，就略过啦；《终结的炽天使》也追了，不过画风依旧略过；《学战都市Asterisk》与《落第骑士英雄传》这雷同的剧情和废柴开挂组后宫的设定也实在是提不起我的兴趣。 野良神-BONES 其实是骨头社的良心作，算是日常与冒险番，男主虽为厄神却想成为福神，男主与其他神明之间的各种故事以及和女主、爱刀(雾)的温馨日常都是看点。剧情还是很不错的，原作的漫画也属于良心的冒险类漫画。不过没有很推荐的原因也是因为其没有突出的亮点，没有能够吸引我的特质在其中。 K Return of Kings-GoHands 声优不要钱，经费燃烧的K硬生生的用画质、音乐和强大的声优阵容掩盖了剧情的单薄，说实话没有什么令人拍手叫绝的剧情或者让人眼前一亮的设定，打斗的过分绚丽浮华使得本作成为了一个漂亮的花瓶。王之间的战斗就是干瞪眼，属下们的战斗对于王来说如以卵击石，王和眷属们过大的实力差使得王之力不能服务于动画整体的剧情。所以只能作为画画或动作制作的参考，而不能成为剧情或叙事的蓝本。 高校星歌剧-C-Station 不得不说如果LoveLive出了男生版可能真就这种样子了，由于舞蹈本身的美感与男生给人的阳刚相性不好使得跳舞的男生们有一种伪娘的氛围。。一部偶像励志番就凄惨的变成了一部搞笑番也是令人比较无奈，女性向的定位却不走壁咚帅B路线使得动画整体看上去不伦不类。不过听歌的话，歌曲确实还是不错的。。。 樱子小姐的脚下埋着尸体-TROYCA 带有推理成分的剧情番，男女主的感情描绘还算可以，但是剧情的深度不够。解决事件的剧情在之后不能发挥更大的作用，而本身不属于叙事物语类。女主的智慧是过人的，加上孤僻的性格，这一反差本来可以获得比较好的反响，但是作为其心灵支柱而塑造出来的弟弟形象却没有很好的发挥其应有的作用。最终观众可能在一个个并不跌宕起伏的案件中失去继续看下去的兴致。 全部成为F-A-1 Pictures 推荐的作品之一，本身作为推理类对于推理的剧情设计还算可以，虽然剧情有些拖沓冗长，但是男女主教授与学生的设定以及作品本身反射出来的哲学思维能够掩盖其他的缺点。不过想要反映哲学的动画一般都无法迎合大众的口味，这使得作品可能无法成为一部商业上的成功作品。对于自由的追求以及对于爱的另类诠释、对女主高智商精神分裂者的描绘都是我喜爱这部动画的原因。 瓦尔基里Drive-Arms 都可以说里番了..没什么营养的百合番，TimeKiller 绯弹的亚里亚AA-动画工房 与后宫向的本传《绯弹的亚里亚》不同，百合番的AA由于没有了令人止不住吐槽的男主能力设定后，萌妹子之前的温馨刀枪日常还是比较不错的。百合控们可以瞅瞅。 #结语 之前看过一个文章，结论是喜欢玩电脑的孩子比喜欢看电视的孩子更加聪明，原因是电视的信息更多的是被动接受的，大脑的思考太少。 看动画的过程我认为也同样，虽然对于我来说也有复习日语的作用，不过感觉如果不能够对看过的内容进行一些自己的总结和思考，那么动画也就只是消遣了。刚好Blog已经建立，那么以后就加入对于动画的一些感悟吧~]]></content>
      <tags>
        <tag>ACG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xen Log 4-Log without Rate Limiting]]></title>
    <url>%2Fblog%2F2016%2F01%2F08%2Fxen-log-4-log-limit%2F</url>
    <content type="text"><![CDATA[#Xen Log without limiting(2016-01-04) In many XSAs (43, 96, 118, 141, 146, 152 and 169 till now), The unlimited logging will cause a DoS attack in Hypervisor. The prinkt is not rate limited and detailed info is recorded in lwn : http://lwn.net/Articles/66091/ Printk is log unlimited. If the log message is sent to console and the hypervisor vill have to spend all of its time to scrolling the console frame buffer (Try sudo apt-get install and list all possible results). ###Question about XSA In xen, (XEN/xen/common/xenoprof.c) xenoprof.c12345678910111213141516ret_t do_xenoprof_op(int op, XEN_GUEST_HANDLE_PARAM(void) arg)&#123; int ret = 0; if ( (op &lt; 0) || (op &gt; XENOPROF_last_op) ) &#123; printk("xenoprof: invalid operation %d for domain %d\n", op, current-&gt;domain-&gt;domain_id); return -EINVAL; &#125; if ( !NONPRIV_OP(op) &amp;&amp; (current-&gt;domain != xenoprof_primary_profiler) ) &#123; printk("xenoprof: dom %d denied privileged operation %d\n", current-&gt;domain-&gt;domain_id, op); return -EPERM; &#125; do_xenoprof_op is hypercall 31, which can be triggered by DomU. So DomU can cause a DoS of hypervisor. ###Solution in Xen Thus, in xen, they proposed log level. Usually, this can be config in grub command line: In /etc/default/grub 1GRUB_CMDLINE_XEN="loglvl=all guest_loglvl=all console=vga" You can set console to tty0 comN to see the log from start up of dom0. Of course you can also set memory and cpu of dom0 here such as: 1GRUB_CMDLINE_XEN_DEFAULT="dom0_max_vcpus=4 dom0_vcpus_pin maxmem=512" to pin dom0 to pcpu 1-4 and limit its memory to 512M etc. You can refer to Full Xen Hypervisor Command Line Options If you have seen the patch of XSA-152 etc, you will find that they replace printk with gdprintk. gdprintk is defined in XEN/xen/include/xen/config.h 123456#define dprintk(_l, _f, _a...) \ printk(_l "%s:%d: " _f, __FILE__ , __LINE__ , ## _a )#define gdprintk(_l, _f, _a...) \ printk(XENLOG_GUEST _l "%s:%d:%pv " _f, __FILE__, \ __LINE__, current, ## _a ) PS: __LINE__ and __FILE__ is predefined macro which can show line nubmer and file name. There are some Standard Predefined Macros in GCC, You can see the full definition. XENLOG_GUEST is a macro #define XENLOG_GUEST &quot;&lt;G&gt;&quot;, and current is a macro can get current vCPU. It seems that this macro didn’t add any rate limitation in printk. So, I send email to the discoverer Jan Beulich of SUSE. Although this is not a good way :) and I am criticized for sending such a private e-mail and less effort on this question :(. Normally, you can seed email to xen-devel@lists.xen.org :). You can see the full mailing-list descripton here. The fact is in XEN/xen/drivers/char/console.c , hypervisor will set threshold for these logs. 1234567891011#ifdef NDEBUG#define XENLOG_UPPER_THRESHOLD 2 /* Do not print INFO and DEBUG */#define XENLOG_LOWER_THRESHOLD 2 /* Always print ERR and WARNING */#define XENLOG_GUEST_UPPER_THRESHOLD 2 /* Do not print INFO and DEBUG */#define XENLOG_GUEST_LOWER_THRESHOLD 0 /* Rate-limit ERR and WARNING */#else#define XENLOG_UPPER_THRESHOLD 4 /* Do not discard anything */#define XENLOG_LOWER_THRESHOLD 4 /* Print everything */#define XENLOG_GUEST_UPPER_THRESHOLD 4 /* Do not discard anything */#define XENLOG_GUEST_LOWER_THRESHOLD 4 /* Print everything */#endif The comments said that : 123456789101112/* The XENLOG_DEFAULT is the default given to printks that * do not have any print level associated with them. *//* * &lt;lvl&gt; := none|error|warning|info|debug|all * loglvl=&lt;lvl_print_always&gt;[/&lt;lvl_print_ratelimit&gt;] * &lt;lvl_print_always&gt;: log level which is always printed * &lt;lvl_print_rlimit&gt;: log level which is rate-limit printed * Similar definitions for guest_loglvl, but applies to guest tracing. * Defaults: loglvl=warning ; guest_loglvl=none/warning */ And in the description of guest_loglvl and loglvl in docs of commind line shows that Any log message with equal more more importance will be printed. , So this option will change the threshold. Here, we know that why the patch for XSA-152 (replace printk with gdprintk) works. Because it add &lt;G&gt; to identify it as guest log, in printk_prefix_check this will add thresh hold to the guest log info. So normally, If we want log info are log unlimited, we can just set UPPER equal to LOWER threshold. NoteI have tried to use an infinite loop to call hypercall 31 (do_xenoprof_op) with wrong log message in order to trigger hypervisor to continuously log info, but it cant cause DoS or limitaion manchanism of hypervisor. Now this is problem I am digging. Anyone knows the answer please contact me via my email or just in comments in this page. Thanks.]]></content>
      <tags>
        <tag>virtualization</tag>
        <tag>CVE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Symbol与Pointer、Array与Function]]></title>
    <url>%2Fblog%2F2015%2F12%2F23%2Fpointer-and-function%2F</url>
    <content type="text"><![CDATA[在上一篇Summary里面已经提到过Array、Function与Pointer了。里面都是标准的语法，理解上也没有什么有问题的地方。本篇则讨论不知是编译器or链接器出于人性考虑进行优化还是什么的引起的一些语义和语法上的不一致。 Function &amp; Pointer详细看过第一篇的博客后，对于Function Pointer的语法理解应该没什么问题了： 12345int fun_o()&#123; printf("Hello Alice\n");&#125;int (*fun)() = fun_o; 上面代码申请了一个function pointer fun 指向了 fun_o 所以我们现在可以直接通过fun来调用fun_o()(*fun)()会输出”Hello Alice” 但是机智的小伙伴可能已经发现： 123456789101112int fun_o()&#123; printf("Hello Alice\n");&#125;int (*fun)() = fun_o;int main()&#123; fun(); (*fun)();&#125; 这fun()和(*fun)()竟然输出一样！！！ fun()直接就可以当做函数来用…好像编译器自己帮我们解引用(Derefer)了fun这个指针。 没有找到正规的文档，也没看编译器源码，不过事实好像确实如此:) 也就是说，编译器会自动把函数指针给解引用使其使用起来就像普通函数一样 现在看看另一个例子 1234567891011121314151617181920212223/* main.c */extern void fun();int main()&#123; printf("Main: %x\n", main); fun(); return 0;&#125;/* fun.c */extern int main;void fun()&#123; printf("Fun: %x\n", main);&#125;/* shell */gcc -m32 -o a.out main.c fun.c./a.out 会发现printf打出来的结果不一样！！！ 在main()中打印出来的main是函数的地址(我的结果是80483fb),而fun中打印出来的main是4244c8d。 查看汇编后发现： 发现fun()打印的是main的第一条指令lea 0x4(%esp), %ecx,对应的编码是8d 4c 24 04，刚好按小端打印出来后就是04244c8d。 printf(%x,var);的语义按道理说，只是把变量里的值打出来，由于在fun.c中，main是int，指向了0x80483fb，里面的内容就是8d 4c 24 04，所以这个打印没有任何问题。但是打印main的时候，语义明显发生了变化。所以我们可以发现：编译器会自动把打印的函数给取地址。 当把fun.c里面的extern int main; 换成 extern int (*main)(); 此时打印的内容，fun()中输出的依旧是4244c8d。 把extern int(*main)()再换成extern int *main，打印出来的结果依旧是4244c8d。 也就是说，如果是变量，那么printf(%x,var);的语义是没有变化的，都是将变量的内容取出来并打印，只有在处理函数的时候，会自动取地址。 #Array &amp; Pointer 在上一篇中同样还提到了Array 和 Pointer的不同，当时的一个例子是优化的问题，编译器对于二维数组会进行优化，而对于二维指针却不会，这次我们来看语义上的不同。 数组在内存中的存在形式与函数十分类似。我们如果申请了数组int Arr[3] = {1, 2, 3};，在内存中的存储方式也是1,2,3连续存数，不会有一个变量Arr,然后Arr再指向数组这样的情况。 现在有下面的代码： 123456789101112131415161718192021/* main.c */extern void fun();int Arr[3] = &#123;1, 2, 3&#125;;int main()&#123; printf("Main: %d\n", Arr[1]); fun(); return 0;&#125;/* fun.c */extern int *Arr;void fun()&#123; printf("Fun: %d\n", Arr[1]);&#125; 编译链接后，当执行这段代码的时候，main中会输出2，fun中会发生segmentation fault。 也就是说，平时我们使用的 int *p = Arr这样的情况，编译器会自动对Arr取地址，并把Arr的地址存到p中。因此代码中以下这两种是一样的： 1234567891011int Arr[3] = &#123;1, 2, 3&#125;;/* Following expressions are same !*/int *p1 = Arr;int *p2 = &amp;Arr;int main()&#123; printf("%d, %d\n", p1[1], p2[1]); return 0;&#125; 输出的结果也都是2。而直接把int *p的p当做和Arr一样的话就会出问题:) 而对于p[1]这种表达，编译器又会自动把p给解引用，取出数组地址进行运算 所以在第一个例子中，由于fun中把Arr当做指针，会自动解引用，取出Arr中的内容01 00 00 00后小端表示，等于0x1 进行[1]的运算：对0x1 + 1后访问0x00000002这个地址，所以发生segmentation fault。 #Conclusion 编译器在处理数组或函数时，会进行一些语义的转换，或许是为了保持形式的一致(p[1]与Arr[1], fun()与fun_o()),或许是考虑到不会有人想要函数的第一个指令byte…，所以在理解的时候需要注意一下这里:)。这是在学习链接的时候额外发现的问题~ 也再一次感谢实验室的各位大大们。]]></content>
      <tags>
        <tag>note</tag>
        <tag>programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xen Log 3-Add New Hypercall to Xen]]></title>
    <url>%2Fblog%2F2015%2F12%2F13%2Fxen-log-3-add-hypercall%2F</url>
    <content type="text"><![CDATA[首先第一步便是给Xen中添加新的Hypercall, Hypercall、Hypervisor与GuestVM的关系与Systemcall、OS与Process的关系类似，如果GuestVM想要执行一些特权行为(如请求硬件)那么就要使用hypercall，控制权会转交给hypervisor，当hypervisor完成相关操作时会将控制权再交回GuestVM。 Debug 系列: Add New Hypercall to Xen Debug Xen on Physical Machine Xentrace Debug Key 可以参考Chang Hyun Park的此文中添加Hypercall到hvm的描述。 修改Xen文件假定XEN为xen源码的顶级目录，我的是xen-4.4.3 修改hvm.c 在 XEN/xen/arch/x86/hvm/hvm.c中 查找hvm_hypercall64_table, hvm_hypercall32_table, 并添加自己的hypercall： 我添加了两个，本例以alice_op为例。 添加HYPERCALL(your hypercall name)，使用的hvm-ubuntu是32位的，不过为了64位的也能使用，两个表都添加上了。 修改entry.S 在XEN/xen/arch/x86/x86_64/entry.S中查找 ENTRY(hypercall_table)，并添加自己的hypercall.(均以do开头) 39号本身是给用户预留的，如果要添加多个顺次增加。 之后，在下面的hypercall_args_table添加参数项 其中.byte后的数字表示有几个参数。为了简便，do_alice_op我们就不使用参数。 PS:如果Xen是在32位机子上的，则修改的是XEN/xen/arch/x86/x86_32/entry.S 修改hypercall.h 在XEN/xen/include/xen/hypercall.h or XEN/xen/include/asm/hypercall.h(如果有架构依赖)中添加自己的hypercall声明: (我放到asm/hypercall.h中了) 添加hypercall number到xen.h 在XEN/xen/include/public/xen.h中添加自己的hypercall 号: 注释掉xc_reserved_op 添加hypercall实现 hypercall如果是共用的功能，实现可以放到XEN/xen/common/kernel.c，与某些功能相关的话可以放到任何在XEN/xen/arch/x86/目录下的文件中，因为我之后要进行memory相关的学习，所以就放到XEN/arch/x86/mm.c里面了 #重新编译xen make xen -j8 并安装 make install-xen -j8，之后重启后，现在就可以调用hypercall了 由于hypercall只能在内核态进行调用，所以可以放到systemcall中或者编译为kernel module在进行加载时调用；xen本身也提供了使用privcmd的工具能够来调用hypercall。下面使用hypercall和kernel module两种方式进行实现。 #Privcmd privcmd.c123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;linux/types.h&gt;#include &lt;fcntl.h&gt;#include &lt;xenctrl.h&gt;#include &lt;xen/sys/privcmd.h&gt;#include &lt;string.h&gt;int main()&#123; int fd, ret; char * message; privcmd_hypercall_t alice_op=&#123; __HYPERVISOR_alice_op, &#123;0,0,0,0,0&#125; &#125;; fd = open("/proc/xen/privcmd", O_RDWR); if(fd&lt;0)&#123; perror("can't open /proc/xen/privcmd"); exit(1); &#125; else &#123; printf("privcmd's fd = %d\n", fd); &#125; ret = ioctl(fd, IOCTL_PRIVCMD_HYPERCALL, &amp;alice_op); printf("ret = %d\n", ret);&#125; 使用gcc -o test test.c进行编译后sudo ./test 使用sudo xl dm查看日志后，也可以看到hypercall被调用的日志 #Kernel Module ###在Debian中使用Kernel Module方式 现在的Linux中已经有对于Xen的支持，所以在源码文件中是有xen.h这一文件的。这次我们修改Kernel Header文件来简化Kernel Module的编写。 在linux-src-dir/xen/interface/xen.h中添加自己的hypercall声明 linux-src-dir在debian上是在/usr/src中，其他的系统自己可以找一下。 之后在 linux-src-dir/arch/x86/include/asm/xen/hypercall.h中添加我们hypercall的声明。 (别人的图，忘截了)接下来就可以着手编写kernel module啦： hypercall_ko_debian.csource1234567891011121314151617181920#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;xen/interface/xen.h&gt;#include &lt;asm/xen/hypercall.h&gt;static int init_hypercall(void)&#123; HYPERVISOR_alice_op(); printk("Hello Alice\n"); return 0;&#125;static void exit_hypercall(void)&#123; &#125;module_init(init_hypercall);module_exit(exit_hypercall);MODULE_LICENSE("GPL"); 需要注意的是，需要在最后加上MODULE_LICENSE(“GPL”)，否则有些lib不能使用就会报错。 相应的makefile: Makefilesource123456obj-m += hypercall_ko_debian.oall: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modulesclean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean 现在就可以调用hypercall了~ Note 如果使用System Call来实现的话，需要修改内核源码。 Kernel Module的编程可以参考《Linux Kernel Module Programming Guide》 Peter Jay Salzman, Michael Burian, Ori Pomerantz Change Log Add Debug series (2017-05-11) Delete ubuntu-example (2016-12-26) Ubuntu 的那个Kernel Module是用别人的，写的不是很简洁，而且不推荐在Module内再自己重新写Hypercall的相关操作等，所以就去掉了。]]></content>
      <tags>
        <tag>tutorial</tag>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xen Log 2-Build HVM DomainU]]></title>
    <url>%2Fblog%2F2015%2F11%2F29%2Fxen-log-2-build-hvm-domain%2F</url>
    <content type="text"><![CDATA[经过上一篇的步骤之后，Xen已经运行并且将原来的OS作为Domain0启动了起来。在文章末尾提到过HVM与PV，本篇会使用建立一个硬盘镜像并安装Ubuntu14.04，最后以HVM启动。 可以参考这里，这是通过克隆自己的host OS来作为Guest Domain的。不过我弄完后磁盘配置好像出了点问题，因此就重新安装一个ubuntu来使用。 ###创建硬盘镜像 创建一个10G左右的磁盘镜像： dd if=/dev/zero of=xen-ubuntu.img bs=1024k seek=10240 count=0 跳过10240M 左右的空间，基本上可以建立一个10G的磁盘镜像。 创建文件系统： mkfs -t ext3 xen-ubuntu.img ###创建虚拟机的配置文件： 配置文件的详细语法见XL Configure File Syntax hvm的配置文件(hvm-ubuntu.cfg)如下： hvm-ubuntu.cfgsource123456name=&quot;hvm-ubuntu&quot;builder = &apos;hvm&apos;vcpus = 1memory = 512disk=[&apos;file:/home/alice/Xen/Img/xen-ubuntu.img,hda,w&apos;, &apos;file:/home/alice/Xen/ISO/ubuntu14.iso,hdc:cdrom,r&apos;]boot=&quot;dc&quot; 详细的配置文件见附件(附件中boot顺序已经改为从disk启动)，根据自己的配置进行修改。 ###启动GuestVM 12sudo xl create hvm-ubuntu.cfgvncviewer localhost:0 vncviewer 可以观看我们的虚拟机，如果开启多个，则为localhost:1, localhost:2 ... 正常安装，之后修改配置文件为从硬盘启动即可 使用xl list查看，可以发现hvm-ubuntu已经启动： Network如果要为Guest配置网络的话可以使用网桥, Ubuntu的可以直接参考: http://ask.xmodulo.com/configure-linux-bridge-network-manager-ubuntu.html Debian默认用的是bridge-utils, Ubuntu的话也可以先安装下, 之后在配置文件里面加一下，最后重启网络服务就行。 123456789101112sudo apt-get install bridge-utils# Add config to /etc/network/interfacesauto xenbr0iface xenbr0 inet dhcp bridge_ports eth0# Comment original eth0 and restart networking servicesudo service networking restart# Now we can add network config for our guest in cfg file,add vif=["bridgename"] (see the source) Misc开机如果因为找一个module需要大量1Min30s的话，可以取消它的开机自动probe: 12nano /etc/modprobe.d/blacklist.confblacklist i2c-piix4 ChangeLog 2017-05-07: Add bridge in Ubuntu]]></content>
      <tags>
        <tag>tutorial</tag>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xen Log 1-Running Xen]]></title>
    <url>%2Fblog%2F2015%2F11%2F28%2Fxen-log-1-running-xen%2F</url>
    <content type="text"><![CDATA[之后的一段时间里面将会围绕Xen开展工作，所以这一系列博客就记录一下学习的过程和问题。本篇介绍如何从源码编译并运行Xen。主要部分都是从大哥那里现学现卖的:) 原文地址 官网教程也介绍的比较详细。 相关书籍里面介绍了许多相关的书能帮助学习和开发。 #直接安装 据说很简单 123sudo aptitude -P install xen-linux-systemsudo dpkg-divert --divert /etc/grub.d/08_linux_xen --rename /etc/grub.d/20_linux_xensudo update-grub # regenerate the /boot/grub/grub.cfg file #从源码编译 遇到什么问题的话可以参考官网指导 1234567891011$ sudo aptitude build-dep xen$ git clone git://xenbits.xen.org/xen.git$ cd xen$ ./configure$ make xen$ make tools$ sudo make install-xen$ sudo make install-tools$ sudo dpkg-divert --divert /etc/grub.d/08_linux_xen --rename /etc/grub.d/20_linux_xen$ sudo update-grub 安装完成以后，在/boot 下会有xen.*.gz的镜像 xen-4.4.3.gz是我安装的xen的镜像(我使用的是4.4.3版本) vmlinuz-3.16.0-4-amd64 是Domain0的镜像 initrd.img-3.16.0-4-amd64 是initrd(initial ram disk) 启动选项(Optional) /boot/grub/grub.cfg会有 with xen的启动选项： grub.cfg 是根据/etc/default/grub生成的， 如果需要修改启动顺序的话，可以在/etc/default/grub中进行修改，查看一下想要默认启动的项是第几个(从0开始)，在grub中将set default=n设置为需要的即可。 也可以直接下面的命令修改 1sudo dpkg-divert --divert /etc/grub.d/08_linux_xen --rename /etc/grub.d/20_linux_xen 这里数字越小优先级越高。 完成后使用 sudo update-grub来更新grub，就可以将其设为默认启动 启动服务 重启后，默认情况下服务时没有开启的，手动开启: 12sudo service xendomains startsudo service xencommons start or restart 或者 12sudo ./etc/init.d/xendomains startsudo ./etc/init.d/xencommons start / restart 如果之后让它自动加载这两个服务的话: 12sudo update-rc.d xencommons defaults 19 18sudo update-rc.d xendomains defaults 21 20 重启后 使用$ sudo xl list 可以看到当前运行的虚拟机，而原本的系统会以Domain0启动 至此，已经成功将Xen跑了起来 如果显示缺少lib 使用ldconfig命令刷新链接 之后重启xen的相关服务 接下来就可以启动虚拟机了，使用的还是xl的工具，同时准备好相应的iso镜像。 关于虚拟化，有两个概念：半虚拟化(para-virtualization)以及全虚拟化(full virtualization)详细的可以参考： The Paravirtualization Spectrum, part 1: The Ends of the Spectrum The Paravirtualization Spectrum, Part 2: From poles to a spectrum 这部分不在讨论范围，具体的可以参考我师兄的blog(原文那里) Note从CD启动虚拟机：官网指导 如何启动DomainU：How to Do 问题在安装过程中可能遇到以下问题： 在Debian启动时卡到界面上进不去 这种要安装Linux-firmware-nonfree，原因是少了nonfree firmware里的显卡相关驱动 全虚拟化模式下启动客户端虚拟机发生重启: 可以查看下/proc/cpuinfo里面是不是有vmx或svm的flag，只有CPU支持vmx(Intel)/svm(AMD)的才能使用全虚拟化。如果CPU不支持，或者BIOS里没打开的话是不行的 ###找不到依赖 Unable to find xgettext: sudo aptitude install gettext Unable to find as86: sudo aptitude install bcc Unable to find iasl: sudo aptitude install iasl Unable to find yawl: sudo aptitude install libyajl-dev sudo aptitude install libpixman-1.dev Unable to find pixman-1: sudo aptitude install libpixman-1.dev cdefs.h not found: (or compile x86 program on x64) sudo apt-get install gcc-multilib sudo apt-get install g++-multilib zlib.h not found sudo apt-get install zlib1g-dev openssl/md5.h not found sudo apt-get install libssl-dev uuid.h not found sudo apt-get install uuid-dev -lncurses not found sudo apt-get install libtool sudo apt-get install lib32ncurses5-dev Python.h not found sudo apt-get install python-dev glib2.12 required to compile qemu 参考glib，不用配置，直接安装，之后再安装这些： make stubdom sudo make install-xen sudo make install-tools PYTHON_PREFIX_ARG= sudo make install-stubdom [standards.info] error 1 sudo apt-get install texinfo yacc not found sudo apt-get install byacc flex fig2dev not found sudo apt-get install transfig Unable to find a suitable curses library sudo aptitude install libncurses5-dev glib.h install libgtk2.0-dev ChangeLog 2017-05-03: Add update-rc.d]]></content>
      <tags>
        <tag>tutorial</tag>
        <tag>virtualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在x64linux下编译Qemu]]></title>
    <url>%2Fblog%2F2015%2F11%2F23%2Fcompile-qemu-in-linux-x86%2F</url>
    <content type="text"><![CDATA[做JOS实验的时候，因为想在真机上跑Qemu来做，而自己的机子是Ubuntu x64的，目标应用是x86的，当时编译的时候还遇到了一些问题，这里做个记录:) 本文参考了：https://community.gns3.com/community/forum/blog/2014/12/24/how-to-compile-qemu-220-in-ubuntu-64bit First install Qemu dependencies for Ubuntu sudo apt-get install build-essential gcc pkg-config glib-2.0 libglib2.0-dev libsdl1.2-dev libaio-dev libcap-dev libattr1-dev libpixman-1-dev install other dependencies sudo apt-get build-dep qemu then download latest Qemu source files from Download - QEMU wget http://wiki.qemu-project.org/download/qemu-2.2.0.tar.bz2 // Change the version of qemu to get latest one extract it sudo tar -xvjf qemu-2.2.0.tar.bz2 go to extracted folder cd qemu-2.2.0/ compile it for 64bit (if you want 32 bit too add this ‘,i386-softmmu’) sudo ./configure --target-list=x86_64-softmmu (for additional platform type ./configure --help) sudo make sudo make install ##Note KVM is enable by default ,you can add –enable-kvm option in ./configure , like the following sudo ./configure –target-list=x86_64-softmmu –enable-kvm if you want to build with NETMAP do as following first install git sudo apt-get install git then download and install NETMAP source code (we need that source code location for building NETMAP) , I want to download NETMAP source in my /opt/ directory cd /opt/ then download NETMAP by git sudo git clone https://code.google.com/p/netmap/ cd netmap cd LINUX sudo ./configure --no-drivers=virtio_net.c sudo make sudo make install then we must give sys folder location in netmap , (/opt/netmap/sys) to ./configure ,with –extra-cflags=-I option , like the following sudo ./configure --target-list=x86_64-softmmu --enable-kvm --enable-netmap --extra-cflags=-I/opt/netmap/sys you will see enable netmap=yes and enable kvm =yes after configure then sudo make -j4 sudo make install]]></content>
      <tags>
        <tag>tutorial</tag>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Calling Convention&Function Pointer]]></title>
    <url>%2Fblog%2F2015%2F11%2F17%2Fcalling-convention-fun-pointer%2F</url>
    <content type="text"><![CDATA[这一年因为工作原因得以跟着本科生一起学习ICS(Introduction to Computer Systems), ICS原本好像是CMU的课：https://www.cs.cmu.edu/~213/, 本校的主页：http://ipads.se.sjtu.edu.cn/courses/ics/。内容基本上涵盖了我本科时期操作系统、计算机组成与x86汇编的大部分内容，而且由于是一门课，所以很好的把这些内容都串了起来，我也有幸能再次学习和温习一下专业的基础知识。这一系列博文主要总结这次学习中的新的收获和以混淆的点，用来温习和回顾。 这次总结函数调用的 Calling Convention和C语言的Function Pointer, 本来还想加上Round to Even 和 x86与x86-64种struct, union对齐的，不过因为扯了C#的事件和委托机制，导致内容有点多，就放到下一篇好了。 #Calling Convention 函数调用过程中Registers需要进行保存和恢复，有一些约定来表明哪些寄存器由Caller保存，哪些由Callee保存，编译器会以这种约定来进行编译。约定与ABI(Application Binary Interface)有关 ###ARM 在ARM中(From AAPCS $5.1.1), 这里不记录浮点寄存器。 r0-r3 are the arguments and scratch registers; r0-r3(a1-a4) 传递arg1-4 r0-r1 are also the result registers r0, r1也用于返回值 r4-r8 are callee-save registers r4-r8(v1-v5)用来存放变量的值 r9 might be a callee-save register or not (on some variants of AAPCS it is a special register) v6/sb(static base),v6就是存放第6个变量，Static Base in PID,/re-entrant/shared-library variants r10-r11 are callee-save registers r10: v7/sl(stack limit)，在检查栈的限长时使用 r11: v8/fp(ARM-state frame pointer), 用来存放帧指针，类似于EBP的作用 r12-r15 are special registers r12:ip (Intra-Procedure-call scratch register) new-sb in inter-link-unit calls. Used by compiler code generators as a local code generator temporary register r13:sp (Stack Pointer)，类似于ESP的作用 r14:lr (Link Regiser), scratch register, 用来存放return address r15:pc (Program Counter) ###Microsoft x64 Software Conventions From Register Usage MSDN Volatile (Caller-saved) RAX: return value RCX: 1st arg RDX: 2nd arg R8: 3rd arg R9: 4th arg R10, R11: used in syscall/sysret instructions Nonvolatile (Callee-saved) R12:R15, RDI, RSI, RBX RBP: 可能作为frame pointer使用 RSP: stack pointer ###AMD64 From System V.application binary interface amd64 architecture processor supplement Caller-save %rax: 1st return reg; tmp reg %rcx: 4th arg %rdx: 3rd arg %rsi: 2nd arg %rdi: 1st arg %r8: 5th arg %r9: 6th arg %r10: tmp reg; passing function’s static chain pointer(听老大说是函数嵌套时使用) %r11: tmp reg Callee-save %r12-%r15 %rbx: 有时用作基址指针(Base Pointer) %rsp: stack pointer %rbp: 有时用作帧指针 其他寄存器可以参考给出的各个链接或手册 x86的Calling Convention比较简单，就不列出来了。 #Pointer and Array 首先看看指针和数组声明： Pointer & Array12345int a[]; // 1D(imension) Arrayint a[][]; // 2D Arrayint *p; // 1L(evel) Pointer p point to intint **p; // 2L Pointer p point to int * 这是平常会用到的指针和数组的声明，但是int[]和int ** 实际上是不同的。 比如说下面的声明： Pointer & Array 212int *a[]; // Pointersint (*a)[]; // Pointer a point to an array 第一个是许多的指针，比如我们可以一个含有3个指针的数组： 1int *a[] = &#123;NULL, (int*)0x80000000, NULL&#125;; 第二个是指向数组的指针，我们可以声明一个指向数组a地址的指针p: 12345int a[] = &#123;233, 123&#125;int (*p)[] = &amp;a;// (*p)[0] is 233// (*p)[1] is 123 其实总结一下，下面四种声明方式我们都可以当做二级指针来操作： 1234int a[][];int ** a;int *a[];int (*a)[]; 之所以会产生这样的区别，在语法上是因为[]的优先级比*高，所以在*a外加不加括号会有区别。而对于编译器，如果是int a[][] 在嵌套循环的时候会进行优化，因为每一行所占的空间是已知的，所以就可以声明行指针与列指针。比如下面的函数在使用-O2优化的时候，就会变成下面的样子。 Optimization of Embedded Loop1234567891011121314151617181920212223242526272829// Original Functionvoid transpose(Marray_t A)&#123; int i, j; for ( i = 0; i &lt; M; i++ ) for ( j = 0; j &lt; i; j++ ) &#123; int t = A[i][j]; A[i][j] = A[j][i]; A[j][i] = t; &#125;&#125;// Optimized Functionvoid transpose_opt(Marray_t A)&#123; int i, j; for ( i = 0; i &lt; M; i++ ) &#123; int *Arow = &amp;A[i][0]; // 第i行的第一个元素的地址 int *Acol = &amp;A[0][i]; // 第0行的第i个元素的地址 for ( j = 0; j &lt; i; j++ ) &#123; int t1 = *Acol; // 下面Acol += M会把Acol变成第j行的第i个元素 int t2 = Arow[j]; // 第i行的第j个元素 *Acol = t2; Arow[j] = t1; Acol += M; // 等于是 &amp;A[0 + j*M][i]，把Acol变成第j行的第i个元素 &#125; &#125;&#125; 由于数组是有边界的，所以这种优化才得以实现。但是在二维指针的情况下就不行了:) #Function Pointer 首先看一组声明： Declaration123456789int a; // Integerint a[10]; // Integer Arrayint *a; // Integer Pointerint *a[10]; // Integer Pointers(array)int a(); // Function Declaration(return int)int* a(); // Function Declaration(return int*)int (*a)() // Function Pointer(return int)int (*a[10])() // Function Pointers(all return int)int* (*a[10])() // Function Pointers(all return int*) 在记忆的时候，只要记住函数指针的声明需要将*与变量名括起来即可，记忆的形式可以参考普通的指针数组。 以下内容并没有实际使用的意义，点我跳过 现在我们把前面的数组和指针也放到函数指针数组里面，看看下面的声明:) 1234567891011121314151617181920212223242526272829303132333435int cons = 1;int * pcons = &amp;cons;int acons[] = &#123;1&#125;;int* (*a[10])(int, int*) // Function Pointers (All return int*, args:int, int*) use it ↓pcons = (*a[n])(cons, pcons);int a(int, int*, int[])[];// Funtion a, return int array. use it as ↓cons = a(cons, pcons, acons)[0];acons = a(cons, pcons, acons);int (* fun(int))[];// Function declaration, return pointer pointing to int array, use ↓int (*p)[] = fun(cons);acons = *fun(cons);cons = (*fun(cons))[0];int* (* fun(int))[];// Function declaration, return pointer pointing to int* array, use ↓pcons = (* fun(int))[0];int *(*(*apfun[2])(int[], int*, int))[];// Function Pointers, each pointer is a function that // get int[], int*, int as args,// return a pointer which points to an array// The array consists of int* (pointers pointing to int)// We can use this one like this:cons = *(*(*apfun[2])(acons, pcons, cons))[0];pcons = (*(*apfun[2])(acons, pcons, cons))[0]; 看到这里，想必感觉非常蛋疼，简直是非人类啊。其实里面有个原因是C语言中数组是不能用来赋值的，所以不能出现这种情况： 12int Array[] = &#123;1,2,3&#125;;int a[] = Array; // Wrong 那么想把数组弄过来怎么办呢？ 于是自然想到传递 &amp;Array,这样就可以声明一个指向数组的指针就好了：↓ 12345int Array[] = &#123;1,2,3&#125;;int (*pa)[] = Array;//(*pa)[0] = 1;//(*pa)[1] = 2; 这样就可以实现数组的传递，当然更简单的方法还是 int *p = Array。所以一般也没人抽风这么用 在记忆的时候，使用和声明的形式是一致的，所以可以通过使用来理解声明的含义。 #Usage of Function Pointer(s) 那么来看看C语言中函数指针的用法： function pointer1234567891011121314151617181920212223242526272829303132333435363738394041/* Suppose number 1-4 represent cheap food * 5+ represent delicious food * less than or equal to 0 means no food */int EatFood(int i)&#123; if (i &gt; 0) return 666; else return -1;&#125;int JudgeFood(int i)&#123; if (i &lt;= 0) return -1; else if (i &lt; 5) return 60; else return 100;&#125;struct People_t &#123; char *strName; int (*eat)(int);&#125;;int main()&#123; /* Initialization */ struct People_t customer = &#123; “Alice”, EatFood &#125; struct People_t gourmet = &#123; “Ming”, JudgeFood &#125; customer.eat(1); /* return 666 */ gourmet.eat(4); /* return 60 */ return 0;&#125; 这种形式就非常像面向对象编程了，所以在C语言里面可以通过使用函数指针来达到OO(Object Oriented)编程的目的。 那么再看看函数指针数组的使用： Function Pointers Array123456789101112131415161718/* Add another defination Food Provider*/struct Provider_t &#123; int (*gave[2])(int);&#125; provider;void Register(struct Provider_t *p1, struct People_t *p2, int index)&#123; p1-&gt;gave[index] = p2-&gt;eat;&#125;int main() &#123; Register(&amp;provider, &amp;customer, 0); Register(&amp;provider, &amp;gourmet, 1); provider.gave[0](10); provider.gave[1](10);&#125; Register表明有人向Provider注册信息，要求provider提供食物给他们。对于Provider来说，他只用关心有多少人注册了，等到有新货来的时候就给所有注册者分发食物。 而具体的注册者会根据自己的函数定义实现不同的行为。 如果写过C#的delegate的话，会发现有点相似点，事件的发起人会获得接受者的函数指针，并在出现时间时调用这些函数。 不过真正的delegate不但可以引用静态函数，还可以引用非静态成员函数(C语言因为没有成员所以也不存在这种函数);delegate是面向对象、类型安全的。由于C本身并不是面向对象语言，而且也不存在class这种东西，所以他们的区别还是非常好理解的。而刚才介绍的C函数指针的用法实际上也是为了借鉴OO编程的思想而已。 现在看看C#中Delegate的用法： Delegate Example1123456789101112131415161718192021public class DelegateTest &#123; // 声明delegate对象 public delegate void AliceDelegate(int a, int b); // 实际执行的函数 public static void AliceDo(int a, int b) &#123; Console.WriteLine((a+b).ToString()+&quot;Alice do something&quot;); &#125; public static void Main() &#123; // 创建delegate对象： AliceDelegate ad = // 这里传进去AliceDo的函数地址 new AliceDelegate(DelegateTest.AliceDo); // 执行ad, 通过ad实际上执行的是AliceDo函数 ad(1,2); &#125;&#125; 是不是觉得和函数指针的感觉很像？ Delegate Example2123456789101112131415161718192021public delegate void AliceDelegate(int i);public class Program&#123; public static void Main() &#123; // 创建delegate ReceiveAliceDelegateArgsFunc(new AliceDelegate(AliceDo)); &#125; public static void ReceiveAliceDelegateArgsFunc(AliceDelegate func) &#123; func(666); &#125; // 实际执行的函数 public static void AliceDo(int i) &#123; System.Console.WriteLine(&quot;Get A: &#123;0&#125;&quot;, i); &#125;&#125; 当要发出一个消息的时候，ReceiveAliceDelegateArgsFunc就会被执行，它会调用拿到的delegate，而delegate实际上代表的函数AliceDo则是在new AliceDelegate(AliceDo)的时候传给AliceDelegate的。 delegate支持+=，可以将许多函数交给这个委托，这一点就和函数指针数组很像了。 .Net中的event事件其实也是一种具有特殊签名的delegate，因为实际在实现的时候如果真的是发送了一些消息给接受者，那只有当接受者被激活或者被调度器调度到的时候才能知道自己收到了一个消息，这样就无法立即响应这个消息。所以在实现的时候还是需要由消息的发起者主动去调用这些函数。 来看看OnClick的实现： OnClick12345678910111213141516171819202122232425262728293031323334353637public class ButtonClickArgs : EventArgs&#123; // 参数可以由我们定义，获得Clicker的信息 public string Clicker;&#125;public class AliceButton&#123; // 定义一个委托 public delegate void ClickHandler(object sender, ButtonClickArgs e); // 定义事件，类型就是上面的委托 public event ClickHandler OnClick; public void Click() &#123; // 触发Click事件，传入Clicker信息 OnClick(this, new ButtonClickArgs() &#123; Clicker = &quot;Alice&quot; &#125;); &#125;&#125;public class Program&#123; public static void Main() &#123; AliceButton btn = new AliceButton(); // 注册事件， 把btn_OnClick压入事件队列 // 这里btn_OnClick就是实际执行的函数 btn.OnClick += new AliceButton.ClickHandler(btn_OnClick); &#125; public static void btn_OnClick(object sender, ButtonClickArgs e) &#123; Console.WriteLine(&quot;Alice be clicked&quot;); &#125;&#125; 在Program执行过程中，我们点击了AliceButton，这时就触发了btn里的Click()函数 在Click()函数中，调用了OnClick并传入sender和Arg OnClick是个事件，而其本身类型是ClickHandler委托类型的事件。所以OnClick可以看做一个函数指针变量(类型为ClickHandler的这种类型)。 而在Program中，通过注册事件: btn.Onclick += new AliceButton.ClickHander(btn_OnClick) 可以看做声明了一个函数指针(类型为ClickHandler的这种类型)，并把这个函数指针赋给event Onclick。 ClickHandler这种类型就是返回值为void，参数为object和ButtonClickArgs的函数类型 所以调用btn.OnClick的时候，等于就调用了btn_OnClick()这一实际执行的函数。 我想现在应该能理解函数指针和C#中的event了吧。关于event的说明，参考了这篇博文]]></content>
      <tags>
        <tag>note</tag>
        <tag>programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在英文版Debian/Ubuntu中添加中文拼音(双拼)输入法]]></title>
    <url>%2Fblog%2F2015%2F11%2F16%2Fadd-chinese-in-english-debian%2F</url>
    <content type="text"><![CDATA[Although for most time english is enough, we have to input some chinese when browse some chinese sites.This post will show how to add chinese input method in Debian(english version). #Chinese Support add chinese locales support: 1sudo dpkg-reconfigure locales Add zh_CN GB2312, zh_CN_GBK, zh_CN.UTF-8 but still set default locale as en_US.UTF-8 This step can be manually configured in /etc/locale.gen install fonts sudo aptitude install fonts-arphic-uming xfonts-intl-chinese xfonts-wqy #Fcitx Input Method install fcitx and fcitx-pinyin sudo aptitude install fcitx fcitx-pinyin install im-config to config the input method sudo aptitude install im-config config the input method to fcitx use im-config, then choose fcitx restart the xwindows with sudo startx Add shuangpin or pinyin in Input Method use fcitx-configuretool to add shuangpin and pinyin Problemsometimes, we can’t add pinyin or shuangpin in english environment. Just set system’s Region and Language as chinese. (Language Support on Ubuntu) In chinese environment, use fcitx-configuretool to add shuangpin or pinyin in Input Method (I think system will not found pinyin in eng environment). Then change system language back to english. Now you can just use chineseinput in english debian. #Supplement To use Wubi or Google Pinyin etc, you have to add these input method like sudo aptitude intall fcitx-googlepinyin. As I am used to use MS shuangpin schema. To change it, use fcitx-configtool and configure shuangpin schema to MS:]]></content>
      <tags>
        <tag>tutorial</tag>
        <tag>linux</tag>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用SSH通过代理连接Git]]></title>
    <url>%2Fblog%2F2015%2F11%2F14%2Fgit-ssh-proxy%2F</url>
    <content type="text"><![CDATA[假设现在有3台计算机： A (IP_A), B1(IP_B1), B2(IP_B2)， B1与B2是在同一内网下，B1是该内网的网关，对外拥有独立IP。 最终目标是在A1使用ssh以网关B1为跳板连接到B2上进行工作。 #B2 ssh B1 在工作或者实验室经常会有这种场景，需要ssh到服务器上进行一些操作。 ssh UserOnB1@IP_B1 //即可 拷贝的话使用： scp ~/xxx UserOnB1@IP_B1:~/xxx //第一个~是B2上的用户主目录，第二个~是UserOnB1在B1上的主目录 ###密钥 ssh可以使用密钥认证，省去输入密码的麻烦 ssh-keygen -C &quot;xxx&quot; -t rsa -C : Comment 是为了标记这个密钥对是属于哪个用户的，邮箱即可 -t 加密方式为rsa 生成完后，在~/.ssh下会有新建的id_rsa.pub 与id_rsa 将id_rsa.pub的内容追加到 IP_B1: ~/.ssh/authorized_keys中即可： scp .ssh/id_rsa.pub UserOnB1@IP_B1: ~/.ssh/ #将公钥拷贝到B1上 ssh UserOnB1@IP_B1 #登录B1 cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys #将公钥内容加入authorized_keys rm -f ~/.ssh/id_rsa.pub #删除公钥文件 这样之后在B2上使用用户 UserOnB1来连接B1时就不用输入密码了。 ###多密钥配置 如果连接不同的host需要使用不同的密钥时，就不能只用默认的id_rsa了 在.ssh下建立config文件，并进行配置： 假设登陆B1使用的密钥文件名为 B1_rsa：↓ host B1 // B1在本地的名称 user UserOnB1 // 登陆B1使用的用户 hostname IP_B1 // B1的主机名或者IP port 22 // 使用的端口 identityfile ~/.ssh/B1_rsa //使用的密钥 这样就可以使用B1_rsa来登录B1了 ssh B1 #因为我们加了user选项，所以直接 ssh host就行了 比较常用的就是本地登陆Github时使用专门的密钥：↓ host github.com // 本地的名称 user git // 用来登陆的用户名 hostname github.com // 用来登陆的机子IP或名称 port 22 // 使用的端口号 identityfile ~/.ssh/github_rsa // 指定使用的密钥文件 使用↓来连接git ssh github.com 类似的，如果不加user选项，那么在连接的时候需要使用↓ ssh git@github.com ###B1作为跳板，从A登陆IP_B2 经常会有在家里需要登陆公司、实验室的机子，外网连不到内网的B2上，此时可以将B1作为跳板来连接到B2上 ↓ (操作是在A上) ssh UserOnB1@IP_B1 #连到B1上 # 连接到B1后，在B1的shell中： ssh UserOnB2@IP_B2 #从B1连到B2上 或者，直接使用代理命令： ssh UserOnB2@IP_B2 -p22 -o &quot;ProxyCommand ssh UserOnB1@IP_B1 exec nc %h %p 2&gt;/dev/null&quot; username2@IP2 # nc (natcat) %p : port, %h : hostname 相应的，可以在A的.ssh/config进行如下配置↓ host B1 port 22 hostname IP_B1 identityfile ~/.ssh/B1_rsa #Host B2↓ host B2 port 22 hostname IP_B2 ProxyCommand ssh UserOnB1@B1 exec nc %h %p 2&gt;/dev/null #上面这条Command会使用 前面B1配置的内容，使用B1_rsa进行连接。 完成后在A上登陆B2↓ ssh UserOnB2@B2 ssh会在config中找到B2 host，并采用proxycommand连接B1，而command中的命令，又会使用host B1并使用B1_rsa来连接。 同样，如果不想输入密码的话，那么在A的.ssh/config中，在host B2下也加入identityfile：↓ host B1 port 22 hostname IP_B1 identityfile ~/.ssh/B1_rsa #Host B2↓ host B2 port 22 hostname IP_B2 identityfile ~/.ssh/B2_rsa ProxyCommand ssh UserOnB1@B1 exec nc %h %p 2&gt;/dev/null 在B2的authorized_keys里加入B2_rsa.pub 最后就可以在A1上，输入↓ ssh UserOnB2@B2 便可以直接通过B1连接到B2了 #GitHub与GitCafe GitHub: 在个人Profile-&gt;左侧导航栏SSH Keys-&gt;Add SSH Key 复制git_rsa.pub里的内容进去即可 GitCafe Profile-&gt;Setting-&gt;SSH Keys-&gt;Add a new public key中操作相同 在本地配置config： .ssh/config123456789host github.com hostname github.com port 22 identityfile ~/.ssh/github_rsa host gitcafe.com hostname gitcafe.com port 22 identityfile ~/.ssh/gitcafe_rsa 之后运行↓来改为使用ssh方式登录 git remote set-url origin user@host:UsernameOnGit/xxx.git # 如果config中有user, 则这里user@可以省略。 可以使用↓来验证一下： ssh -T git@github.com ssh -T git@gitcafe.com 之后再进行pull、push等操作时就可以使用ssh的方式了。]]></content>
      <tags>
        <tag>tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Octopress博客(4)-基础操作]]></title>
    <url>%2Fblog%2F2015%2F11%2F14%2Foctopress-basic%2F</url>
    <content type="text"><![CDATA[博客已经能够正常访问了，本篇主要介绍一下Octopress的基本操作，关于基本操作官网有更详细的，这里只简单进行必要的总结~ #Configuration 配置文件一共有4个： _config.yml # 关于Jekyll的配置文件，也是主要是用的配置文件 Rakefile # 有关部署的配置文件 config.rb # 有关文件路径的配置文件 config.ru # 有关出错处理的配置文件 在前面的文章中，我们已经修改了Rakefile以实现同时部署gitcafe和github，其他的内容一般也涉及不到。config.rb与config.ru使用默认的路径就可以，所以我们主要修改的是_config.yml文件。这里只说一下一般会用到的配置： _config.yml123456789101112131415161718192021222324252627282930313233#网站的链接，自己没有域名的话就是http://username.github.iourl: http://silentming.net # 博客的名字title: SilentMing&apos;s Blog# 副本题(名字下面的小字)subtitle: xxxxx# 作者，用来写在footer里或者license里面的author: SilentMing# 网站内搜索使用的引擎# Google的话，搜索时会加上site:url keyword# Baidu的还没研究simple_search: https://www.google.com/search# 描述description: this is a xxx blog# RSS订阅subscribe_rss: /atom.xmlsubscribe_email: # 邮箱email: yumingwu233@gmail.com# 中间是在blog页面显示多少文章等# 之后是侧边栏的定制：default_asides: [asides/about.html, asides/xxx.html]# 后面是Github等内置的侧边栏或分享的系统配置# 如果在上面敲上自己的账户名的话，它会自己拉取公开信息并显示 #Post and Site 在bash or terminal中： 1234567new_post["name of post"] # 创建新的post# 创建markdown site,访问用 url/sitename/new_site["sitename"] # 会在source/sitename/下创建index.markdown# 创建普通site, 如果不是index.html则访问为 url/dir/site.htmlnew_site["dir/site.html"] # 会在source/dir/创建site.html #Img and Code 由于markdown本身支持内嵌html，所以嵌入图片可以使用： 1234567&lt;img src="path/to/img" title="title" alt="xxx"&gt;&lt;!-- 也可以使用Octopress提供的更简单方法 --&gt;&#123;% img [class name] /path/to/img [width] [heigh] [title] [alt] %&#125;&lt;!-- 如果想嵌入gist代码的话，可以直接使用：--&gt;&#123; % gist gist_id [filename] % &#125; 嵌入代码的更多内容可以参考官网文档 如果使用的是默认模板和配置的话，以上的操作已经够用，自己只需要在*.html或*.markdown上写内容就好。 #Misc Markdown的教程推荐Daring Fireball，对应的中文版本是http://www.appinn.com/markdown/ Git的教程推荐官网教程，有配图说明且十分详细, 也可以生成电子书下载！]]></content>
      <tags>
        <tag>tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Octopress博客(3)-同时部署管理GitCafe和GitHub与CDN加速]]></title>
    <url>%2Fblog%2F2015%2F11%2F13%2Fmanage-octopress-deployment%2F</url>
    <content type="text"><![CDATA[#Introduction 在上一篇中我们已经能够成功应用自己的域名，但是会发现github对于国内的用户访问好像比较慢，而gitcafe对于国外的用户又没有github好，因此本篇将说明如何同时部署博客到github和gitcafe，以及调整域名管理让国内的用户访问gitcafe，国外的用户访问github。最后介绍一个CDN(Content Delivery Network)服务来加速博客的访问。 #Preparation Gitcafe 注册Gitcafe账号，并仿照Github建立repository (gitcafe里repository是username，不需要加gitcafe.io)。 Cloudflare Cloudflare是一个CDN服务提供商，它能将你的网站的CSS、img、js缓存到世界各地的服务器中，当用户访问时便可以用最近的缓存来加载网页提升访问速度，个人使用的话可以使用它的免费计划。 我们先注册个账号:) #Deploy on gitcafe 进入octopress目录： 123cd _deploygit remote add gitcafe git@gitcafe.com:SilentAlice/silentalice.gitgit push -u gitcafe master:gitcafe-pages Gitcafe的Page只能发布到gitcafe-pages分支上，所以git push -u gitcafe(设定upstream为gitcafe) master:gitcafe-pages(将本地的master分支推送到remote的gitcafe-pages上)。之后博客也就被部署到了gitcafe上。 如果觉得手动比较麻烦的话，修改octopress/Rakefile, 123456789101112131415Rake::Task[:copydot].invoke(public_dir, deploy_dir)puts "\n## Copying #&#123;public_dir&#125; to #&#123;deploy_dir&#125;"cp_r "#&#123;public_dir&#125;/.", deploy_dircd "#&#123;deploy_dir&#125;" do system "git add -A" message = "Site updated at #&#123;Time.now.utc&#125;" puts "\n## Committing: #&#123;message&#125;" system "git commit -m \"#&#123;message&#125;\"" puts "\n## Pushing generated #&#123;deploy_dir&#125; website" Bundler.with_clean_env &#123; system "git push origin #&#123;deploy_branch&#125;" &#125; puts "\n## Github Pages deploy complete"# Add your new code here system "git push -u gitcafe master:gitcafe-pages" puts "\n## Gitcafe Pages deploy complete" 在添加这些代码之前，需要先在_deploy中添加remote add gitcafe哦。现在博客也会发布到Gitcafe上了。 #Domain Gitcafe的域名解析要比Github简单许多：在setting-&gt;Pages添加自己的域名即可： 依旧是ping gitcafe.io来查看IP： 然后在自己域名的DNS解析管理中添加新的A记录解析： 中国数据的DNS解析服务提供针对不同线路不同解析的服务，我们可以将国内的电信、联通等解析到Gitcafe的IP上，而将默认线路解析到Github即可实现让国内外不同用户访问不同服务器的策略。 #CDN 刚才已经介绍了，Cloudflare可以让访问你博客的流量通过他们智能的云实现负载均衡。同时Cloudflare还提供对于访问的保护： 通过使用他们的服务，我们网站的内容便可以缓存到世界各地他们的服务器上，Octopress很多模板会用到Google字体，Cloudflare会事先缓存js, css, img；当访客得到回复的html时便会使用本地的js, css迅速渲染。只是改动html的话不会影响他们的缓存，所以博客的访问一方面可以实现负载均衡，也能提升安全，尤其是对于使用个人服务器的情况。Cloudflare对免费非盈利的个人网站提供有免费计划，我们便可以借此来提升博客的浏览体验。 在最上面点Add site后，按照指导一步步走就可以了，最后它会提供给你两个新的DNS: 在我们自己的域名管理页面中，替换原来的Nameserver为Cloudflare的即可： 之后就会发现网页的加载速度非常快了。 Migrate to New Computer当我们需要在多个地方维护博客，或者更换电脑时重新回复博客内容，需要先提交最新的source，之后再在新电脑安装环境即可： 12345678910111213141516171819# old Computercd octopressgit add .git commit -m 'prepare for migration'git push origin source #push 到origin的source分支# new Computer# You need to build your environment first (ruby, python etc)git clone -b source git@github.com:SilentAlice/silentalice.github.io.git octopresscd octopressgit clone -b master git@github.com:SilentAlice/silentalice.github.io.git _deploy# install dependencygem install bundlerbundle install# generate siterake generaterake preview 之后就可以在新电脑上继续维护博客啦~ #Note 360网站卫士公共库停止运行 (2016-09-17)这几天打开网站发现一直卡在ajax.useso.com这边，原来以为是360那边抽风就没鸟，后来查了下发现360已经停止了这个服务(Are u kidding me?!) (公告)http://bbs.360.cn/thread-14471550-1-1.html 不过Google已经在北京设置了服务器，所以直接使用Google API的速度已经非常快了… 于是换回去就行了。 或者在自己的主题里把google api去掉吧..用离线的也行，只不过享受不了google的CDN服务就是了 Google Library (2016-01-30)由于众所周知的原因，国内一般上Google是上不去的。而Octopress的许多主题都会用到Google的公共库，所以导致网页在国内久久不能打开。我刚加上CDN服务的时候由于频繁的访问使得缓存服务器中缓存了Google的文件，所以也没遇到打开很慢的情况。不过后来博客搭起来之后就没有频繁访问了，估计缓存服务器里面也没相应的文件，打开就很慢。不过好在国内有Google公共库的代理。这次尝试的是360的常用前端公共库CDN服务：http://libs.useso.com/ 只需要将所有域名换成对应的useso的即可。 12ajax.googleapis.com -&gt; ajax.useso.comfonts.googleapis.com -&gt; fonts.useso.com Individual Repo (2015-12-02)在添加了home页之后，发现总是出现Not Found。 本来是将home页的工程单独部署到了一个单独的Repository:WebGL，由于Gitcafe和Github会自己将silentalice.github(cafe).io解析到silentming.net，所以本来只要silentming.net/WebGL就可以直接访问新的添加页。 但是由于我使用了CDN加速，CloudFlare在加速的时候会将网页的Img、css等文件提前下载到本地服务器，而我的WebGL不在网页的目录树中，所以本地服务器中没有缓存WebGL的相关内容。 用户在访问的时候会先访问本地服务器，于是就找不到WebGL了orz。 CDN的加速可以让网页访问速度提高3-5倍，实在是不想放弃啊，当初用的时候就有用户提过这个问题，我还完全没有在意，不过现在看来确实这个是它的弊端。 最开始我不想将home的相关内容放到octopress的repo中一是想方便管理，而是以为每次ruby的脚本都会删除和重新创建网站，pull的时候会有很大开销。不过今天发现，source里面的目录也只有post会被重新创建，但是img这些是不会的，所以放进来的开销其实也还好。 GitCafe is gone (2016-07-15)Gitcafe已经合并到coding.net，coding.net由于建立的初衷不是用来建站，因此其演示功能是按天收费的，并且不支持绑定自己的域名而只能使用其提供的二级域名，所以目前我只部署到github上了，不过由于CDN的加速，国内的访问速度依旧非常快。并且将用到google渲染的内容给去掉后，现在也不会因为需要翻墙等原因导致网页加载缓慢。目前就保持这样了…]]></content>
      <tags>
        <tag>tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Octopress博客(2)-将Github Page绑定到自己的域名上]]></title>
    <url>%2Fblog%2F2015%2F11%2F13%2Fdomainname-about-git-page%2F</url>
    <content type="text"><![CDATA[#Introduction 上一篇文章主要介绍了如何在Windows上搭建Octopress博客，我们的博客使用的是Github Page或GitCafe Page，默认情况下访问的域名是username.github.io。如果自己拥有自己的顶级域名的话，就会想要将自己的域名绑到自己的域名上。 #Prerequisite 有自己的域名 我买的是中国数据的顶级域名silentming.net #Octopress 在blog(your blog dir name)/source/ 下新建一个名为CNAME的文件，内容为: Cotent of CNAMEMy CNAME1234silentming.net# 之后重新发布rake deploy 确保在repository的master分支下有CNAME文件，其作用就是将username.github.io映射为CNAME里的域名，所以现在我访问silentalice.github.io就会变成访问silentming.net了 #Domain 首先ping github.io来查看它的IP 在自己的域名管理中进行相应的设置，如果是顶级域名的话要添加一条A记录： 之后就可以使用自己的域名访问博客了]]></content>
      <tags>
        <tag>tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Octopress博客(1)-在windows 10上使用octopress搭建个人博客]]></title>
    <url>%2Fblog%2F2015%2F11%2F13%2Fbuild-blog-on-github-with-octopress%2F</url>
    <content type="text"><![CDATA[#Introduction Octopress是一款基于Jekyll的静态网页生成框架，使用Ruby实现。 Octopress的博客支持Markdown语法，Markdown是一种标记语言，可以快速生成Html并能内嵌Html，因此用来写文章或笔记的效率会很高。 Octopress是静态网页生成框架，因此可以利用GitPage部署在Github上，国内可以部署在Gitcafe上面。 #Prerequisite 了解简单的命令行操作 了解Git的基本操作和分支概念 具有一定的编程基础 了解Html脚本基础 了解简单的Markdown语法 #Preparation 我搭建的环境是Windows 10 64位，Ruby2.2.3, Python2.7.10, Octopress3.0, 命令行用的就是GitBash，没有使用cmd Git: http://git-scm.com/download/ Ruby2.3.3&amp;DevKit: http://rubyinstaller.org/downloads/ Python2.7: https://www.python.org/downloads/ Octopress3.0: git://github.com/imathis/octopress.git 32位的请选择对应的版本，Python只能使用2.7，因为之后要用的一个代码高亮脚本不支持Python3.5 #Installation Git or GitBash的安装就一直next就行 Ruby 一路next，路径中最好不要含有空格或中文,不过注意选择上将ruby的可执行文件添加到环境变量中”Add Ruby executables to PATH”。或者自己在环境变量里配置。安装完成后可以使用Gitbash or cmd 输入ruby --version来查看。 Python2.7 与安装Ruby类似，路径中不要含有中文或空格，添加到PATH也勾选上。 安装DevKit，解压后进入该文件夹，运行 12ruby dk.rb initruby dk.rb install 代码高亮脚本Pygments: 在GitBash中:easy_install pygments 安装完Python后在安装目录下的Scripts文件夹中，应该有easy_install.exe, 如果没有的话请自行下载，并且确保该Scripts文件夹也在环境变量PATH中(我放在全局的PATH中好像用不了，无奈放到了当前用户的PATH路径下才能正常使用) Octopress12345678910cd /D/git clone git://github.com/imathis/octopress.git blog(your dir name)# 安装依赖项gem install bundlerbundle install# 安装octopress默认主题rake installrake preview 之后在浏览器里输入127.0.0.1:4000就可以观看效果了 #Deployment Github Page 在Github上注册一个账号，并新建一个Repository:名为：username.github.io (我的为silentalice.github.io) 在Bash中发布：123456789rake setup_github_pages #配置Github_page的路径，按照提示输入自己的repository地址git@github.com:SilentAlice/silentalice.github.io.gitrake deploy #将网站发布到github的master分支上# 之后可以将源码也放到Git上方便维护：git add .git commit -m "source of octopress"git push origin source # 放到source分支 使用git@github.com这种形式的要用到ssh，有关ssh的文章请参考另一篇文章：《使用SSH通过代理连接Git》 #Note 发布文章或者site的话可以使用： 12345678rake new_post[title of post] # post在source/_post/下rake new_site[name of site] # site会自动生成到source/nameofsite/index.markdown# 写完保存后，就可以生成了rake generate# 最后就是发布rake deploy ###Linux Linux上安装Ruby与Python更加简单，其余的操作和在Windows上是一致的，这也是使用Octopress的优点：跨平台~]]></content>
      <tags>
        <tag>tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新博客开篇]]></title>
    <url>%2Fblog%2F2015%2F11%2F11%2Fbegin%2F</url>
    <content type="text"><![CDATA[刚开始接触博客是从初三开始的，那个时候还在用百度空间，也通过百度空间认识了好多小伙伴，也是中二满满的我刚入动漫坑的时候，写的文章也都是一些中二少年强行说愁或者强行文艺的黑历史。 百度空间后来被砍掉后就尝试使用新浪微博或者QQ空间，但是总觉得鱼龙混杂，不是很喜欢里面花花绿绿的东西，到现在我的 QQ空间都还保留着高一的样子orz。背景音乐也是xxxHolic里的19歳。 在大一选择软件工程这个专业之后，就曾经萌生过写技术博客的想法用来记录一些点点滴滴，企图使用csdn。但是发现自己总是在不务正业，写的内容也跟技术八竿子打不着，所以就一直闲置了。 接触github是在大三的时候，当时和其他小伙伴为了一起写一个LeapMotion的桌面应用，所以就学习了Git(那时还是很拒绝命令行的，用了Tortoise的图形化，也不懂ssh是个什么鬼)。直到现在才基本上是开始使用Git。也是在那个时候学习了Markdown语法。 几乎和接触Github是同时，我被推荐了WizNote。一款国产的笔记软件，由于其功能齐全，界面简洁美观，而且笔记支持markdown语法，所以就选择了它而没有选择evernote。自己也一直使用markdown来写笔记。 在新的实验室学习时，读了指导我的聪聪大哥的博客后发现使用Octopress+Github可以搭建属于自己的博客，而且Octopress支持markdown，这刚好解决了我既想写技术博客又想写生活文章的问题，同时还能让我轻松的把Wiznote上的笔记移过来，加上能够高度定制自己的博客，所以果断就有样学样的搭建了一个博客。 希望我之后能坚持下去，把自己学习到的和感悟到的都记录下来…]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown Testing]]></title>
    <url>%2Fblog%2F2015%2F11%2F06%2Ffirst-post-for-testing%2F</url>
    <content type="text"><![CDATA[This page is used for individual blog. Thus, I don’t need any design services. Thanks. Title: #h1 ##h2 ######h6 List: First Second Third Forth Fifth Sixth Seventh Code Block Supported Languates link is baidusource article1234#include&lt;stdio.h&gt;printf("This is a code block\n");//Hello Word /*Comment*/ this is a code Reference This is a reference aaa bbb ccc left center right aaaaaaaa bbbbbbbbb cccccccccc Header Test 1Header Test 2Header Test 3This is code **BLock** Hello World test code bodle hello titlelinks1This is a code block [link1][Header Test 1] link1.1 link2 link3]]></content>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
</search>
